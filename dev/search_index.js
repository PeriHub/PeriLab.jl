var documenterSearchIndex = {"docs":
[{"location":"lecture/seminar_3/#Seminar-3:-Convergence-and-fracture","page":"Seminar 3","title":"Seminar 3: Convergence and fracture","text":"","category":"section"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"Convergence","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"For FEM an error estimation is given bei [25]","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"e=Ch^p","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"Parameter Definition\ne Error\nh Mesh size (h  1)\nC Constant\np Polynomial order","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"hrightarrow 0","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"leads to erightarrow 0; if analytical solutions exist","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"info: Limitions\nIf the fundamental assumptions of classical continuum mechanics are violated, e.g. second derivative of u exists.","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"Peridynamics","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"(Image: )","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"Figure taken from [1]","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"(Image: )","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"Figure taken from [32]","category":"page"},{"location":"lecture/seminar_3/#Damage-models","page":"Seminar 3","title":"Damage models","text":"","category":"section"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"rho ddotu_i = frac12sum_j mu_ij(f_jiV_i-f_ijV_j)+b_i","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"mu_ij=begincases\n  1  textif undamaged  \n  0  textif damaged\nendcases","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"(Image: )","category":"page"},{"location":"lecture/seminar_3/#Critical-stretch","page":"Seminar 3","title":"Critical stretch","text":"","category":"section"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"The critical stretch model is widely used in literature [1], [33]. It defines the critical length change, or stretch s as a criterion for a damage.","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"Herleitung Bednarek","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"s_critleq s frac underlinemathbfY  underlinemathbfX ","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"s_crit = sqrtfracG_0C3G+(frac34)^4(K-frac5G3)delta","category":"page"},{"location":"lecture/seminar_3/#Critical-energy","page":"Seminar 3","title":"Critical energy","text":"","category":"section"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"The critical energy model introduced by [34] is valid for state-based peridynamic and bond-based analysis. The bond energy is defined as:","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"w_bond = int_boldsymboleta_final (mathbfunderlineTxtlangle x-xrangle - mathbfunderlineTxtlangle x-xrangle)dboldsymboleta","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"with the relative displacement vector as:","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"boldsymboleta=mathbfunderlineuxt-mathbfunderlineuxt","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"If the bond energy is bigger than or equal to the critical energy value, then the bond is considered to be broken:","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"w_crit leq w_bond","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"The critical bond energy can be defined as:","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"w_crit = frac4G_0Cpidelta^4","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"(Image: )","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"w_crit=2int_0^deltaint_mathcalHw_cdV=int_0^deltaint_0^2piint_z^deltaint_0^cos^-1zxiw_cxi^2sinphi dphi dxi domega dz","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"Equations are taken from [4].","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"","category":"page"},{"location":"lecture/seminar_3/#Differences","page":"Seminar 3","title":"Differences","text":"","category":"section"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"discussion in the seminar\ndirection\nexperimental","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"","category":"page"},{"location":"lecture/seminar_3/#Numerical-integration","page":"Seminar 3","title":"Numerical integration","text":"","category":"section"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"Integration of damage model","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"## Code concept\n\n#Run material\n#Evaluate Damage\n#Run Material\n\nomega = ones(length(nodes), nneighbor)\n\n\nfor idt in time\n\n    K = create_K(omega)\n\n    u = inv(K)*F_V # or from time integration\n\n    for iID in nodes\n        for jID in nlist[iID]\n            s = (u[iID]+x[iID]-(u[jID]+x[jID]))/(x[jID]-x[iID])\n            if  s>s_crit\n                omega[i,j]=0\n            end\n        end\n    end\n\n    K = create_K(omega)\n\n    u = inv(K)*F_V # or from time integration\n\n    ...\nend","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"using LinearAlgebra\n\n\nfunction K_stiff(np, c, omega, V)\n    K=zeros(np,np)\n    for iID in 1:np\n        for jID in -nn:nn\n            if jID != 0 && iID + jID > 0 && iID + jID < np + 1\n                xi = L*abs(jID)\n                K[iID, iID + jID] -= 0.5 * c[iID] / xi * V * omega[iID, iID + jID]\n                K[iID, iID]      +=  0.5 *c[iID] / xi * V * omega[iID, iID + jID]\n            end\n        end\n    end\n    K[np, :] .= 0\n    K[:, np] .= 0\n    K[np, np] = 1\n    return K\nend\n\nE = 1\nV = 1\nL = 1\nnp = 8\nnn = 2\ndelta = 1\nu = zeros(np)\nu[1]=0.125\nomega=ones(np, np)\n\n\n##\nc=zeros(np)\nc .= 2*E/delta^2\nc[4]=1.5 .*c[4]\n\nK_undam = K_stiff(np, c, omega, V)\nomega[1,2] = 0\nK_d = K_stiff(np, c, omega, V)\nomega[2,1] = 0\nK_dsym = K_stiff(np, c, omega, V)\nomega[1,3] = 0\nomega[3,1] = 0\nK_full_dam = K_stiff(np, c, omega, V)\n\n## Damage\n\n\nM = [\"no damage\" \"damage\" \"damage sym\" \"damage full\";K_undam*u K_d*u K_dsym*u K_full_dam*u]\ndisplay(M)\n#--------------------------\nprintln(\"Rank\")\nM = [\"no damage\" \"damage\" \"damage sym\" \"damage full\";\nrank(K_undam) rank(K_d) rank(K_dsym) rank(K_full_dam)]\ndisplay(M)\n","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"Discussion","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"How many bonds are allowed to break per time step?\nSize of the horizon?","category":"page"},{"location":"lecture/seminar_3/","page":"Seminar 3","title":"Seminar 3","text":"","category":"page"},{"location":"man/models/contact/#Contact","page":"Contact Models","title":"Contact","text":"","category":"section"},{"location":"man/models/contact/#Contact-Search","page":"Contact Models","title":"Contact Search","text":"","category":"section"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Parameter Unit Description\nContact Radius m Radius to get a list of potential contact pairs.\nMaster - Block ID of the master nodes.\nSlave - Block ID of the slave nodes.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Initialization","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Step 1 -","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Identification of all surface nodes of contact blocks.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Step 2 -","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"All surface nodes are stored in a list. This list exists at all cores with the current position of the surface nodes.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Step 3 -","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Connect each surface node to a geometrical surface.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"The standard way for points in the parallelization is given here.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"beginbmatrix1  2  3  4  5  6  7 endbmatrix_allrightarrowbeginmatrix beginbmatrix 4  6  endbmatrix_C1-global\nbeginbmatrix1  2   7 endbmatrix_C2-global\nbeginbmatrix35endbmatrix_C3-globalendmatrixleftarrow rightarrowbeginmatrix beginbmatrix 1  2  endbmatrix_C1-local\nbeginbmatrix1  2   3 endbmatrix_C2-local\nbeginbmatrix12endbmatrix_C3-localendmatrix","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"A new mapping is needed to the contact surface exchange list. The local numbering (right above) has to be mapped to the sublist and vice, versa.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"beginbmatrix1  2    6  7 endbmatrix_surfaceleftarrowrightarrow beginbmatrix1  2   3  4  endbmatrix_surfacerightarrow beginmatrix beginbmatrix  6  endbmatrix_C1\nbeginbmatrix1  2   7 endbmatrix_C2\nbeginbmatrixendbmatrix_C3endmatrixleftarrow rightarrowbeginmatrix beginbmatrix 2   endbmatrix_C1-local\nbeginbmatrix1  2   3 endbmatrix_C2-local\nbeginbmatrixendbmatrix_C3-localendmatrix","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"List mapping To fill the postion vector with the needed values mappings are needed.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"local point ids -> global point id -> reduced contact block point id The mapping has to be done in both directions, because the contact forces have to be applied to the local core point id.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Computation","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Step 1 -","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Perform a nearest neighbor search with a user defined Contact Radius. The result is a list of potential contact pairs.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Step 2 -","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"A sub list nearest neighbor search is performed.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Step 3 -","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"All points found are than in contact.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"The quasi code is given here","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"# synchronize all contact nodes\nsynchronize_contact_points(datamanager, \"Deformed Coordinates\", \"NP1\",\n                                               all_positions)\n\n## loop over all contact pairs\nfor (cm, block_contact_params) in pairs(contact_params)\n    contact_search(...)\nend\n\nfunction contact_search(...)\n    if n < search_frequency\n        potential_contact_list = global_search(...) # finds all points within the search radius\n        local_search(...)\n        return\n    else\n        synchronize_contact_points(datamanager, \"Deformed Coordinates\", \"NP1\",\n                                               all_positions[potential_contact_list])\n        local_search(...)   # finds all points within the contact radius\n        return\n    end\nend\n","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"The structure tries to minimize the search and the communication between cores.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Synchronization All cores (except core 1) send it's displacement values to core 1. Core 1 sends them back.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"note: Efficiency\nSmaller contact areas are more efficient in numerical analysis, because less synchronisation have to occur.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"","category":"page"},{"location":"man/models/contact/#Contact-Models","page":"Contact Models","title":"Contact Models","text":"","category":"section"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Contact Model Penalty Contact\nContact Stiffness âœ”ï¸","category":"page"},{"location":"man/models/contact/#Penalty-Contact","page":"Contact Models","title":"Penalty Contact","text":"","category":"section"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"A bond-based contact formulation is computed. The contact stiffness $ c{contact}$ is defined in YAML input file. Based on that utilzing the horizon delta the penalty stiffness shown in the table is computed. These parameter are comparable to the bond-based formulation. The algorithm was taken from [Peridigm](https://github.com/peridigm/peridigm/blob/master/src/contact/PeridigmShortRangeForceContactModel.cpp)","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Dimension Penalty Stiffness\nplane strain: c_Penalty = frac48 c_contactpi 5 delta_slave^3\nplane stress: c_Penalty = frac9 c_contactpi delta_slave^3\n3D: c_Penalty = frac12 c_contactpi  delta_slave^4","category":"page"},{"location":"man/models/contact/#Normal-Contact","page":"Contact Models","title":"Normal Contact","text":"","category":"section"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"The distance is currently computed as","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"d = underlinemathbfY_master-underlinemathbfY_slave","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"The normal is","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"mathbfn = fracunderlinemathbfY_master-underlinemathbfY_slaved","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Both can be adopted if needed. Utilizing the contact radius r_contact the contact force densities are","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"\nmathbff_master = c_Penaltyfrac(r_contact-d)delta_slavemathbfnV_slave","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"mathbff_slave = -c_Penaltyfrac(r_contact-d)delta_slavemathbfnV_master","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Within PeriLab the functions computemasterforcedensity and computeslaveforcedensity are used to apply the force to the correct postions. This is needed, becaus if a parallel process is run, master and slave nodes not necessarily are on the same core.","category":"page"},{"location":"man/models/contact/#Friction-Contact","page":"Contact Models","title":"Friction Contact","text":"","category":"section"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Contact Model Penalty Contact\nFriction Coeffient âœ”ï¸","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"The model is computed if the \"\"Friction Coeffient\"\" is greater than zero. For friction the normal forces mathbff_n=c_Penaltyfrac(r_contact-d)delta_slavemathbfn are used. The tangential direction must be computed. Following the Peridigm algorithm, the normal velocity of the master node m and the slave node s are","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"beginmatrix\nv_m = mathbfv_mmathbfn\nv_s = mathbfv_smathbfn\nendmatrix","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"To obtain the tangential part tan this value hmust be substrated from the velocity. beginmatrix mathbfv_tan-m = mathbfv_m - v_mmathbfn\nmathbfv_tan-s = mathbfv_s - v_smathbfn endmatrix","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"Tanking the average mathbfv_avg = 05(mathbfv_tan-m+mathbfv_tan-s) the relative velocity of each point can be determined. beginmatrix mathbfv_tan-m = mathbfv_tan-m - mathbfv_avg\nmathbfv_tan-s = mathbfv_tan-s - mathbfv_avg endmatrix If the length of mathbfv_tan-m and mathbfv_tan-s is greater than zero, respectively, friction occurs. The friction force is computed as using the friction coefficient mu.","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"beginmatrix\nmathbff_fric-m = -mu mathbff_nfracmathbfv_tan-mmathbfv_tan-m\nmathbff_fric-s = -mu mathbff_nfracmathbfv_tan-smathbfv_tan-s\nendmatrix","category":"page"},{"location":"man/models/contact/","page":"Contact Models","title":"Contact Models","text":"","category":"page"},{"location":"man/bond_filter/#Bond-Filters","page":"Bond-Filter","title":"Bond-Filters","text":"","category":"section"},{"location":"man/bond_filter/#Rectangular-Plane","page":"Bond-Filter","title":"Rectangular Plane","text":"","category":"section"},{"location":"man/bond_filter/","page":"Bond-Filter","title":"Bond-Filter","text":"For a recangular plane following parameters needs to be defined:","category":"page"},{"location":"man/bond_filter/","page":"Bond-Filter","title":"Bond-Filter","text":"Normal X/Y/Z: Numeric values representing normal components. (Float64 or Int64)\nLower Left Corner X/Y/Z: Numeric values representing lower left corner components. (Float64 or Int64)\nBottom Unit Vector X/Y/Z: Numeric values representing bottom unit vector components. (Float64 or Int64)\nBottom Length: Numeric value representing the bottom length. (Float64 or Int64)\nSide Length: Numeric value representing the side length. (Float64 or Int64)","category":"page"},{"location":"man/bond_filter/","page":"Bond-Filter","title":"Bond-Filter","text":"(Image: Discretization_BondFilters_RectangularPlane)","category":"page"},{"location":"man/bond_filter/#Disk","page":"Bond-Filter","title":"Disk","text":"","category":"section"},{"location":"man/bond_filter/","page":"Bond-Filter","title":"Bond-Filter","text":"For a disk following parameters needs to be defined:","category":"page"},{"location":"man/bond_filter/","page":"Bond-Filter","title":"Bond-Filter","text":"Normal X/Y/Z: Numeric values representing normal components. (Float64 or Int64)\nCenter X/Y/Z: Numeric values representing center components. (Float64 or Int64)\nRadius: Numeric value representing the radius. (Float64 or Int64)","category":"page"},{"location":"man/bond_filter/","page":"Bond-Filter","title":"Bond-Filter","text":"","category":"page"},{"location":"man/solver/solver/#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"Parameter Type Optional Description\nMaterial Models Bool Yes Activates the time integration for materials and material evaluation\nDamage Models Bool Yes Activates the damage evaluation\nThermal Models Bool Yes Activates the time integration for thermal models and thermal model evaluation\nAdditive Models Bool Yes Activates the additive model evaluation\nMaximum Damage Float Yes Defines the maximum damage in one point\nInitial Time Float No Defines the initial time\nFinal Time Float No Defines the final time\nFixed dt Float Yes Defines a fixed time step\nNumber of Steps Int Yes Defines a fixed number of steps\nVerlet Dict Yes Defines the Verlet solver\nStatic Dict Yes Defines the Static solver","category":"page"},{"location":"man/solver/solver/#Verlet","page":"Solver","title":"Verlet","text":"","category":"section"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"Parameter Type Optional Description\nSafety Factor Float Yes Defines a scaling factor for the time increment\nNumerical Damping Float Yes Defines a damping factor","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"warning: Fixed dt\nIf a fixed time step is defined, the time integration can become unstable.","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"The Verlet time integration is used as standard solver for dynamic hyperbolic differential equation of motion. It is also used in Peridigm [3]. The displacements for step i+1 are solved as follows","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"mathbfu_i+1 = mathbfu_i + Delta tdotmathbfu_i + frac12 Delta t^2ddotmathbfu_i","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"with","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"ddotmathbfu_i = fracmathbfF_irho","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"where rho is the mass density of the point and mathbfF_i=mathbfF_external-mathbfF_internal for the current time step.","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"For parabolic time integration as in temperature models the following schema is used","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"boldsymboltau_i+1 =  boldsymboltau_i - Delta t fracmathbfHrho C_v","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"where rho is the mass density, C_v is the specific heat capacity and mathbfH is the heat flux of each point [10].","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"For the time intergration a stable increment has to be determined.","category":"page"},{"location":"man/solver/solver/#Static","page":"Solver","title":"Static","text":"","category":"section"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"Parameter Type Optional Description\nNLsolve Bool Yes Place Holder\nSolution tolerance Float Yes Defines how much change between two iterations of the solution variable is allowed.\nResidual tolerance Float Yes Defines how much change between two iterations of the maximum residual variable is allowed.\nMaximum number of iterations Int Yes Maximum number of iteration of the solver.\nShow solver iteration Bool Yes Shows additional information\nResidual scaling Float Yes Scales the residual and the variable in same order. Should be in the range of the Young's modulus.\nSolver Type String Yes not implmented yet\nm Int Yes Only for Anderson solver;  It does not use Jacobian information or linesearch, but has a history whose size is controlled by the m parameter: m=0 corresponds to the simple fixed-point iteration above, and higher values use a larger history size to accelerate the iterations. Higher values of m usually increase the speed of convergence, but increase the storage and computation requirements and might lead to instabilities. m=15 is set as standard value.\nLinear Start Value Vector{Float} Yes Defines start and end values of a linear function over the length of the model (detailed explanation in the text)","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"The static solver from NLsolve.jl has been included. Specifically the method = :anderson is used.","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"The solver computes the residual of the internal reaction force densities and the external applied force densities r =  leftunderlinemathbfT_external + underlinemathbfT_internalright  s_Residualscaling","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"Right now the default value m of the Anderson acceleration method is chosen.","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"s_Residualscaling","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"should be in the range of the Young's modulus and is than scaled by the volume.","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"s_Residualscaling = minimum(volume)^2","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"warning: Multiphysics\nCurrently only the mechanical solver is included!","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"Start Value","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"The start value defines the values taken for the first iteration. The default is zero. Two options are possible. The first option defines start values in the mesh file. The name is","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"start_values_x\nstart_values_y\nstart_values_z (optional)","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"These numbers are stored in the datamanager and are used for the iteration.","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"The alternative is to define a Linear Start Value as it is given as option in the list above. This list defines values for 3D as","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"start_val = A_x-minA_x-maxA_y-minA_y-maxA_z-minA_z-max","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"and for 2D","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"start_val = A_x-minA_x-maxA_y-minA_y-max","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"where A are amplitude values chosen by the user.","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"With these values the field ''start_values'' is computed as","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"start_value(xyz (optional))= fraca(xyz(optional))cdot coordinates+n(xyz(optional))nsteps","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"a(xyz (optional))=fractextmax(start_val)-textmin(start_val)textmax(coordinates)-textmin(coordinates)","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"and","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"n(xyz (optional))=textmax(start_val)-a(xyz (optional))textmax(coordinates)","category":"page"},{"location":"man/solver/solver/","page":"Solver","title":"Solver","text":"","category":"page"},{"location":"lib/faq/#PeriLab-Frequently-Asked-Questions-(FAQ)","page":"FAQ","title":"PeriLab - Frequently Asked Questions (FAQ)","text":"","category":"section"},{"location":"lib/faq/#General-Questions","page":"FAQ","title":"General Questions","text":"","category":"section"},{"location":"lib/faq/#What-is-PeriLab?","page":"FAQ","title":"What is PeriLab?","text":"","category":"section"},{"location":"lib/faq/","page":"FAQ","title":"FAQ","text":"PeriLab is a peridynamic simulation software designed for different kind of mechanical problems.","category":"page"},{"location":"lib/faq/#Installation-and-Setup","page":"FAQ","title":"Installation and Setup","text":"","category":"section"},{"location":"lib/faq/#What-are-the-system-requirements-for-installing-PeriLab?","page":"FAQ","title":"What are the system requirements for installing PeriLab?","text":"","category":"section"},{"location":"lib/faq/","page":"FAQ","title":"FAQ","text":"In order to install PeriLab, you will need to have a recent version of Julia or Docker installed on your system.","category":"page"},{"location":"lib/faq/#How-do-I-update-my-PeriLab-software?","page":"FAQ","title":"How do I update my PeriLab software?","text":"","category":"section"},{"location":"lib/faq/","page":"FAQ","title":"FAQ","text":"To update PeriLab you just need to run julia -e \"using Pkg; Pkg.update()\" or pull the latest version of the PeriLab Docker image.","category":"page"},{"location":"lib/faq/#Simulation-and-Analysis","page":"FAQ","title":"Simulation and Analysis","text":"","category":"section"},{"location":"lib/faq/#How-can-I-generate-my-own-input-mesh?","page":"FAQ","title":"How can I generate my own input mesh?","text":"","category":"section"},{"location":"lib/faq/","page":"FAQ","title":"FAQ","text":"There are multiple options to generate your own input mesh:","category":"page"},{"location":"lib/faq/","page":"FAQ","title":"FAQ","text":"Use the Perihub framework to generate your own input mesh.\nGenerate your own input mesh with julia, here is an example.\nCreate a .png image of your 2D model and translate it with this script.\nUse an existing Abaqus Inputfile (.inp).\nTransfer your mesh using meshio\nCreate a feature issue and let us know what you need.","category":"page"},{"location":"lib/faq/#What-to-do-with-my-results?","page":"FAQ","title":"What to do with my results?","text":"","category":"section"},{"location":"lib/faq/","page":"FAQ","title":"FAQ","text":"First of all congratulations ðŸŽ‰ on the success of your simulation. Now, you can take a look at your results. To do that, you can use ParaView it's free and very powerful.","category":"page"},{"location":"lib/faq/#Can-I-customize-parameters-for-my-simulations-in-PeriLab?","page":"FAQ","title":"Can I customize parameters for my simulations in PeriLab?","text":"","category":"section"},{"location":"lib/faq/","page":"FAQ","title":"FAQ","text":"Yes, PeriLab allows users to customize various parameters to tailor simulations based on their specific requirements.","category":"page"},{"location":"lib/faq/#Troubleshooting","page":"FAQ","title":"Troubleshooting","text":"","category":"section"},{"location":"lib/faq/#I'm-experiencing-technical-issues-with-PeriLab.-What-should-I-do?","page":"FAQ","title":"I'm experiencing technical issues with PeriLab. What should I do?","text":"","category":"section"},{"location":"lib/faq/","page":"FAQ","title":"FAQ","text":"If you encounter technical issues, please create an issue and describe it in detail.","category":"page"},{"location":"lib/faq/#Additional-Assistance","page":"FAQ","title":"Additional Assistance","text":"","category":"section"},{"location":"lib/faq/","page":"FAQ","title":"FAQ","text":"If your question is not addressed here, please feel free to contact us or create an issue for further assistance.","category":"page"},{"location":"lib/faq/#Contributions","page":"FAQ","title":"Contributions","text":"","category":"section"},{"location":"lib/faq/","page":"FAQ","title":"FAQ","text":"Contributions are always welcomed, take a look at the Contributing Guidelines","category":"page"},{"location":"lib/faq/","page":"FAQ","title":"FAQ","text":"","category":"page"},{"location":"theory/theory_FEM/#Finite-Element-Method","page":"FEM","title":"Finite Element Method","text":"","category":"section"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"The elements in PeriLab are formulated using the matrix of shape functions mathbfN and the matrix of derivatives mathbfB [25], [26].","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"mathbfM=mathbfN^TmathbfNrho","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"To run a point wise analysis and bring it into the same structure as the PD formulation the lumped mass matrix form is used","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"m_i=sumlimits_j=1^n M_ij","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"to get a diagonal mass matrix. To compute the stiffness matrix the following form is used.","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"mathbfK=int_VmathbfB^Tboldsymbolsigma(boldsymbolvarepsilon)dV","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"The element strain is given as","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"boldsymbolvarepsilon=mathbfB^Tmathbfu","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"This formulation allows the flexible integration of material laws. Using the linear elastic material with the elasticity matrix mathbfC","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"mathbfK=int_V mathbfB^TmathbfCBdV","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"Module Related Model in PeriLab\nLagrange_element Lagrange","category":"page"},{"location":"theory/theory_FEM/#Lagrange-functions","page":"FEM","title":"Lagrange functions","text":"","category":"section"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"Lagrange polynomials can be used to formulated finite elements [27]. These polynomials can be defined recursively for a polynomial p.","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"L(x) =  prodlimits_beginsmallmatrix0le mle p mneq jendsmallmatrix fracx-x_mx_j-x_m","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"The values x are defined in local coordinated -11. These shape functions can be defined seperatly for each direction, also with different polynomial orders. In combination these functions are used in the matrix mathbfN.","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"The derivative can be computed recursively as well.","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"L_j(x)=L_j(x)sumlimits_beginsmallmatrixi=0 ineq jendsmallmatrix^pfrac1x-x_i","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"The number of nodes per element is depended on the degrees of freedom (dof) (p+1)^dof.","category":"page"},{"location":"theory/theory_FEM/","page":"FEM","title":"FEM","text":"","category":"page"},{"location":"lib/references/","page":"References","title":"References","text":"F.Â Bobaru, J.Â T.Â Foster, P.Â H.Â Geubelle and S.Â A.Â Silling. Handbook of Peridynamic Modeling. Advances in Applied Mathematics (CRC Press, 2016).\n\n\n\nL.Â Beuth. Formulation and Application of a Quasi-Static Material Point Method. PhD thesis, Institut fÃ¼r Geotechnik, UniversitÃ¤t Stuttgart (Stuttgart, 2012).\n\n\n\nD.Â J.Â Littlewood, M.Â L.Â Parks, J.Â T.Â Foster, J.Â A.Â Mitchell and P.Â Diehl. The Peridigm Meshfree Peridynamics Code. JournalÂ ofÂ PeridynamicsÂ andÂ NonlocalÂ Modeling (2023).\n\n\n\nC.Â Willberg, L.Â Wiedemann and M.Â RÃ¤del. A mode-dependent energy-based damage model for peridynamics and its implementation. JournalÂ ofÂ MechanicsÂ ofÂ MaterialsÂ andÂ Structures 14, 193â€“217 (2019).\n\n\n\nC.Â Willberg, J.-T.Â Hesse, M.Â Garbade, M.Â RÃ¤del, F.Â Heinecke, A.Â Schuster and A.Â Pernatii. A user material interface for the Peridynamic Peridigm framework. SoftwareX 21, 101322 (2023).\n\n\n\nJ.-T.Â Hesse, C.Â Willberg, R.Â Hein and F.Â Winkelmann. Peridynamic framework to model additive manufacturing processes. PAMM n/a, e202300033 (2023).\n\n\n\nC.Â Willberg, J.-T.Â Hesse and A.Â Pernatii. PeriLab - Peridynamic Laboratory. SoftwareX 26 (2024).\n\n\n\nK.Â Partmann, M.Â Dienst and K.Â Weinberg. Peridynamic computations of wave propagation and reflection at material interfaces. ArchiveÂ ofÂ AppliedÂ Mechanics 94, 2405â€“2416 (2024).\n\n\n\nC.Â Willberg, J.-T.Â Hesse, F.Â Winkelmann and R.Â Hein. Peridynamic Framework to Model Additive Manufacturing Processes. AdvancedÂ TheoryÂ andÂ Simulations n/a, 2400818 (2024).\n\n\n\nS.Â Oterkus, E.Â Madenci and A.Â Agwai. Peridynamic thermal diffusion. JournalÂ ofÂ ComputationalÂ Models 265, 71â€“96 (2014).\n\n\n\nJ.Â Trageser and P.Â Seleson. Bond-Based Peridynamics: a Tale of Two Poisson's Ratios. JournalÂ ofÂ PeridynamicsÂ andÂ NonlocalÂ Modeling 2, 278â€“288 (2020).\n\n\n\nJ.Â Guan and L.Â Guo. A unified bond-based peridynamic model without limitation of Poisson's ratio. AppliedÂ MathematicalÂ Modelling 128, 609â€“629 (2024).\n\n\n\nJ.Â Guan, W.Â Li, X.Â Yan and L.Â Guo. An incremental bond-based peridynamic method for elastoplastic problems. InternationalÂ JournalÂ forÂ NumericalÂ MethodsÂ inÂ Engineering 124, 3875â€“3902 (2023).\n\n\n\nS.Â A.Â Silling, M.Â Epton, O.Â Weckner, J.Â Xu and E.Â Askari. Peridynamic States and Constitutive Modeling. JournalÂ ofÂ Elasticity 88, 151â€“184 (2007).\n\n\n\nM.Â R.Â Tupek. Extension of the peridynamic theory of solids for the simulation of materials under extreme loadings. Ph.D. Thesis, Massachusetts Intitute of Technology (2014).\n\n\n\nM.Â Breitenfeld, P.Â Geubelle, O.Â Weckner and S.Â A.Â Silling. Non-ordinary state-based peridynamic analysis of stationary crack problems. ComputerÂ MethodsÂ inÂ AppliedÂ MechanicsÂ andÂ Engineering 272, 233â€“250 (2014).\n\n\n\nH.Â Chen. Bond-associated deformation gradients for peridynamic correspondence model. MechanicsÂ ResearchÂ Communications 90, 34â€“41 (2018).\n\n\n\nP.Â Li, Z.Â Hao and W.Â Zhen. A stabilized non-ordinary state-based peridynamic model. ComputerÂ MethodsÂ inÂ AppliedÂ MechanicsÂ andÂ Engineering 339, 262â€“280 (2018).\n\n\n\nM.Â Tupek and R.Â Radovitzky. An extended constitutive correspondence formulation of peridynamics based on nonlinear bond-strain measures. JournalÂ ofÂ theÂ MechanicsÂ andÂ PhysicsÂ ofÂ Solids 65, 82â€“92 (2014).\n\n\n\nC.Â Wu. Kinematic constraints in the state-based peridynamics with mixed local/nonlocal gradient approximations. ComputationalÂ Mechanics 54, 1255â€“1267 (2014).\n\n\n\nC.Â Wu and B.Â Ren. A stabilized non-ordinary state-based peridynamics for the nonlocal ductile material failure analysis in metal machining process. ComputerÂ MethodsÂ inÂ AppliedÂ MechanicsÂ andÂ Engineering 291, 197â€“215 (2015).\n\n\n\nJ.Â Wan, Z.Â Chen, X.Â Chu and H.Â Liu. Improved method for zero-energy mode suppression in peridynamic correspondence model. ActaÂ MechanicaÂ Sinica 35, 1021â€“1035 (2019).\n\n\n\nS.Â A.Â Silling. Stability of peridynamic correspondence material models and their particle discretizations. ComputerÂ MethodsÂ inÂ AppliedÂ MechanicsÂ andÂ Engineering 332, 42â€“57 (2017).\n\n\n\nS.Â Oterkus, E.Â Madenci and A.Â Agwai. Fully coupled peridynamic thermomechanics. JournalÂ ofÂ theÂ MechanicsÂ andÂ ModelsÂ ofÂ Solids 64, 1â€“23 (2014).\n\n\n\nO.Â C.Â Zienkiewicz, R.Â L.Â Taylor and J.Â Z.Â Zhu. The Finite Element Method: Its Basis and Fundamentals. 7thÂ Edition (Butterworth-Heinemann, 2013).\n\n\n\nC.Â Willberg. Development of a new isogeometric finite element and its application for Lamb wave based structural health monitoring. Dissertation, Otto von Guericke University Magdeburg (2012). Open-Access-Publikation.\n\n\n\nM.Â Abramowitz and I.Â A.Â Stegun. Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables. Vol.Â 55 of Applied Mathematics Series (United States Department of Commerce, National Bureau of Standards; Dover Publications, Washington D.C.; New York, 1983); p.Â 878. [June 1964], Ninth reprint with additional corrections of tenth original printing with corrections (December 1972); first edition.\n\n\n\nA.Â Pernatii, U.Â Gabbert, K.Â Naumenko, J.-T.Â Hesse and C.Â Willberg. A Penalty Method for Coupling of Finite-Element and Peridynamic Models. PAMM 22, e202200151 (2023).\n\n\n\nC.Â Willberg, J.-T.Â Hesse and A.Â Pernatii. Version v1.3.6 - PeriLab - Peridynamic Laboratory. SoftwareX 31, 102168 (2025).\n\n\n\nQ.Â V.Â Le and F.Â Bobaru. Surface corrections for peridynamic models in elasticity and fracture. ComputationalÂ Mechanics 61, 499â€“518 (2018).\n\n\n\nA.Â Masoumi, M.Â Salehi and M.Â Ravandi. A modified bond-based peridynamic model without limitations on elastic properties. EngineeringÂ AnalysisÂ withÂ BoundaryÂ Elements 149, 261â€“281 (2023).\n\n\n\nA.Â Pernatii, D.Â Filiurskyi, U.Â Gabbert, J.-T.Â Hesse and C.Â Willberg. Brittle fracture investigation in a coupled FEM-PD model. PAMM 24, e202400021 (2024).\n\n\n\nE.Â Madenci and E.Â Oterkus. Peridynamic Theory and Its Applications (Springer New York, 2014).\n\n\n\nJ.Â T.Â Foster, S.Â A.Â Silling and W.Â Chen. An Energy based Failure Criterion for use with Peridynamic States. InternationalÂ JournalÂ forÂ MultiscaleÂ ComputationalÂ Engineering 9, 675â€“688 (2011).\n\n\n\nM.Â RÃ¤del, A.-J.Â Bednarek and C.Â Willberg. Influence of probabilistic material distribution in peridynamics to the crack initiation. In: 6th ECCOMAS Thematic Conference on the Mechanical Response of Composites: COMPOSITES 2017 (2017).\n\n\n\nR.Â Brighenti, M.Â A.Â Zeleke and M.Â B.Â Ageze. A Review of Peridynamics (PD) Theory of Diffusion Based Problems. JournalÂ ofÂ Engineering, 20 (2021).\n\n\n\nD.Â J.Â Littlewood, J.Â D.Â Thomas and T.Â Shelton. Estimation of the Critical Time Step for Peridynamic Models. In: Proceedings of the 12th U.S. National Congress on Computational Mechanics (2013).\n\n\n\n","category":"page"},{"location":"lib/references/","page":"References","title":"References","text":"","category":"page"},{"location":"man/mesh_input/#Mesh-Input-File-Structure","page":"Mesh and Nodesets","title":"Mesh Input File Structure","text":"","category":"section"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"The mesh input file is a text or exodus file used to define the geometry of the simulation domain. The file has a header and subsequent lines representing individual nodes with their corresponding coordinates, block IDs, volumes, and optional user-defined values. Below is an example of the structure:","category":"page"},{"location":"man/mesh_input/#Header","page":"Mesh and Nodesets","title":"Header","text":"","category":"section"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"The header of the mesh input file specifies the format of the subsequent data columns. In this example, the header consists of the following columns:","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"Variable definition","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"Parameter Datamanager name Header name 2D Header name 3D Type\nx, y, z (optional) coordinate of the node Coordinates x, y x, y, z Float64, Int64\nDefinition to which block the node corresponds. Is needed in the Yaml file to define properties Block_Id block_id block_id Int64\nVolume the node represents. Volume volume volume Float64, Int64","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"Optional","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"Parameter Datamanager name Header name 2D Header name 3D Type\nOrientation of a Node Angles Angles Anglesx, Anglesy, Anglesz Float64, Int64\nActivation time of a node, e.g. used for additive manufacturing to define when the node will be acativated Activation_Time Activation_Time Activation_Time Float64, Int64\nStatus of the node. If it is false the node is deactivated, but exists. This variable is automatically created if additive models are used and set everywhere to false, if it is not predefined Active Active Active Bool","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"The difference between 2D and 3D is found automatically. If no z occurs PeriLab identifies it as 2D problem and requests a plane stress or plane strain definition.","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"tip: Additional parameter\nAdditional parameter can be applied in the header. They will be added in the datamanager and can be used in the programm. If you add x,y,z to the parameter a multidimensional field will be created, e.g. MyVarx, MyVary will be created as field MyVar with 2 degrees of freedom","category":"page"},{"location":"man/mesh_input/#Data-Lines","page":"Mesh and Nodesets","title":"Data Lines","text":"","category":"section"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"The data lines represent individual nodes in the mesh, with values corresponding to the columns specified in the header.","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"Example Data Lines:","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"header: x y block_id volume\n0.0 0.0 1 1.0E-02\n0.1 0.0 1 1.0E-02\n0.1 0.1 1 1.0E-02\n...","category":"page"},{"location":"man/mesh_input/#Abaqus-Input","page":"Mesh and Nodesets","title":"Abaqus Input","text":"","category":"section"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"You can use the Abaqus input file to define the geometry of the simulation domain. In order to do that, refer in the input deck to your .inp file:","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"PeriLab:\n  Discretization:\n    Input Mesh File: ABAQUS_FILE.inp\n    Type: Abaqus\n...","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"All elements that are defined in a element set in the Abaqus input file will be translated to PeriLab nodes. The center and volume of the elements will be calculated automatically. Have a look at the AbaqusReader.jl package to see what elements are supported.","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"warning: Supported elements\nCurrently only Quad4, Tet4, Wedge6 and Hex8 elements are tested!","category":"page"},{"location":"man/mesh_input/#How-to-define-blocks-and-nodesets-with-Abaqus?","page":"Mesh and Nodesets","title":"How to define blocks and nodesets with Abaqus?","text":"","category":"section"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"The element sets are defined in the Abaqus input file and can be used to define blocks and nodesets. The order of the blocks will be similar to the order in the .inp file. Nodesets can be referenced via the correspoinding element set in the Abaqus input file.","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"tip: Block order\nIf you are not sure what order the blocks in the .inp file will be read in, you can use PeriLab to create an exodus file and check the order of the blocks in ParaView.","category":"page"},{"location":"man/mesh_input/#Nodeset-Input-File-Structure","page":"Mesh and Nodesets","title":"Nodeset Input File Structure","text":"","category":"section"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"The nodeset input file is a text file used to define sets of nodes in the simulation domain. The file has a header and subsequent lines representing individual node global IDs that belong to the nodeset. Below is an example of the structure:","category":"page"},{"location":"man/mesh_input/#Header-2","page":"Mesh and Nodesets","title":"Header","text":"","category":"section"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"The header of the nodeset input file specifies the format of the subsequent data columns. In this example, the header consists of the following column:","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"global_id: Global ID of the node.","category":"page"},{"location":"man/mesh_input/#Data-Lines-2","page":"Mesh and Nodesets","title":"Data Lines","text":"","category":"section"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"The data lines represent individual nodes in the nodeset, with values corresponding to the columns specified in the header.","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"Example Data Lines:","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"header: global_id\n1\n2\n11\n12","category":"page"},{"location":"man/mesh_input/","page":"Mesh and Nodesets","title":"Mesh and Nodesets","text":"","category":"page"},{"location":"man/models/thermal/#Thermal-Models","page":"Thermal Models","title":"Thermal Models","text":"","category":"section"},{"location":"man/models/thermal/","page":"Thermal Models","title":"Thermal Models","text":"The list shows the three main model, thermal expansion, thermal flow and heat transfer. All can use simular parameters to work.","category":"page"},{"location":"man/models/thermal/","page":"Thermal Models","title":"Thermal Models","text":"Thermal Model Thermal Expansion Thermal Flow Heat Transfer\nType âœ”ï¸ âœ”ï¸ âœ”ï¸\nHeat Transfer Coefficient âœ”ï¸ âœ”ï¸ âœ”ï¸\nEnvironmental Temperature âœ”ï¸ âœ”ï¸ âœ”ï¸\nReference Temperature âœ”ï¸  \nThermal Conductivity   âœ”ï¸\nThermal Expansion Coefficient âœ”ï¸  \nThermal Conductivity Print Bed   âœ”ï¸\nPrint Bed Temperature   âœ”ï¸","category":"page"},{"location":"man/models/thermal/","page":"Thermal Models","title":"Thermal Models","text":"There are block defined properties for needed for the thermal models.","category":"page"},{"location":"man/models/thermal/","page":"Thermal Models","title":"Thermal Models","text":"Parameter Unit Description\nSpecific Heat Capacity leftfracJkgKright Specific heat capacity of the block\nDensity leftfrackgm^3right Specific heat capacity of the block\nHorizon m Radius of the neighborhood","category":"page"},{"location":"man/models/thermal/#Thermal-Expansion","page":"Thermal Models","title":"Thermal Expansion","text":"","category":"section"},{"location":"man/models/thermal/","page":"Thermal Models","title":"Thermal Models","text":"Calculates the thermal expansion of the material.","category":"page"},{"location":"man/models/thermal/","page":"Thermal Models","title":"Thermal Models","text":"Parameter Unit Description\nThermal Expansion Coefficient left1Kright Thermal expansion can be a 3times3 matrix.\nReference Temperature K Reference temperature for the thermal expansion coefficient.","category":"page"},{"location":"man/models/thermal/","page":"Thermal Models","title":"Thermal Models","text":"info: Thermal expansion\nPeriLab supports currently only isotropic thermal expansion.","category":"page"},{"location":"man/models/thermal/#Thermal-Flow","page":"Thermal Models","title":"Thermal Flow","text":"","category":"section"},{"location":"man/models/thermal/","page":"Thermal Models","title":"Thermal Models","text":"Parameter Unit Description\nThermal Conductivity leftfracWmKright ","category":"page"},{"location":"man/models/thermal/#Heat-Transfer","page":"Thermal Models","title":"Heat Transfer","text":"","category":"section"},{"location":"man/models/thermal/","page":"Thermal Models","title":"Thermal Models","text":"Parameter Unit Description\nHeat Transfer Coefficient leftfracWm^2Kright Coefficient describing the heat transfer between a solid and a gas or liquid","category":"page"},{"location":"man/models/thermal/#Model-merging","page":"Thermal Models","title":"Model merging","text":"","category":"section"},{"location":"man/models/thermal/","page":"Thermal Models","title":"Thermal Models","text":"In PeriLab you are able to combine models with each other, by simply adding a +. Therefore, modules can be merged and double coding can be avoided. This is necessary if you want to model the heating of a model and its expansion.","category":"page"},{"location":"man/models/thermal/","page":"Thermal Models","title":"Thermal Models","text":"tip: Full Model\nIf you want to run a full thermal model Thermal Flow + Heat Transfer + Thermal Expansion.","category":"page"},{"location":"man/models/thermal/","page":"Thermal Models","title":"Thermal Models","text":"tip: Model order\nThe order is defined by the user. Therfore, in this example first the flow, than the transfer to the environment and than the expansion will be calculated.","category":"page"},{"location":"man/models/thermal/","page":"Thermal Models","title":"Thermal Models","text":"","category":"page"},{"location":"man/dev/testing/#Software-testing","page":"Software Testing","title":"Software testing","text":"","category":"section"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"The testing takes place manually or if commits are submitted to the repository. Make sure that all test are reasonably complex and won't take to much time. The testing coverage is checked as well.","category":"page"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"warning: Code quality\nTests only handle expected results and helps that code stays as intended after further development. It does not guarantee that not error occur.","category":"page"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"info: New tests\nIf new unexpected errors occur, please add an test to check possible exception to avoid them next time.","category":"page"},{"location":"man/dev/testing/#Runtests.jl","page":"Software Testing","title":"Runtests.jl","text":"","category":"section"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"The tests to perform are defined in the runtests.jl within the test folder. The structure is as follows.","category":"page"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"@testset ExtendedTestSet \"PeriLab\" begin\n\n    @testset \"unit_tests\" begin\n        @testset \"Compute\" begin\n            @testset \"ut_compute_global_values\" begin\n                include(filepath + filename)\n            end\n            @testset \"ut_compute_field_values\" begin\n                include(filepath + filename)\n            end\n        end\n    end\n\n    @testset \"full_scale\" begin\n        ...\n    end","category":"page"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"After testing you will get an overview over failed or errored tests. The test set structure helps to identify the position of errors.","category":"page"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"info: Error & Fails\nError means that the code of the test has an error. Typically the function call is flawed. Fail means that the test is wrong, e.g. 2==3","category":"page"},{"location":"man/dev/testing/#Unit-tests","page":"Software Testing","title":"Unit tests","text":"","category":"section"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"Unit tests are tests to check functions. To do that you add a file the the unit_tests folder. The folder has the same structure as the src folder. Please add your test in place of the src code file where your function is located. It helps to find the tests. Add your tests (please take examples from already existing tests).","category":"page"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"info: Exceptions\nIn this tests the exeptions should be tested, because full scale tests are not capable of.","category":"page"},{"location":"man/dev/testing/#Full-scale-test","page":"Software Testing","title":"Full scale test","text":"","category":"section"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"Full scale models should be used to test features within a complete analyses. A complete model is run and tested against the result file.","category":"page"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"How to set up? To create such test, you have to create a ''normal'' model and run it. Create a folder of your test and put all the information for the model inside. Create .jl file in the following structure","category":"page"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"    folder_name = basename(@__FILE__)[1:end-3]\n    cd(\"fullscale_tests/\" * folder_name) do\n        run_perilab(\"additive_2d\", 1, true, folder_name)\n        run_perilab(\"additive_2d_heat\", 1, true, folder_name)\n        run_perilab(\"additive_3d\", 1, true, folder_name)\n    end","category":"page"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"This file has to be called in the runtests.jl. You are able to define  .cmd with the following input if specific tolerances are needed.","category":"page"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"DEFAULT TOLERANCE absolute 1.0E-9\nCOORDINATES absolute 1.0E-12\nTIME STEPS absolute 1.0E-14\nNODAL VARIABLES absolute 1.0E-12\n    Temperature   absolute 1.0E-8\n    Heat Flow     absolute 1.0E-8\n    Active        absolute 1.0E-8","category":"page"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"warning: Naming convention\nNames of the .yaml input and the output must be the same.","category":"page"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"info: License\nUse licensing files for files which are not ascii.","category":"page"},{"location":"man/dev/testing/#Examples","page":"Software Testing","title":"Examples","text":"","category":"section"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"Examples should be given for more complex models used in papers. Here it should be refered to the commit hash (when it worked) and the paper where the model was used. These models won't run automatically. But they help to reproduce the results and make them more transparent.","category":"page"},{"location":"man/dev/testing/","page":"Software Testing","title":"Software Testing","text":"","category":"page"},{"location":"man/models/materials/#Material-Models","page":"Material Models","title":"Material Models","text":"","category":"section"},{"location":"man/models/materials/#Existing-Models","page":"Material Models","title":"Existing Models","text":"","category":"section"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"The models related functions can be found here.","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"Method Related Model in PeriLab\nBond-based Bond-based Elastic\nOrdinary state-based PD Solid Elastic, PD Solid Plastic\nNon-ordinary state-based Correspondence Elastic, Correspondence Plastic, Correspondence UMAT","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"Material Model Bond-based Elastic PD Solid Elastic PD Solid Plastic Correspondence Elastic Correspondence Plastic\nSymmetry âœ”ï¸ âœ”ï¸ âœ”ï¸ âœ”ï¸ âœ”ï¸\nPoisson's/Young's/Bulk/Shear âœ”ï¸ âœ”ï¸ âœ”ï¸ âœ”ï¸ âœ”ï¸\nYield Stress   âœ”ï¸  âœ”ï¸\nZero Energy Control    âœ”ï¸ âœ”ï¸\nC11/C12/.../C66 (âœ”ï¸) (âœ”ï¸) (âœ”ï¸) (âœ”ï¸) (âœ”ï¸)","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"Parameter Unit Description\nDensity leftfrackgm^3right Specific heat capacity of the block\nHorizon m Radius of the neighborhood","category":"page"},{"location":"man/models/materials/#Bond-based-Elastic","page":"Material Models","title":"Bond-based Elastic","text":"","category":"section"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"The Bond-based Elastic calculates the linear elastic behavior of a simple bond-based material. The theory of the bond-based elastic material can be found here.","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"Parameter Unit Description\nYoungs Modulus leftNm^2right Young's modulus or elasticity modulus\nShear Modulus leftNm^2right Shear modulus\nBulk Modulus leftNm^2right Bulk modulus or compression modulus","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"One of theses parameters have to be defined.","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"info: Fixed Poisson's ratio\nIn the bond-based formulation the Poisson's ratio is fixed by 0.25 for 2D plane strain and 1/3 for 3D and 2D plane stress, respectively.","category":"page"},{"location":"man/models/materials/#PD-Solid-Elastic","page":"Material Models","title":"PD Solid Elastic","text":"","category":"section"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"The PD Solid Elastic module calculates the isotropic linear elastic material law for a peridynamic solid material. The underlying theory can be found here.","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"Parameter Unit Description\nYoungs Modulus leftNm^2right Young's modulus or elasticity modulus\nShear Modulus leftNm^2right Shear modulus\nBulk Modulus leftNm^2right Bulk modulus or compression modulus\nPoissons Ratio Modulus left-right Poisson's ratio","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"Two of these parameters have to be defined. The other two are determined automatically and can be used in the model if needed.","category":"page"},{"location":"man/models/materials/#PD-Solid-Plastic","page":"Material Models","title":"PD Solid Plastic","text":"","category":"section"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"The PD Solid Plastic material uses elastic stresses and calculate the plastic part for a peridynamic solid material. Has to be combined with a function, which provides elastic stresses.","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"Parameter Unit Description\nYield Stress leftNm^2right Yield stress","category":"page"},{"location":"man/models/materials/#Correspondence-Elastic","page":"Material Models","title":"Correspondence Elastic","text":"","category":"section"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"The Correspondence Elastic module calculates the fully anisotropic linear elastic material law. The underlying correspondence theory can be found here.","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"Parameter Unit Description\nYoungs Modulus leftNm^2right Young's modulus or elasticity modulus\nShear Modulus leftNm^2right Shear modulus or elasticity modulus\nBulk Modulus leftNm^2right Bulk modulus or compression modulus\nPoissons Ratio Modulus left-right Poisson's ratio\nC11, C12, ..., C66 (optional) leftNm^2right Parameter of the Hook matrix","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"For Correspondence Elastic you can provide all 27 elastic parameters if you like by adding C11,...,C66.","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"tip: Isotropic elastic parameter\nFor the time step calculation two of the four isotropic elastic parameter have to be defined.","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"tip: Material Rotation\nIf you define a field \"Angles\" for 2D or \"Anglesx\", \"Anglesy\" and \"Anglesz\" for 3D in the mesh file your material will be rotated. This helps to create an arbitrary material orientation.","category":"page"},{"location":"man/models/materials/#Correspondence-Plastic","page":"Material Models","title":"Correspondence Plastic","text":"","category":"section"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"The Correspondence Plastic material uses elastic stresses and calculate the plastic part. Has to be combined with a function, which provides elastic stresses.","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"Parameter Unit Description\nYield Stress leftNm^2right Yield stress","category":"page"},{"location":"man/models/materials/#Correspondence-UMAT","page":"Material Models","title":"Correspondence UMAT","text":"","category":"section"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"The Correspondence UMAT can be used to include Abaqus user materials.","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"warning: Replace ABAQUS Functions\nNo extra Abaqus functions should be called in the user subroutine. For example INCLUDE 'ABA_PARAM.INC' needs to be replaced by implicit real(8) (a-h,o-z)","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"You can call the user subroutine by defining path with a compiled Fotran library. [5] gives an overview about the interface for Peridigm. In PeriLab all fields in the UMAT interface are supported execpt these integer (NOEL, NPT, LAYER, KSPT, JSTEP, KINC) and float values (PNEWDT, CELENT). In the material module these values defined for the interfase and named as notsupportedint and notsupportedfloat, respectively.","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"Parameter Type and Range Description Optional\nFile String Path and filename of the UMAT, e.g. \"./src/Models/Material/UMATs/libusertest.so\" No\nNumber of State Variables Int geq 0 Number of state variables; Defines the size of state variable field datamanager.createconstantnodefield(\"State Variables\", Float64, numstate_vars) yes\nNumber of Properties Int geq 1 Properties of the material; Needed for the propterty field datamanager.createconstantfreesizefield(\"Properties\", Float64, (num_props, 1)) \n No  \nProperty_iID Float iID is 1...Number of Properties. It has to be in order and can be utilized in the UMAT. No\nUMAT Material Name String (maximum are 80 characters) Defines material names defined in the UMAT to destinguash between different areas of the Fortran routine Yes\nUMAT name in development Should allow the definition of own subroutine name. The standard will be UMAT in development\nPredefined Field Names String separated by spaces geq0 Define all the fields in the mesh file which should be used as pre-defined values. An increment field is than defined as well. E.g. Predefined Field Names: \"Temperature\" \"Color\"; Temperature and Color must exist in the mesh file. They must be defined as Float or Int in that case. Yes","category":"page"},{"location":"man/models/materials/#Compilation-of-the-UMAT-subroutine","page":"Material Models","title":"Compilation of the UMAT subroutine","text":"","category":"section"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"In order to compile the UMAT subroutine you need to install gfortran. Have a look at this page. After installation you can compile the Fortran subroutine with the following command:","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"gfortran -shared -fPIC -o libusermat.so base.f","category":"page"},{"location":"man/models/materials/#Model-merging","page":"Material Models","title":"Model merging","text":"","category":"section"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"In PeriLab you are able to combine models with each other, by simply adding a +. Therefore, modules can be merged and double coding can be avoided.","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"tip: Elastic platic\nIf you want to run elastic platic please use Correspondence Elastic + Correspondence Plastic or PD Solid Elastic + PD Solid Plastic","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"warning: Model order\nThe order is defined by the user. Because the plastic routines need stresses to work, make sure the materials which provide these stresses are before the plastic models.","category":"page"},{"location":"man/models/materials/","page":"Material Models","title":"Material Models","text":"","category":"page"},{"location":"man/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"The PeriLab package is available through the Julia package system and can be installed using the following commands:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"PeriLab\")","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Throughout the rest of this tutorial, we will assume that you have installed the PeriLab package and have already typed using PeriLab to bring all of the relevant variables into your current namespace.","category":"page"},{"location":"man/getting_started/#Using-PeriLab","page":"Getting Started","title":"Using PeriLab","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"The simplest way to run the PeriLab simulation core is to use a provided example import the module and go. ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"using PeriLab\n\nPeriLab.get_examples()\nPeriLab.main(\"examples/DCB/DCBmodel.yaml\")","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"The output should look like this:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"<script src=\"https://asciinema.org/a/649032.js\" id=\"asciicast-649032\" async=\"true\"></script>","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"The main functionalities for the yaml input deck is given in","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"\"examples/functionalities.yaml\"","category":"page"},{"location":"man/getting_started/#Using-PeriLab-with-multiple-processors-(MPI)","page":"Getting Started","title":"Using PeriLab with multiple processors (MPI)","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to run PeriLab for large scale problems MPI needs to be installed:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"$ julia\njulia> using MPI\njulia> MPI.install_mpiexecjl()","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Run PeriLab with two processors:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"$ mpiexecjl -n 2 julia -e \"using PeriLab; PeriLab.main()\" Dogbone.yaml -v","category":"page"},{"location":"man/getting_started/#Training","page":"Getting Started","title":"Training","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"The training input is given under the examples folder. The documentation and a video will follow.","category":"page"},{"location":"man/getting_started/#Index","page":"Getting Started","title":"Index","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Pages = [\"gettin_started.md\"]","category":"page"},{"location":"man/getting_started/#Functions","page":"Getting Started","title":"Functions","text":"","category":"section"},{"location":"man/getting_started/#PeriLab.main","page":"Getting Started","title":"PeriLab.main","text":"main()\n\nEntry point for the PeriLab application.\n\nThis function serves as the entry point for the PeriLab application. It calls the core main function with the provided arguments.\n\n\n\n\n\nmain(filename::String, output_dir::String=\"\", dry_run::Bool=false, verbose::Bool=false, debug::Bool=false, silent::Bool=false, reload::Bool=false)\n\nEntry point for the PeriLab application.\n\nThis function serves as the entry point for the PeriLab application. It calls the core main function with the provided arguments.\n\nArguments\n\nfilename::String: The filename of the input file.\noutput_dir::String: The output directory.\ndry_run::Bool=false: Whether to run in dry-run mode.\nverbose::Bool=false: Whether to run in verbose mode.\ndebug::Bool=false: Whether to run in debug mode.\nsilent::Bool=false: Whether to run in silent mode.\nreload::Bool=false: Whether to reload the input file.\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#PeriLab.get_examples","page":"Getting Started","title":"PeriLab.get_examples","text":"get_examples()\n\nCopy the examples folder to the current directory.\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"devLog/","page":"-","title":"-","text":"<!â€“ SPDX-FileCopyrightText: 2023 Christian Willberg <christian.willberg@dlr.de>, Jan-Timo Hesse <jan-timo.hesse@dlr.de>","category":"page"},{"location":"devLog/","page":"-","title":"-","text":"SPDX-License-Identifier: BSD-3-Clause â€“>","category":"page"},{"location":"devLog/#Dev-Steps","page":"-","title":"Dev Steps","text":"","category":"section"},{"location":"devLog/","page":"-","title":"-","text":"Introduction of bond associated correspondence ","category":"page"},{"location":"devLog/","page":"-","title":"-","text":"Developement plan","category":"page"},{"location":"devLog/","page":"-","title":"-","text":"Bond associated neighborhood is the overlap between nlist[iID] and nlist[nlist[iID][jID]]\nFilter equal nodes and create a new neighborhoodlist for bond -> bond_nlist\ncalculate K, Kinv and defGrad -> already there if the neighborhood loop is in a function\nweighted volume (sum(volume(bond_nlist))/sum(volume[nlist[iID]]))","category":"page"},{"location":"devLog/","page":"-","title":"-","text":"If this works for one core the following will be introduced","category":"page"},{"location":"devLog/","page":"-","title":"-","text":"all neighbors search for neighbors at each core\nnumbers are correct and it allows a change in size -> local ID is correct","category":"page"},{"location":"devLog/#Design-decisions","page":"-","title":"Design decisions","text":"","category":"section"},{"location":"devLog/","page":"-","title":"-","text":"Each vector entry for a value exists for all nodes, also if the node does not have this property in a block. However, the synchronisation is very ugly, because all responder nodes of block with value I need the entry at the other core to. If not it will lead nowhere if MPI communication occurs","category":"page"},{"location":"devLog/","page":"-","title":"-","text":"IO\nnodesets are not defined yet in Exodus.jl\n\nsnake_case for variables and functions\nPascalCase for modules and type names\nFULL_UPPERCASE for constants","category":"page"},{"location":"devLog/#Issues","page":"-","title":"Issues","text":"","category":"section"},{"location":"devLog/","page":"-","title":"-","text":"for n=4 -> errors    \nMPI_Neighbor_alltoall -> might be easier","category":"page"},{"location":"devLog/#planned-feature","page":"-","title":"planned feature","text":"","category":"section"},{"location":"devLog/","page":"-","title":"-","text":"test if blocks are defined in yaml, but missing in mesh\nhttps://github.com/StephenVavasis/Unroll.jl\nstatic arrays package -> speed up -> only for arrays smaller 100; inverte of Jacobian, etc.\nintegration of FEM Julia package -> coupling might be better, becaus of more functionality\ntime step minimum for all cores -> parallel computing! -> done\nmatrix -> reshape from vector for better use\nsearch for jl files in material\ncheck the header for the material name\ninclude the file in the code via a makro\nmaterial inclusion is very simple\nbonds as elements in exodus -> filter small to large writing ?! -> elements can be x,y to be represented both\nmultiple materials in one block -> evaluation order","category":"page"},{"location":"devLog/","page":"-","title":"-","text":"","category":"page"},{"location":"lecture/seminar_8/#Seminar-8:-Additive-manufacturing","page":"Seminar 8","title":"Seminar 8: Additive manufacturing","text":"","category":"section"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"underlineomegalangleboldsymbolxirangle in mathcalH_textbfx =    leftbeginarrayl\n0 qquadtextfor tt_activate\n1  qquadtextfor t geq t_activate\nendarrayright","category":"page"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"(Image: Virtual printing process)","category":"page"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"figure (taken from [9]).","category":"page"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"    Additive Models:\n      Test:\n        Additive Model: \"Simple\"\n        Print Temperature: 100","category":"page"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"Additve Result","category":"page"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"boldsymbolvarepsilon=boldsymbolvarepsilon_mechanical + boldsymbolvarepsilon_thermal","category":"page"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"boldsymbolvarepsilon_thermal =- boldsymbolalphatau","category":"page"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"boldsymbolsigma=mathbfCcdotcdotleft(boldsymbolvarepsilon_mechanical - boldsymbolalphatau right)","category":"page"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"For bond 1 the stresses are zero, if varepsilon_mechanical = boldsymbolalphatau","category":"page"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"during a printing process this holds true for each step t. Assumed that tau_it_printtau_it_print + Delta t, leads to following effect. t_jprint = t_iprint + Delta t varepsilon_imechanical = boldsymbolalphatau_it_print + Delta t varepsilon_jmechanical = boldsymbolalphatau_jt_print","category":"page"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"varepsilon_imechanicalneqvarepsilon_jmechanical","category":"page"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"This leads to internal stresses or forces.","category":"page"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"\nusing LinearAlgebra\n\n\nfunction K_stiff(np, c, omega, V)\n    K=zeros(np,np)\n    for iID in 1:np\n        for jID in -nn:nn\n            if jID != 0 && iID + jID > 0 && iID + jID < np + 1\n                xi = L*abs(jID)\n                K[iID, iID + jID] -= 0.5 * c[iID] / xi * V * omega[iID, iID + jID]\n                K[iID, iID]      +=  0.5 *c[iID] / xi * V * omega[iID, iID + jID]\n            end\n        end\n    end\n    K[np, :] .= 0\n    K[:, np] .= 0\n    K[np, np] = 1\n    return K\nend\n\nE = 1\nV = 1\nL = 1\nnp = 8\nnn = 2\ndelta = 1\nu = collect(1:np)\n\nomega=ones(np, np)\n\n\n##\nc=zeros(np)\nc .= 2*E/delta^2\n\nK_f = K_stiff(np, c, omega, V)\nK_f[1,:] .= 0; K_f[:,1] .= 0; K_f[1,1] = 1\nF=K_f*u\n\nc[6]=2.0 .*c[6]\n\nK_s = K_stiff(np, c, omega, V)\n\nK_s[1,:] .= 0; K_s[:,1] .= 0; K_s[1,1] = 1\n\nu_error=inv(K_s)*F\ndisplay(u-u_error)\n\ninteral_force = K_s*(u-u_error)\ndispaly(internal_force)","category":"page"},{"location":"lecture/seminar_8/","page":"Seminar 8","title":"Seminar 8","text":"","category":"page"},{"location":"lib/links/#Useful-Tools-and-Links","page":"Useful Links","title":"Useful Tools and Links","text":"","category":"section"},{"location":"lib/links/","page":"Useful Links","title":"Useful Links","text":"Below you can find a summary of some useful tools and links, that can help you get started with PeriLab and Peridynamics.","category":"page"},{"location":"lib/links/","page":"Useful Links","title":"Useful Links","text":"Link Description\nPeriLab The source code for PeriLab\nDocker Image Ready to use Docker Image\nPeriLab-Results Web-service for PeriLab Results\nPeriHub Web-Framework and API for PeriLab\nParaView Open source visualization software\nYouTube Our YouTube channel\nJuliaHub Platform for scientific computing","category":"page"},{"location":"lib/links/","page":"Useful Links","title":"Useful Links","text":"If you want to contribute to the development of PeriLab, here are some recommended tools to get started:","category":"page"},{"location":"lib/links/","page":"Useful Links","title":"Useful Links","text":"Link Description\nVisual Studio Code Open source code editing\nJulia Open source programming language for scientific computing\nJulia Extension VS Code extension for Julia programming","category":"page"},{"location":"lib/links/","page":"Useful Links","title":"Useful Links","text":"","category":"page"},{"location":"theory/theory_surface_correction/#Surface-correction","page":"Surface Correction","title":"Surface correction","text":"","category":"section"},{"location":"theory/theory_surface_correction/","page":"Surface Correction","title":"Surface Correction","text":"There are several ways to deal with the surface correction in Peridynamics. The issue is caused, because parts of the intergral domain mathcalH near a surface lies outside of the material or is mixed between materials (shown in the figure). This leads to errors in the computation of the force densities. For smaller horizons, obviously this effect can be reduced. However, there are several methods to mitigate the issue described in this study [30].","category":"page"},{"location":"theory/theory_surface_correction/","page":"Surface Correction","title":"Surface Correction","text":"(Image: )","category":"page"},{"location":"theory/theory_surface_correction/#Volume-correction","page":"Surface Correction","title":"Volume correction","text":"","category":"section"},{"location":"theory/theory_surface_correction/","page":"Surface Correction","title":"Surface Correction","text":"Following the study of Le and Bobaru","category":"page"},{"location":"theory/theory_surface_correction/","page":"Surface Correction","title":"Surface Correction","text":"info: Quote [LeQV2018](@cite)\nthe simplest correction methods to implement, the volume correction method, also appear to be one of the most effective. Correction methods reduce the PD surface effect faster (more efficiently) than simply using a smaller horizon (problem shown in the figure).","category":"page"},{"location":"theory/theory_surface_correction/","page":"Surface Correction","title":"Surface Correction","text":"a volume corrections factor lambda_corr is introduced deviding the domain volume V_0 by the avarage of the domain volumes of point  mathbfx and mathbfx.","category":"page"},{"location":"theory/theory_surface_correction/","page":"Surface Correction","title":"Surface Correction","text":"lambda_corr=frac2V_0V(mathbfx)+V(mathbfx)","category":"page"},{"location":"theory/theory_surface_correction/","page":"Surface Correction","title":"Surface Correction","text":"(Image: ) The reference volumen V_0 is depended on the dimension (3D or 2D)","category":"page"},{"location":"theory/theory_surface_correction/","page":"Surface Correction","title":"Surface Correction","text":"V_0-3D=frac4pidelta^33","category":"page"},{"location":"theory/theory_surface_correction/","page":"Surface Correction","title":"Surface Correction","text":"V_0-2D=fracpidelta^2h4","category":"page"},{"location":"theory/theory_surface_correction/","page":"Surface Correction","title":"Surface Correction","text":"this factor is than multiplied to the bond force mathbft_corr =lambda_corrmathbft","category":"page"},{"location":"theory/theory_surface_correction/","page":"Surface Correction","title":"Surface Correction","text":"warn: Only mechanical\nSurface correction is right now only applied for mechanical properties.","category":"page"},{"location":"theory/theory_surface_correction/","page":"Surface Correction","title":"Surface Correction","text":"You can apply the surface correction initialy for all outer surfaces and continuous, for cracks or additive manufacturing.","category":"page"},{"location":"theory/theory_surface_correction/","page":"Surface Correction","title":"Surface Correction","text":"","category":"page"},{"location":"lecture/seminar_9/#Seminar-9:-PeriLab-Implement-your-own-model","page":"Seminar 9","title":"Seminar 9: PeriLab - Implement your own model","text":"","category":"section"},{"location":"lecture/seminar_9/","page":"Seminar 9","title":"Seminar 9","text":"","category":"page"},{"location":"theory/theory_bondbased/#Bond-based-Peridynamics","page":"Bond-based","title":"Bond-based Peridynamics","text":"","category":"section"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"Bond-based Peridynamics is a nonlocal extension of classical continuum mechanics, designed to address discontinuities like cracks within materials. Unlike traditional methods, which use partial differential equations (PDEs) and are based on local interactions, Peridynamics operates on integral equations and accounts for long-range forces.","category":"page"},{"location":"theory/theory_bondbased/#Fundamental-Concepts","page":"Bond-based","title":"Fundamental Concepts","text":"","category":"section"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"In bond-based Peridynamics, the material is considered as a continuum of particles that interact with each other through bonds. These interactions are not limited to immediate neighbors, allowing the framework to naturally handle the initiation and propagation of cracks.","category":"page"},{"location":"theory/theory_bondbased/#Equation-of-Motion","page":"Bond-based","title":"Equation of Motion","text":"","category":"section"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"The equation of motion in Peridynamics is an integral equation, differing from the local PDEs in classical mechanics. For a particle at position mathbfx, the equation is:","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"rho(mathbfx) ddotmathbfu(mathbfx t) = int_mathcalH mathbff(mathbfx mathbfx t)  dV + mathbfb(mathbfx t)","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"where: rho(mathbfx) is the mass density at mathbfx. ddotmathbfu(mathbfx t) is the acceleration at point mathbfx. mathcalH represents the horizon around mathbfx, within which interactions occur. mathbfb(mathbfx t) is the body force term.","category":"page"},{"location":"theory/theory_bondbased/#Interaction","page":"Bond-based","title":"Interaction","text":"","category":"section"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"The fundamental interaction in bond-based Peridynamics is between pairs of points or particles within a certain horizon distance. The force vector between two points, x and x, is given by:","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"mathbff(mathbfx mathbfx) = underlineomegalangle boldsymbolxi rangle c  (mathbfu(mathbfx) - mathbfu(mathbfx))","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"where: mathbff(mathbfx mathbfx) is the force vector exerted by the particle at mathbfx on the particle at mathbfx. c is a bond modulus representing the stiffness of the bond. underlineomegalangle boldsymbolxi rangle is a bond-associated influence function. mathbfu(mathbfx) is the displacement of the particle at mathbfx.","category":"page"},{"location":"theory/theory_bondbased/#Bond-Moduli","page":"Bond-based","title":"Bond Moduli","text":"","category":"section"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"From [11] we get","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"Dimension Bond Stiffness Poisson's ratio\nplane strain: c = frac48 Epi 5 delta^3 fixed nu=025\nplane stress: c = frac9 Epi delta^3 fixed nu=13\n3D: c = frac12 Epi  delta^4 fixed nu=025","category":"page"},{"location":"theory/theory_bondbased/#Unified-Bond-based-Peridynamics","page":"Bond-based","title":"Unified Bond-based Peridynamics","text":"","category":"section"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"This model was developed by Guan et al. [12] and utilizes the strain identification technique (SIT) [13]. It extends the original bond-based theory and extends it. Poisson's ratios which differs from the proposed ones are allowed. For 3D they defined","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"mathbff=cleftfrac3  (4nu-1) 2 (1 + nu)varepsilon_m- frac5  (1 - 2nu) 2 (1 + nu) s  rightfracboldsymbolxiboldsymbolxi","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"varepsilon_m=fracvarepsilon3","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"where varepsilon is the bond strain, s is the bond stretch and c is the bond stiffness from the bond based formulation.","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"For 2D plane stress and plane stress the equations are more complex","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"mathbff_2D=c_2leftR_as_ij+R_bvarepsilon_mrightfracxi_ijxi_ij","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"Several parameter have to be computed","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"c_2=leftbeginaligned frac6pi  delta  (1 - 2  nu)(1 + nu)   textplane strain\nfrac6Epidelta^3(1-nu)  textplane stress\nendalignedright","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"R_a=leftbeginaligned 2(1 + nu) beta I_1   textplane strain\n frac2  (1 - nu)(1 - 2nu) beta  I_1  textplane stress\nendalignedright","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"R_b=leftbeginaligned 2 (1 + nu)  (1 - beta) I_2   textplane strain\n frac6nu (1 - nu)(1 - 2 nu)^2beta I_1 +\n         2  frac1 - nu1 - 2 nuleft(1 - frac1 + nu1 - 2 nu betaright) I_2  textplane stress\nendalignedright","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"with beginalignedbeta = frac5(1-2nu)2(1+nu) I_1 = n  sqrt1 - n^2textand I_2 = n  a  sinh(sqrt1  n^2 - 1)endaligned where n, xi_ik and s_ij are given as","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"n = fracxidelta","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"xi_ik=(x_iky_ikz_ik)qquad textand","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"s_ij=varepsilon_xfracx_ij^2xi_ik^2 + varepsilon_zfracz_ij^2xi_ik^2","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"The meaning of a is not specified by Guan et al. [12] and set to one. As can be seen in the equations E and nu can be specified independently.","category":"page"},{"location":"theory/theory_bondbased/","page":"Bond-based","title":"Bond-based","text":"","category":"page"},{"location":"lib/mpi_functions/#MPI-Functions","page":"MPI","title":"MPI - Functions","text":"","category":"section"},{"location":"lib/mpi_functions/#Index","page":"MPI","title":"Index","text":"","category":"section"},{"location":"lib/mpi_functions/","page":"MPI","title":"MPI","text":"Pages = [\"mpi_functions.md\"]","category":"page"},{"location":"lib/mpi_functions/#MPI","page":"MPI","title":"MPI","text":"","category":"section"},{"location":"lib/mpi_functions/#PeriLab.IO.MPI_communication.send_single_value_from_vector","page":"MPI","title":"PeriLab.IO.MPI_communication.send_single_value_from_vector","text":"send_single_value_from_vector(comm::MPI.Comm, controller::Int64, values::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}, type::Type)\n\nSends a single value from a vector to a controller\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\ncontroller::Int64: The controller\nvalues::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The values\ntype::Type: The type\n\nReturns\n\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.IO.MPI_communication.synch_responder_to_controller","page":"MPI","title":"PeriLab.IO.MPI_communication.synch_responder_to_controller","text":"synch_responder_to_controller(comm::MPI.Comm, overlapnodes, vector, dof)\n\nSynch the responder to the controller\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\noverlapnodes::Dict: The overlap nodes\nvector::Vector: The vector\ndof::Int: The degree of freedom\n\nReturns\n\nvector::Vector: The vector\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.IO.MPI_communication.synch_controller_to_responder","page":"MPI","title":"PeriLab.IO.MPI_communication.synch_controller_to_responder","text":"synch_controller_to_responder(comm::MPI.Comm, overlapnodes, vector, dof)\n\nSynch the controller to the responder\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\noverlapnodes::Dict: The overlap nodes\nvector::Vector: The vector\ndof::Int: The degree of freedom\n\nReturns\n\nvector::Vector: The vector\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.IO.MPI_communication.synch_controller_bonds_to_responder","page":"MPI","title":"PeriLab.IO.MPI_communication.synch_controller_bonds_to_responder","text":"synch_controller_bonds_to_responder(comm::MPI.Comm, overlapnodes, array, dof)\n\nSynch the controller bonds to the responder\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\noverlapnodes::Dict: The overlap nodes\narray::Array: The array\ndof::Int: The degree of freedom\n\nReturns\n\narray::Array: The array\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.IO.MPI_communication.split_vector","page":"MPI","title":"PeriLab.IO.MPI_communication.split_vector","text":"split_vector(input, row_nums, dof)\n\nSplit a vector into a vector of matrices\n\nArguments\n\ninput::Vector: The input vector\nrow_nums::Vector: The row numbers\ndof::Int: The degree of freedom\n\nReturns\n\nresult::Vector: The result vector\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.IO.MPI_communication.synch_controller_bonds_to_responder_flattened","page":"MPI","title":"PeriLab.IO.MPI_communication.synch_controller_bonds_to_responder_flattened","text":"synch_controller_bonds_to_responder_flattened(comm::MPI.Comm, overlapnodes, array, dof)\n\nSynch the controller bonds to the responder\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\noverlapnodes::Dict: The overlap nodes\narray::Array: The array\ndof::Int: The degree of freedom\n\nReturns\n\narray::Array: The array\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.IO.MPI_communication.send_vector_from_root_to_core_i","page":"MPI","title":"PeriLab.IO.MPI_communication.send_vector_from_root_to_core_i","text":"send_vector_from_root_to_core_i(comm::MPI.Comm, send_msg, recv_msg, distribution)\n\nSends a vector from the root to the core i\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\nsend_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The send message\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The receive message\ndistribution::Vector{Int64}: The distribution\n\nReturns\n\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.IO.MPI_communication.send_value","page":"MPI","title":"PeriLab.IO.MPI_communication.send_value","text":"send_value(comm::MPI.Comm, controller, send_msg)\n\nSends a value to a controller\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\ncontroller::Int64: The controller\nsend_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The send message\n\nReturns\n\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.IO.MPI_communication.find_and_set_core_value_min","page":"MPI","title":"PeriLab.IO.MPI_communication.find_and_set_core_value_min","text":"find_and_set_core_value_min(comm::MPI.Comm, value::Union{Float64,Int64})\n\nFind and set core value min\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\nvalue::Union{Float64,Int64}: The value\n\nReturns\n\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.IO.MPI_communication.find_and_set_core_value_max","page":"MPI","title":"PeriLab.IO.MPI_communication.find_and_set_core_value_max","text":"find_and_set_core_value_max(comm::MPI.Comm, value::Union{Float64,Int64})\n\nFind and set core value max\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\nvalue::Union{Float64,Int64}: The value\n\nReturns\n\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.IO.MPI_communication.find_and_set_core_value_sum","page":"MPI","title":"PeriLab.IO.MPI_communication.find_and_set_core_value_sum","text":"find_and_set_core_value_sum(comm::MPI.Comm, value::Union{Float64,Int64})\n\nFind and set core value sum\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\nvalue::Union{Float64,Int64}: The value\n\nReturns\n\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.IO.MPI_communication.find_and_set_core_value_avg","page":"MPI","title":"PeriLab.IO.MPI_communication.find_and_set_core_value_avg","text":"find_and_set_core_value_avg(comm::MPI.Comm, value::Union{Float64,Int64})\n\nFind and set core value avg\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\nvalue::Union{Float64,Int64}: The value\n\nReturns\n\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.IO.MPI_communication.gather_values","page":"MPI","title":"PeriLab.IO.MPI_communication.gather_values","text":"gather_values(comm::MPI.Comm, value::Any)\n\nGather values\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\nvalue::Any: The value\n\nReturns\n\nrecv_msg::Any: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/","page":"MPI","title":"MPI","text":"","category":"page"},{"location":"lib/solver_functions/#Solver-Functions","page":"Solver","title":"Solver - Functions","text":"","category":"section"},{"location":"lib/solver_functions/#Index","page":"Solver","title":"Index","text":"","category":"section"},{"location":"lib/solver_functions/","page":"Solver","title":"Solver","text":"Pages = [\"solver_functions.md\"]","category":"page"},{"location":"lib/solver_functions/#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"lib/solver_functions/#PeriLab.Solver_control.init","page":"Solver","title":"PeriLab.Solver_control.init","text":"init(params::Dict, datamanager::Module)\n\nInitialize the solver\n\nArguments\n\nparams::Dict: The parameters\ndatamanager::Module: Datamanager\nto::TimerOutputs.TimerOutput: A timer output\n\nReturns\n\nblock_nodes::Dict{Int64,Vector{Int64}}: A dictionary mapping block IDs to collections of nodes.\nbcs::Dict{Any,Any}: A dictionary containing boundary conditions.\ndatamanager::Module: The data manager module that provides access to data fields and properties.\nsolver_options::Dict{String,Any}: A dictionary containing solver options.\n\n\n\n\n\n","category":"function"},{"location":"lib/solver_functions/#PeriLab.Solver_control.remove_models-Tuple{Module, Vector{String}}","page":"Solver","title":"PeriLab.Solver_control.remove_models","text":"remove_models(datamanager::Module, solver_options::Vector{String})\n\nSets the active models to false if they are deactivated in the solver. They can be active, because they are defined as model and in the blocks.\n\nArguments\n\ndatamanager::Module: The MPI communicator\nsolver_options::Vector{String}: A dictionary of fields\n\nReturns\n\ndatamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.set_angles-Tuple{Module, Dict, Dict}","page":"Solver","title":"PeriLab.Solver_control.set_angles","text":"set_angles(datamanager::Module, params::Dict, block_nodes::Dict)\n\nSets the density of the nodes in the dictionary.\n\nArguments\n\ndatamanager::Module: The data manager\nparams::Dict: The parameters\nblock_nodes::Dict: A dictionary mapping block IDs to collections of nodes\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.set_density-Tuple{Dict, Dict, Vector{Float64}}","page":"Solver","title":"PeriLab.Solver_control.set_density","text":"set_density(params::Dict, block_nodes::Dict, density::Vector{Float64})\n\nSets the density of the nodes in the dictionary.\n\nArguments\n\nparams::Dict: The parameters\nblock_nodes::Dict: A dictionary mapping block IDs to collections of nodes\ndensity::Vector{Float64}: The density\n\nReturns\n\ndensity::Vector{Float64}: The density\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.set_fem_block-Tuple{Dict, Dict, Vector{Bool}}","page":"Solver","title":"PeriLab.Solver_control.set_fem_block","text":"set_fem_block(params::Dict, block_nodes::Dict, fem_block::Vector{Bool})\n\nSets the fem_block of the nodes in the dictionary.\n\nArguments\n\nparams::Dict: The parameters\nblock_nodes::Dict: A dictionary mapping block IDs to collections of nodes\nfem_block::Vector{Bool}: The fem_block\n\nReturns\n\nfem_block::Vector{Bool}: The fem_block\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.set_horizon-Tuple{Dict, Dict, Vector{Float64}}","page":"Solver","title":"PeriLab.Solver_control.set_horizon","text":"set_horizon(params::Dict, block_nodes::Dict, horizon::Vector{Float64})\n\nSets the horizon of the nodes in the dictionary.\n\nArguments\n\nparams::Dict: The parameters\nblock_nodes::Dict: A dictionary mapping block IDs to collections of nodes\nhorizon::Vector{Float64}: The horizon\n\nReturns\n\nhorizon::Vector{Float64}: The horizon\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.solver-Tuple{Dict{Any, Any}, Dict{Int64, Vector{Int64}}, Dict{Any, Any}, Module, Dict{Int64, Dict}, Vector{Dict}, Any, Any, Bool}","page":"Solver","title":"PeriLab.Solver_control.solver","text":"solver(solver_options::Dict{String,Any}, block_nodes::Dict{Int64,Vector{Int64}}, bcs::Dict{Any,Any}, datamanager::Module, outputs::Dict{Int64,Dict{}}, result_files::Vector{Any}, write_results, to, silent::Bool)\n\nRuns the solver.\n\nArguments\n\nsolver_options::Dict{String,Any}: The solver options\nblock_nodes::Dict{Int64,Vector{Int64}}: A dictionary mapping block IDs to collections of nodes\nbcs::Dict{Any,Any}: The boundary conditions\ndatamanager::Module: The data manager module\noutputs::Dict{Int64,Dict{}}: A dictionary for output settings\nresult_files::Vector{Any}: A vector of result files\nwrite_results: A function to write simulation results\nto::TimerOutputs.TimerOutput: A timer output\nsilent::Bool: A boolean flag to suppress progress bars\n\nReturns\n\nresult_files: A vector of updated result files\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.synchronise_field-Tuple{Any, Dict, Any, Any, String, String}","page":"Solver","title":"PeriLab.Solver_control.synchronise_field","text":"synchronise_field(comm, synch_fields::Dict, overlap_map, get_field, synch_field::String, direction::String)\n\nSynchronises field.\n\nArguments\n\ncomm: The MPI communicator\nsynch_fields::Dict: A dictionary of fields\noverlap_map: The overlap map\nget_field: The function to get the field\nsynch_field::String: The field\ndirection::String: The direction\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#Verlet","page":"Solver","title":"Verlet","text":"","category":"section"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Verlet.calculate_strain-Tuple{Module, AbstractVector{Int64}, Union{Matrix{Float64}, StaticArraysCore.SMatrix, StaticArraysCore.MMatrix}}","page":"Solver","title":"PeriLab.Solver_control.Verlet.calculate_strain","text":"calculate_strain(datamanager::Module, nodes::AbstractVector{Int64}, hooke_matrix::Matrix{Float64})\n\nCalculate the von Mises stress.\n\nArguments\n\ndatamanager::Data_manager: Datamanager.\nnodes::AbstractVector{Int64}: The nodes.\nhooke_matrix::Matrix{Float64}: The hooke matrix.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Verlet.calculate_stresses-Tuple{Module, Dict{Int64, Vector{Int64}}, Dict{String, Any}}","page":"Solver","title":"PeriLab.Solver_control.Verlet.calculate_stresses","text":"calculate_stresses(datamanager::Module, block_nodes::Dict{Int64,Vector{Int64}}, options::Dict{String, Any})\n\nComputes the stresses.\n\nArguments\n\ndatamanager::Data_manager: Datamanager.\nblock_nodes::Dict{Int64,Vector{Int64}}: List of block nodes.\noptions::Dict{String, Any}: List of options.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Verlet.calculate_von_mises_stress-Tuple{Module, AbstractVector{Int64}}","page":"Solver","title":"PeriLab.Solver_control.Verlet.calculate_von_mises_stress","text":"calculate_von_mises_stress(datamanager::Module, nodes::AbstractVector{Int64})\n\nCalculate the von Mises stress.\n\nArguments\n\ndatamanager::Data_manager: Datamanager.\nnodes::AbstractVector{Int64}: The nodes.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Verlet.compute_crititical_time_step-Tuple{Module, Dict{Int64, Vector{Int64}}, Bool, Bool}","page":"Solver","title":"PeriLab.Solver_control.Verlet.compute_crititical_time_step","text":"compute_crititical_time_step(datamanager::Module, block_nodes::Dict{Int64,Vector{Int64}}, mechanical::Bool, thermo::Bool)\n\nCalculate the critical time step for a simulation considering both mechanical and thermodynamic aspects.\n\nThis function computes the critical time step by considering mechanical and thermodynamic properties of different blocks. The resulting critical time step is based on the smallest critical time step found among the blocks.\n\nArguments\n\ndatamanager::Module: The data manager module that provides access to required data fields and properties.\nblock_nodes::Dict{Int64, Vector{Int64}}: A dictionary mapping block IDs to collections of nodes.\nmechanical::Bool: If true, mechanical properties are considered in the calculation.\nthermo::Bool: If true, thermodynamic properties are considered in the calculation.\n\nReturns\n\nFloat64: The calculated critical time step based on the smallest critical time step found among the blocks.\n\nDependencies\n\nThis function may depend on the following functions:\n\ncompute_thermodynamic_critical_time_step: Used if thermo is true to calculate thermodynamic critical time steps.\ncompute_mechanical_critical_time_step: Used if mechanical is true to calculate mechanical critical time steps.\nThe availability of specific properties from the data manager module.\n\nErrors\n\nIf required properties are not available in the data manager, it may raise an error message.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Verlet.compute_mechanical_critical_time_step-Tuple{AbstractVector{Int64}, Module, Union{Float64, Int64, SubArray, Vector{Float64}}}","page":"Solver","title":"PeriLab.Solver_control.Verlet.compute_mechanical_critical_time_step","text":"compute_mechanical_critical_time_step(nodes::AbstractVector{Int64}, datamanager::Module, bulk_modulus::Float64)\n\nCalculate the critical time step for a mechanical simulation using a bond-based approximation [37].\n\nThis function iterates over a collection of nodes and computes the critical time step for each node based on the given input data and parameters.\n\nArguments\n\nnodes::Union{SubArray, Vector{Int64}}: The collection of nodes to calculate the critical time step for.\ndatamanager::Module: The data manager module that provides access to required data fields.\nbulk_modulus::Float64: The bulk modulus used in the calculations.\n\nReturns\n\nFloat64: The calculated critical time step for the mechanical simulation.\n\nDependencies\n\nThis function depends on the following data fields from the datamanager module:\n\nget_nlist(): Returns the neighbor list.\nget_field(\"Density\"): Returns the density field.\nget_field(\"Bond Length\"): Returns the bond distance field.\nget_field(\"Volume\"): Returns the volume field.\nget_field(\"Horizon\"): Returns the horizon field.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Verlet.compute_thermodynamic_critical_time_step-Tuple{AbstractVector{Int64}, Module, Union{Float64, Int64}}","page":"Solver","title":"PeriLab.Solver_control.Verlet.compute_thermodynamic_critical_time_step","text":"compute_thermodynamic_critical_time_step(nodes::AbstractVector{Int64}, datamanager::Module, lambda::Float64, Cv::Float64)\n\nCalculate the critical time step for a thermodynamic simulation based on  [24].\n\nThis function iterates over a collection of nodes and computes the critical time step for each node using provided input data and parameters.\n\nArguments\n\nnodes::Union{SubArray, Vector{Int64}}: The collection of nodes to calculate the critical time step for.\ndatamanager::Module: The data manager module that provides access to required data fields.\nlambda::Float64: The material parameter used in the calculations.\nCv::Float64: The heat capacity at constant volume used in the calculations.\n\nReturns\n\nFloat64: The calculated critical time step for the thermodynamic simulation.\n\nDependencies\n\nThis function depends on the following data fields from the datamanager module:\n\nget_nlist(): Returns the neighbor list.\nget_field(\"Density\"): Returns the density field.\nget_field(\"Bond Length\"): Returns the bond distance field.\nget_field(\"Volume\"): Returns the volume field.\nget_field(\"Number of Neighbors\"): Returns the number of neighbors field.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Verlet.get_cs_denominator-Tuple{AbstractVector{Float64}, AbstractVector{Float64}}","page":"Solver","title":"PeriLab.Solver_control.Verlet.get_cs_denominator","text":"get_cs_denominator(volume::AbstractVector{Float64}, undeformed_bond::AbstractVector{Float64})\n\nCalculate the denominator for the critical time step calculation.\n\nArguments\n\nvolume::AbstractVector{Float64}: The volume field.\nundeformed_bond::Union{SubArray,Vector{Float64},Vector{Int64}}: The undeformed bond field.\n\nReturns\n\nFloat64: The denominator for the critical time step calculation.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Verlet.get_forces_from_force_density-Tuple{Module}","page":"Solver","title":"PeriLab.Solver_control.Verlet.get_forces_from_force_density","text":"get_forces_from_force_density(datamanager::Module)\n\nComputes the forces from the force densities.\n\nArguments\n\ndatamanager::Data_manager: Datamanager.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Verlet.get_integration_steps-Tuple{Float64, Float64, Float64}","page":"Solver","title":"PeriLab.Solver_control.Verlet.get_integration_steps","text":"get_integration_steps(initial_time::Float64, end_time::Float64, dt::Float64)\n\nCalculate the number of integration steps and the adjusted time step for a numerical integration process.\n\nArguments\n\ninitial_time::Float64: The initial time for the integration.\nend_time::Float64: The final time for the integration.\ndt::Float64: The time step size.\n\nReturns\n\nA tuple (nsteps, dt) where:\n\nnsteps::Int64: The number of integration steps required to cover the specified time range.\ndt::Float64: The adjusted time step size to evenly divide the time range.\n\nErrors\n\nThrows an error if the dt is less than or equal to zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Verlet.get_partial_stresses-Tuple{Module, AbstractVector{Int64}}","page":"Solver","title":"PeriLab.Solver_control.Verlet.get_partial_stresses","text":"get_partial_stresses(datamanager::Module, nodes::Vector{Int64})\n\nComputes the partial stresses.\n\nArguments\n\ndatamanager::Data_manager: Datamanager.\nnodes::Vector{Int64}: List of block nodes.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Verlet.init_solver-Tuple{Dict{Any, Any}, Dict, Dict{Any, Any}, Module, Dict{Int64, Vector{Int64}}}","page":"Solver","title":"PeriLab.Solver_control.Verlet.init_solver","text":"init_solver(params::Dict, bcs::Dict{Any,Any}, datamanager::Module, block_nodes::Dict{Int64,Vector{Int64}}, mechanical::Bool, thermo::Bool)\n\nInitialize the Verlet solver for a simulation.\n\nThis function sets up the Verlet solver for a simulation by initializing various parameters and calculating the time step based on provided parameters or critical time step calculations.\n\nArguments\n\nparams::Dict: A dictionary containing simulation parameters.\nbcs::Dict{Any,Any}: Boundary conditions\ndatamanager::Module: The data manager module that provides access to required data fields and properties.\nblock_nodes::Dict{Int64,Vector{Int64}}: A dictionary mapping block IDs to collections of nodes.\nmechanical::Bool: If true, mechanical properties are considered in the calculation.\nthermo::Bool: If true, thermodynamic properties are considered in the calculation.\n\nReturns\n\nA tuple (initial_time, dt, nsteps, numerical_damping) where:\n\ninitial_time::Float64: The initial time for the simulation.\ndt::Float64: The time step for the simulation.\nnsteps::Int64: The number of time integration steps.\nnumerical_damping::Float64: The numerical damping factor.\nmax_damage::Float64: The maximum damage in the simulation.\n\nDependencies\n\nThis function may depend on the following functions:\n\nget_initial_time, get_final_time, get_safety_factor, get_fixed_dt: Used to retrieve simulation parameters.\ncompute_crititical_time_step: Used to calculate the critical time step if dt is not fixed.\nget_integration_steps: Used to determine the number of integration steps and adjust the time step.\nfind_and_set_core_value_min and find_and_set_core_value_max: Used to set core values in a distributed computing environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Verlet.run_solver-Tuple{Dict{Any, Any}, Dict{Int64, Vector{Int64}}, Dict{Any, Any}, Module, Dict{Int64, Dict}, Vector{Dict}, Any, Any, Any, Any, TimerOutputs.TimerOutput, Bool}","page":"Solver","title":"PeriLab.Solver_control.Verlet.run_solver","text":"run_solver(\n    solver_options::Dict{Any,Any},\n    block_nodes::Dict{Int64,Vector{Int64}},\n    bcs::Dict{Any,Any},\n    datamanager::Module,\n    outputs::Dict{Int64,Dict{}},\n    result_files::Vector{Any},\n    synchronise_field,\n    write_results,\n    to::TimerOutputs.TimerOutput,\n    silent::Bool\n)\n\nRun the Verlet solver for a simulation based on the strategy provided in [1] and  [3].\n\nThis function performs the Verlet solver simulation, updating various data fields and properties over a specified number of time steps.\n\nArguments\n\nsolver_options::Dict{String,Any}: A dictionary containing solver options and parameters.\nblock_nodes::Dict{Int64,Vector{Int64}}: A dictionary mapping block IDs to collections of nodes.\nbcs::Dict{Any,Any}: A dictionary containing boundary conditions.\ndatamanager::Module: The data manager module that provides access to data fields and properties.\noutputs::Dict{Int64,Dict{}}: A dictionary for output settings.\nresult_files::Vector{Any}: A vector of result files.\nsynchronise_field: A function for synchronization.\nwrite_results: A function to write simulation results.\nto::TimerOutputs.TimerOutput: A timer output.\nsilent::Bool: A boolean flag to suppress progress bars.\n\nReturns\n\nresult_files: A vector of updated result files.\n\nDependencies\n\nThis function depends on various data fields and properties from the datamanager module, as well as several helper functions. It also relies on solver options and boundary conditions provided in the input parameters.\n\nFunction Workflow\n\nInitialize simulation parameters and data fields.\nPerform Verlet integration over a specified number of time steps.\nUpdate data fields and properties based on the solver options.\nWrite simulation results using the write_results function.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Verlet.test_timestep-Tuple{Float64, Float64}","page":"Solver","title":"PeriLab.Solver_control.Verlet.test_timestep","text":"test_timestep(t::Float64, critical_time_step::Float64)\n\nCompare a time step t with a critical time step critical_time_step and update critical_time_step if t is smaller.\n\nArguments\n\nt::Float64: The time step to compare with critical_time_step.\ncritical_time_step::Float64: The current critical time step.\n\nReturns\n\ncritical_time_step::Float64: The updated critical time step, which is either the original critical_time_step or t, whichever is smaller.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#Boundary_conditions","page":"Solver","title":"Boundary_conditions","text":"","category":"section"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Boundary_conditions.apply_bc_dirichlet-Tuple{Vector{String}, Dict, Module, Float64, Float64}","page":"Solver","title":"PeriLab.Solver_control.Boundary_conditions.apply_bc_dirichlet","text":"apply_bc_dirichlet(bcs::Dict, datamanager::Module, time::Float64)\n\nApply the boundary conditions\n\nArguments\n\nbcs::Dict{Any,Any}: The boundary conditions\ndatamanager::Module: Datamanager\ntime::Float64: The current time\n\nReturns\n\ndatamanager::Module: Datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Boundary_conditions.apply_bc_neumann-Tuple{Dict, Module, Float64, Float64}","page":"Solver","title":"PeriLab.Solver_control.Boundary_conditions.apply_bc_neumann","text":"apply_bc_neumann(bcs::Dict, datamanager::Module, time::Float64)\n\nApply the boundary conditions\n\nArguments\n\nbcs::Dict{Any,Any}: The boundary conditions\ndatamanager::Module: Datamanager\ntime::Float64: The current time\n\nReturns\n\ndatamanager::Module: Datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Boundary_conditions.boundary_condition-Tuple{Dict, Any}","page":"Solver","title":"PeriLab.Solver_control.Boundary_conditions.boundary_condition","text":"boundary_condition(params::Dict, datamanager)\n\nInitialize the boundary condition\n\nArguments\n\nparams::Dict: The parameters\ndatamanager::Module: Datamanager\n\nReturns\n\nbcs_out::Dict{Any,Any}: The boundary conditions\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Boundary_conditions.check_valid_bcs-Tuple{Dict{String, Any}, Module}","page":"Solver","title":"PeriLab.Solver_control.Boundary_conditions.check_valid_bcs","text":"check_valid_bcs(bcs::Dict{String,Any}, datamanager::Module\n\nCheck if the boundary conditions are valid\n\nArguments\n\nbcs::Dict{String,Any}: The boundary conditions\ndatamanager::Module: The data manager module\n\nReturns\n\nworking_bcs::Dict{String,Any}: The valid boundary conditions\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Boundary_conditions.clean_up-Tuple{String}","page":"Solver","title":"PeriLab.Solver_control.Boundary_conditions.clean_up","text":"clean_up(bc::String)\n\nClean up the boundary condition\n\nArguments\n\nbc::String: The boundary condition\n\nReturns\n\nbc::String: The cleaned up boundary condition\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Boundary_conditions.eval_bc!","page":"Solver","title":"PeriLab.Solver_control.Boundary_conditions.eval_bc!","text":"eval_bc!(field_values::Union{Vector{Float64},Vector{Int64}}, bc::Union{Float64,Float64,Int64,String}, coordinates::Matrix{Float64}, time::Float64, dof::Int64)\n\nWorking with if-statements \"if t>2 0 else 20 end\" works for scalars. If you want to evaluate a vector, please use the Julia notation as input \"ifelse.(x .> y, 10, 20)\"\n\n\n\n\n\n","category":"function"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Boundary_conditions.find_bc_free_dof-Tuple{Module, Dict{Any, Any}}","page":"Solver","title":"PeriLab.Solver_control.Boundary_conditions.find_bc_free_dof","text":"find_bc_free_dof(datamanager::Module, bcs::Dict{String,Any})\n\nFinds all dof without a displacement boundary condition. This tuple vector is stored in the datamanager.\n\nArguments\n\ndatamanager::Module: The data manager module\nbcs::Dict{String,Any}: The boundary conditions\n\nReturns\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_control.Boundary_conditions.init_BCs-Tuple{Dict, Any}","page":"Solver","title":"PeriLab.Solver_control.Boundary_conditions.init_BCs","text":"init_BCs(params::Dict, datamanager)\n\nInitialize the boundary conditions\n\nArguments\n\nparams::Dict: The parameters\ndatamanager::Module: Datamanager\n\nReturns\n\nbcs::Dict{Any,Any}: The boundary conditions\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/","page":"Solver","title":"Solver","text":"","category":"page"},{"location":"theory/theory_ordinary/#Ordinary-state-based-Peridynamics","page":"Ordinary state-based","title":"Ordinary state-based Peridynamics","text":"","category":"section"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"info: Info\nMore details can be found here [4]","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"For an isotropic Peridynamic solid and small deformations we can define underlinex=underlinemathbfX and  underliney=underlinemathbfY and underlinee=underliney-underlinex","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"In general underlinemathbfY-underlinemathbfXnequnderlinee. The force density scalar state can be defined as underlinet=underlinemathbfT","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"The weighted volume is","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"m_V = int_mathcalH underlineomegalangle boldsymbolxirangle underlinex underlinex dV","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"The dilatation is given as","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"theta = frac3m_V = int_mathcalHunderlineomegalangle boldsymbolxirangle underlinex underlineelangle boldsymbolxirangle dV","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"underlinet = fracomegalangle boldsymbolxirangle m_Vleft3K theta underlinex + 15G underlinee^d  right","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"with the decomposition in the devatoring and isotropic part of the strain","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"underlinee^dlangle boldsymbolxirangle = epsilon_ij^dxi_ifracx_jboldsymbolxi","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"and","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"underlinee^ilangle boldsymbolxirangle = epsilon_ij^ixi_ifracx_jboldsymbolxi","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"The force density can be determined as","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"underlinemathbfT=underlinetfracunderlinemathbfYunderlinemathbfY","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"For plane stress and plane strain the equations are taken form [1].","category":"page"},{"location":"theory/theory_ordinary/","page":"Ordinary state-based","title":"Ordinary state-based","text":"","category":"page"},{"location":"lib/helper_functions/#Helper-Functions","page":"Helper","title":"Helper - Functions","text":"","category":"section"},{"location":"lib/helper_functions/#Index","page":"Helper","title":"Index","text":"","category":"section"},{"location":"lib/helper_functions/","page":"Helper","title":"Helper","text":"Pages = [\"helper_functions.md\"]","category":"page"},{"location":"lib/helper_functions/#Helpers","page":"Helper","title":"Helpers","text":"","category":"section"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.check_inf_or_nan-Tuple{Any, Any}","page":"Helper","title":"PeriLab.Solver_control.Helpers.check_inf_or_nan","text":"check_inf_or_nan(array, msg)\n\nChecks if the sum of the array is finite. If not, an error is raised.\n\nArguments\n\narray: The array to check.\nmsg: The error message to raise.\n\nReturns\n\nBool: true if the sum of the array is finite, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.compute_free_surface_nodes-Tuple{Union{Matrix{Float64}, Matrix{Int64}}, Vector{Int64}, Vector{Int64}}","page":"Helper","title":"PeriLab.Solver_control.Helpers.compute_free_surface_nodes","text":"compute_surface_nodes_and_connections(points::Union{Matrix{Float64},Matrix{Int64}},\n                                           poly, free_surfaces::Vector{Int64})\n\nComputes the points which are connected free surfaces (()). This function is used for contact search purposes. The free surface nodes are used to compute the nearest neighbors. The connections and underlying points are needed for the contact algorithm. They are a subset of the surface points to create the polyhedron and the only ones which can be in contact.\n\nArguments\n\npoints::Union{Matrix{Float64},Matrix{Int64}}: Points which form the polyhedron.\npoly: Polyhedron object.\nfree_surfaces::Vector{Int64}: List of the free surfaces of the polyhedron.\n\nReturns\n\nconnections: Tthe connections to the free surfaces. There can be more surface points than connections.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.create_centroid_and_search_radius-Tuple{Union{Matrix{Float64}, Matrix{Int64}}, Matrix{Int64}, Int64, Any}","page":"Helper","title":"PeriLab.Solver_control.Helpers.create_centroid_and_search_radius","text":"create_centroid_and_search_radius(coor::Union{Matrix{Float64},Matrix{Int64}},\n                                  el_topology::Matrix{Int64},\n                                  dof::Int64,\n                                  fu)\n\nComputes the centroid and Contact Radius for each element in a given mesh.\n\nArguments\n\ncoor::Union{Matrix{Float64}, Matrix{Int64}}:   A matrix of size (N x dof), where each row represents the coordinates of a point in the space.\nel_topology::Matrix{Int64}:   A matrix of size (M x num_nodes), where each row contains the indices of points that define an element.\ndof::Int64:   The number of spatial dimensions (degrees of freedom), e.g., 2 for 2D and 3 for 3D.\nfu:   A function of four point 2D surface or eight point 3D volume.\n\nReturns\n\nel_centroid::Matrix{Float64}: A matrix of size (M Ã— dof), where each row represents the centroid of an element.\nsearch_radius::Vector{Float64}: A vector of size M, where each entry is the maximum distance from the element centroid to any of its nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.find_files_with_ending-Tuple{AbstractString, AbstractString}","page":"Helper","title":"PeriLab.Solver_control.Helpers.find_files_with_ending","text":"find_files_with_ending(folder_path::AbstractString, file_ending::AbstractString)\n\nReturns a list of files in folder_path that end with file_ending.\n\nArguments\n\nfolder_path::AbstractString: The path to the folder.\nfile_ending::AbstractString: The ending of the files.\n\nReturns\n\nfile_list::Vector{String}: The list of files that end with file_ending.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.find_indices-Tuple{Any, Any}","page":"Helper","title":"PeriLab.Solver_control.Helpers.find_indices","text":"find_indices(vector, what)\n\nReturns the indices of vector that are equal to what.\n\nArguments\n\nvector::Vector: The vector to search in.\nwhat: The value to search for.\n\nReturns\n\nindices::Vector: The indices of vector that are equal to what.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.find_inverse_bond_id-Tuple{Vector{Vector{Int64}}}","page":"Helper","title":"PeriLab.Solver_control.Helpers.find_inverse_bond_id","text":"find_inverse_bond_id(nlist::Vector{Vector{Int64}})\n\nFinds the inverse of the bond id in the nlist.\n\nArguments\n\nnlist::Vector{Vector{Int64}}: The nlist to find the inverse of.\n\nReturns\n\ninverse_nlist::Vector{Dict{Int64,Int64}}: The inverse nlist.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.get_active_update_nodes-NTuple{4, Any}","page":"Helper","title":"PeriLab.Solver_control.Helpers.get_active_update_nodes","text":"get_active_update_nodes(active::Vector{Bool}, update_list::Vector{Bool}, nodes::Vector{Int64}, index::Vector{Int64})\n\nReturns the active nodes and the update nodes.\n\nArguments\n\nactive::Vector{Bool}: The active vector.\nupdate_list::Vector{Bool}: The update vector.\nnodes::Vector{Int64}: The vector of nodes.\nindex::Vector{Int64}: Pre allocated Vector.\n\nReturns\n\nupdate_nodes::Vector{Int64}: The nodes of update that are true.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.get_block_nodes-Tuple{Any, Any}","page":"Helper","title":"PeriLab.Solver_control.Helpers.get_block_nodes","text":"get_block_nodes(block_ids, nnodes)\n\nReturns a dictionary mapping block IDs to collections of nodes.\n\nArguments\n\nblock_ids::Vector{Int64}: A vector of block IDs\nnnodes::Int64: The number of nodes\n\nReturns\n\nblock_nodes::Dict{Int64,Vector{Int64}}: A dictionary mapping block IDs to collections of nodes\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.get_fourth_order-Union{Tuple{DOF}, Tuple{AbstractMatrix{Float64}, Val{DOF}}} where DOF","page":"Helper","title":"PeriLab.Solver_control.Helpers.get_fourth_order","text":"get_fourth_order(CVoigt, dof)\n\nConstructs a symmetric fourth-order tensor from a Voigt notation vector. It uses Tensors.jl package.\n\nThis function takes a Voigt notation vector CVoigt and the degree of freedom dof to create a symmetric fourth-order tensor. The CVoigt vector contains components that represent the tensor in Voigt notation, and dof specifies the dimension of the tensor.\n\nArguments\n\nCVoigt::Matrix{Float64}: A vector containing components of the tensor in Voigt notation.\ndof::Int64: The dimension of the resulting symmetric fourth-order tensor.\n\nReturns\n\nSymmetricFourthOrderTensor{dof}: A symmetric fourth-order tensor of dimension dof.\n\nExample\n\n```julia CVoigt = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0] dof = 3 result = getfourthorder(CVoigt, dof)\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.get_hexagon-Tuple{Union{Matrix{Float64}, Matrix{Int64}}, Vector{Int64}}","page":"Helper","title":"PeriLab.Solver_control.Helpers.get_hexagon","text":"get_hexagon(coor::Union{Matrix{Float64},Matrix{Int64}}, topo::Vector{Int64})\n\nDescription\n\nThis function gives the hexahedron model back to compute centroids of this surface and check if a point lies inside. The el_topology has to be transformed from PeriLab notation, to avoid overlapping.\n\nArguments\n\ncoor::Union{Matrix{Float64},Matrix{Int64}}: Coordinates.\ntopo::Vector{Int64}: el_topology of an element.\n\nReturns\n\nHexahedron: eight point hexahedron.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.get_ring-Tuple{Union{Matrix{Float64}, Matrix{Int64}}, Vector{Int64}}","page":"Helper","title":"PeriLab.Solver_control.Helpers.get_ring","text":"get_ring(coor::Union{Matrix{Float64},Matrix{Int64}}, topo::Vector{Int64})\n\nDescription\n\nThis function gives the ring model back to compute centroids of this surface and check if a point lies inside. The el_topology has to be transformed from PeriLab notation, to avoid overlapping.\n\nArguments\n\ncoor::Union{Matrix{Float64},Matrix{Int64}}: Coordinates.\ntopo::Vector{Int64}: el_topology of an element.\n\nReturns\n\nRing: four point closed surface.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.invert","page":"Helper","title":"PeriLab.Solver_control.Helpers.invert","text":"invert(A::Union{Matrix{Float64},Matrix{Int64}}, error_message::String=\"Matrix is singular\")\n\nInvert a n x n matrix. Throws an error if A is singular.\n\nArguments\n\nA::Union{Matrix{Float64},Matrix{Int64}}: A n x n matrix.\nerror_message::String=\"Matrix is singular\": The error message returned if A is singular.\n\nReturns\n\ninverted matrix or nothing if not inverable.\n\n\n\n\n\n","category":"function"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.matrix_style-Tuple{Any}","page":"Helper","title":"PeriLab.Solver_control.Helpers.matrix_style","text":"matrix_style(A)\n\nInclude a scalar or an array and reshape it to style needed for LinearAlgebra package\n\nArguments\n\nA: The array or scalar to reshape\n\nReturns\n\nArray: The reshaped array\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.matrix_to_vector-Tuple{Union{Matrix{Float64}, Matrix{Int64}}}","page":"Helper","title":"PeriLab.Solver_control.Helpers.matrix_to_vector","text":" matrix_to_vector(mat::Union{Matrix{Float64},Matrix{Int64}})\n\nTransforming a matrix representation in a Vector{Vector} representation.\n\nArguments\n\nmat::Union{Matrix{Float64},Matrix{Int64}}: Points which form the polyhedron.\n\nReturns\n\n``: transformed data\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.progress_bar-Tuple{Int64, Int64, Bool}","page":"Helper","title":"PeriLab.Solver_control.Helpers.progress_bar","text":"progress_bar(rank::Int64, nsteps::Int64, silent::Bool)\n\nCreate a progress bar if the rank is 0. The progress bar ranges from 1 to nsteps + 1.\n\nArguments\n\nrank::Int64: An integer to determine if the progress bar should be created.\nnsteps::Int64: The total number of steps in the progress bar.\nsilent::Bool: de/activates the progress bar\n\nReturns\n\nProgressBar or UnitRange: If rank is 0, a ProgressBar object is returned. Otherwise, a range from 1 to nsteps + 1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.qdim-Tuple{Int64, Int64}","page":"Helper","title":"PeriLab.Solver_control.Helpers.qdim","text":"qdim(order::Int64, dof::Int64)\n\nCalculate the number of terms in a polynomial expansion up to a specified accuracy order. Simplied first complex loop in Peridigm correspondence::computeLagrangianGradientWeights. In the unit test this values where tested.\n\nArguments\n\norder::Int64: The accuracy order of the polynomial expansion.\n\nReturns\n\nInt64: The total number of terms in the polynomial expansion.\n\nDescription\n\nThis function calculates the number of terms in a polynomial expansion up to the specified accuracy order using an analytical formula derived from combinatorial considerations. The function iterates over each order from 1 to the specified order and calculates the sum of binomial coefficients according to the formula: qdim(order) = Î£(i=1 to order) [(i+2)! / (2! * i!)]\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.rotate-Tuple{AbstractVector{Int64}, Union{Array{Float64, 3}, SubArray}, Union{Array{Float64, 3}, SubArray}, Bool}","page":"Helper","title":"PeriLab.Solver_control.Helpers.rotate","text":"rotate(nodes::AbstractVector{Int64}, dof::Int64, matrix::Union{SubArray,Array{Float64,3}}, angles::SubArray, back::Bool)\n\nRotates the matrix.\n\nArguments\n\nnodes::AbstractVector{Int64}: List of block nodes.\nmatrix::Union{SubArray,Array{Float64,3}}: Matrix.\nrot::SubArray: Rotation tensor.\nback::Bool: Back.\n\nReturns\n\nmatrix::SubArray: Matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Solver_control.Helpers.rotate_second_order_tensor-Tuple{Matrix{Float64}, Matrix{Float64}, Bool}","page":"Helper","title":"PeriLab.Solver_control.Helpers.rotate_second_order_tensor","text":"rotate_second_order_tensor(angles::Union{Vector{Float64},Vector{Int64}}, tensor::Matrix{Float64}, dof::Int64, back::Bool)\n\nRotates the second order tensor.\n\nArguments\n\nangles::Union{Vector{Float64},Vector{Int64}}: Angles.\ntensor::Matrix{Float64}: Second order tensor.\ndof::Int64: Degree of freedom.\nback::Bool: Back.\n\nReturns\n\ntensor::Matrix{Float64}: Second order tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/","page":"Helper","title":"Helper","text":"","category":"page"},{"location":"theory/theory_thermal/#Thermal-models","page":"Thermal Models","title":"Thermal models","text":"","category":"section"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"The theory is taken from [9]","category":"page"},{"location":"theory/theory_thermal/#Thermo-mechanics","page":"Thermal Models","title":"Thermo-mechanics","text":"","category":"section"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"To introduce a thermo-mechanical coupling the mechanical strains in have to be expanded with the thermal strains:","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"boldsymbolvarepsilon=boldsymbolvarepsilon_mechanical + boldsymbolvarepsilon_thermal","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"The thermal strains are defined as boldsymbolvarepsilon_thermal =- boldsymbolalphatau with tau as the temperature increment and boldsymbolalpha as matrix of the coefficients of thermal expansion. Typically, this matrix is diagonal. The coupled stresses for linear elastic material utilizing Hook's law is given as boldsymbolsigma=mathbfCcdotcdotleft(boldsymbolvarepsilon_mechanical - boldsymbolalphatau right)","category":"page"},{"location":"theory/theory_thermal/#Thermal-flux","page":"Thermal Models","title":"Thermal flux","text":"","category":"section"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"The mechanical response due to temperature changes is included in the Peridynamics model. However, the heat flux must be included as well.  Under the assumption that mechanical deformations do not change the temperature, the thermodynamic equilibrium equation can be studied separately.","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"rho C_vdottau = int_mathcalH(underlineh(textbfxt)langleboldsymbolxirangle-underlineh(textbfxt)langleboldsymbolxirangle)dV_textbfx+ S_i","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"The parameters are rho the mass density, C_v the specific heat capacity, dottau the temperature gradient in time, dV_textbfx the volume and S_i the heat sink or heat source. The heat flux of a bond is defined as","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"underlineh(textbfxt)langleboldsymbolxirangle = mathbfq^TmathbfK^-1(textbfx)boldsymbolxi","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"with mathbfq as classical heat flux and mathbfK as the shape tensor. It follows","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"nablacdotmathbfq = int_mathcalHleftmathbfq(textbfx)^TmathbfK^-1(textbfx)+mathbfq(textbfx)^TmathbfK^-1(textbfx)rightboldsymbolxidV_textbfx","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"which can be derived utilizing the spatial gradient of the temperature nablatau as","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"mathbfq = -boldsymbollambdanablatau","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"boldsymbollambda","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"is the 3times3 matrix of thermal conductivity. Typically it is a diagonal matrix. Following \\cite{BrighentiR2021} the spatial temperature gradient nablatau can be derived as","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"nablatau = mathbfK^-1int_mathcalHlefttau(mathbfx)-tau(mathbfx)rightboldsymbolxiunderlineomegalangleboldsymbolxirangle dV_mathbfx","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"The numerical solving process is then","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"rho C_v fractau^t+dt-tau^tdt=nablamathbfq + S_i","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"tau^t+dt = dtfracnablamathbfq + S_irho C_v + tau^t","category":"page"},{"location":"theory/theory_thermal/#Heat-transfer-to-environment","page":"Thermal Models","title":"Heat transfer to environment","text":"","category":"section"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"Following \\cite{GuX2019c,OterkusS2014b} the heat volumetric density at the surface for a assigned heat flux normal to the surface q_bc is: S_i = fracq_bcDelta","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"where Delta can be set to dx. Thereby, q_bc is","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"q_bc = kappa (tau-tau_env)","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"where kappa is the heat convection coefficient between solid and environment and tau_env the environmental temperature. For a mesh free model the question arises how the outer surface and the corresponded surface can be identified. For the outer surface the Peridynamics neighborhood mathcalH is utilized. It is assumed that is circle for 2D and a sphere for 3D. Therefore, the following criteria has to be fulfilled for 2D","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"V_2D=2pidelta^2 h geq int_mathcalHdV","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"and 3D V_3D=frac43pidelta^3 geq int_mathcalHdV","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"Each point which is next to the surface will have less volume represented be the discrete material points. Defining a limit value f_limit leq V_specific =  fracint_mathcalHdVV_2Dor3D allows an easy identification of surface nodes i during the printing process. Combining the heat flow and the convection model allows the computation of the change in temperature for these nodes i as tau_i^t+dt = dtfracnablamathbfq_i + frackappa (tau_i^t-tau_env)dx(rho C_v)_i + tau^t_i","category":"page"},{"location":"theory/theory_thermal/#Time-step","page":"Thermal Models","title":"Time step","text":"","category":"section"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"The minimum time step for the explicit time integration of the temperature field to obtain a stable solution is given by Delta t  textminleft(fracleft(rho C_vright)_isum_j=1^Nfractextmax(texteig(boldsymbollambda))mathbfxi_ijV_jright) with N the number of neighbors of point i [24].","category":"page"},{"location":"theory/theory_thermal/","page":"Thermal Models","title":"Thermal Models","text":"","category":"page"},{"location":"man/dev/module_integration/#Module-integration","page":"Module integration","title":"Module integration","text":"","category":"section"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"If you want to integrate your own model check if it suits in one of the predefined classes material, damage, additive, thermal or degradation. If so check the template folder.","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"info: Material Template\nMaterials have multiple templates, because the correspondence formulation allows additional options.","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"Each template has a init function, a name function, a compute function.","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"Copy the template and put it in the folder. Change all the functions and give the module a name.","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"info: Automatic Integration\nIn PeriLab makros are used to automatically integrate your model.","category":"page"},{"location":"man/dev/module_integration/#Parameter","page":"Module integration","title":"Parameter","text":"","category":"section"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"In PeriLab a field called params exists. This field provides all the material information. The structure is given here","category":"page"},{"location":"man/dev/module_integration/#Init-function","page":"Module integration","title":"Init function","text":"","category":"section"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"The init function is used to read and check the  properties provided by the yaml. It should be done there, because if the compute function is used, this check is done in every time step. Also specific fields can be defined here as well.","category":"page"},{"location":"man/dev/module_integration/#Name-function","page":"Module integration","title":"Name function","text":"","category":"section"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"This function defines the name of the module. This name is used to call this model from the yaml.","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"info: Correspondence\nIf you want to integrate a correspondence model, make sure ''Correspodence'' occur in the material name","category":"page"},{"location":"man/dev/module_integration/#Compute-function","page":"Module integration","title":"Compute function","text":"","category":"section"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"This function is called from the solver. You can call whatever function you like from here. However, this function should evaluate the result needed for the solving process, e.g. heat flux or force densities.","category":"page"},{"location":"man/dev/module_integration/#Module-name","page":"Module integration","title":"Module name","text":"","category":"section"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"You can setup the module name as you like as long as it does not exist a second time in PeriLab.","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"info: Coding Style\nPlease name the module file and the module equaly.","category":"page"},{"location":"man/dev/module_integration/#Creating-your-own-model-category","page":"Module integration","title":"Creating your own model category","text":"","category":"section"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"warn: Creating your own model category\nThis is advanced programming. Feel free to contact the developers for help.","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"To integrate a model category somewhere you have to do the following things. You need a main function of your modeling category. The existing ones are the factory files. These modules have a init function and a compute function. The init function find the modules of the category and the compute function calls these modules during the solving process.","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"Here, the call for the init function is shown for the material factory.","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"mod = Set_modules.create_module_specifics(material_model, module_list, \"material_name\")\ndatamanager.set_model_module(material_model, mod)","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"The module_list is optained, by applying","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"global module_list = Set_modules.find_module_files(@__DIR__, \"material_name\")\nSet_modules.include_files(module_list)","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"You can integrate these functions than in the compute function of the factory module.","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"mod = datamanager.get_model_module(material_model)\ndatamanager = mod.compute_model(datamanager, nodes, model_param, time, dt, to)","category":"page"},{"location":"man/dev/module_integration/","page":"Module integration","title":"Module integration","text":"","category":"page"},{"location":"man/output/#Output","page":"Output","title":"Output","text":"","category":"section"},{"location":"man/output/#Output-File-Type","page":"Output","title":"Output File Type","text":"","category":"section"},{"location":"man/output/","page":"Output","title":"Output","text":"Currently Exodus and CSV are supported as output types.","category":"page"},{"location":"man/output/","page":"Output","title":"Output","text":"warning: CSV File\nOnly variables that are defined as global variables are supported.","category":"page"},{"location":"man/output/","page":"Output","title":"Output","text":"tip: Flush File\nBy default the output files will be flushed after each write-step, meaning you can look at the results while the simulation is still running.","category":"page"},{"location":"man/output/#Output-Frequency-/-Number-of-Output-Steps","page":"Output","title":"Output Frequency / Number of Output Steps","text":"","category":"section"},{"location":"man/output/","page":"Output","title":"Output","text":"As the number of solver steps can be quite large and you don't want to buy new drives for every simulation we want to specify the number of output steps written.","category":"page"},{"location":"man/output/","page":"Output","title":"Output","text":"You can either specify the total number of output steps via Number of Output Steps or the frequency of output via Output Frequency.","category":"page"},{"location":"man/output/","page":"Output","title":"Output","text":"tip: First time users\nFor first time users we will recommend to use Number of Output Steps in the range of 100 to 1000. Depending on your discretization this is enough to get a good idea of the simulation results.","category":"page"},{"location":"man/output/","page":"Output","title":"Output","text":"tip: Only damage\nIf you want to take a closer look at damage initiation and propagation and are worried about the result file size, you can write another output file with Write After Damage set to true.","category":"page"},{"location":"man/output/#Output-Variables","page":"Output","title":"Output Variables","text":"","category":"section"},{"location":"man/output/","page":"Output","title":"Output","text":"Below you can find a list of all current Output Variables and the necessary Prerequisites.","category":"page"},{"location":"man/output/","page":"Output","title":"Output","text":"Variable Prerequisite\nDensity -\nHorizon -\nNumber of Neighbors -\nNumber of Filtered Neighbors Bond-Filter\nUpdate List -\nActive -\nDisplacements -\nVelocity -\nAcceleration -\nForces -\nForce Densities -\nCauchy Stress -\nvon Mises Stress -\nOrientations Rotated Nodes\nDamage Damage Model\nWeighted Volume PD Solid Elastic\nDilatation PD Solid Elastic\nYield Value PD Solid Plastic\nLambda Plastic PD Solid Plastic\nStrain Correspondence\nZero Energy Stiffness Correspondence\nPlastic Strain Correspondence Plastic\nTemperature Thermal Models\nDelta Temperature Thermal Models\nHeat Flow Thermal Models\nSpecific Heat Capacity Thermal Models\nSpecific Volume Thermal Models\nSurface_Nodes Thermal Models\nConcentration Degradation Models\nDelta Concentration Degradation Models\nConcentration Flux Degradation Models\nLumbed Mass Matrix FEA\nFE Nodes FEA","category":"page"},{"location":"man/output/","page":"Output","title":"Output","text":"info: Own Variables\nAll variables that are defined as global variables are supported as well as those defined in the mesh input f.e.: Angles","category":"page"},{"location":"man/output/","page":"Output","title":"Output","text":"","category":"page"},{"location":"#PeriLab","page":"Introduction","title":"PeriLab","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the PeriLab documentation!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This resource aims to teach you everything you need to know to get up and running with tabular data manipulation using the PeriLab.jl package.","category":"page"},{"location":"#What-is-PeriLab.jl?","page":"Introduction","title":"What is PeriLab.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PeriLab.jl provides a Peridynamics [1] simulation core based on the material point method (MPM) [2].","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It's design and functionality are similar to those of Peridigm  [3] and several extenions [4], [5], [6].","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: PeriLab Project\nThe PeriLab project is built on collaboration and aims to make the world a better place. There is no space here for bullies, racists, or fascists. Groups like MAGA, AfD, and others that actively oppose progress and a better future are not welcome. If spreading hate is your goal, do it elsewhere.","category":"page"},{"location":"#PeriLab.jl-and-the-Peridynamics-Ecosystem","page":"Introduction","title":"PeriLab.jl and the Peridynamics Ecosystem","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Mesh-free particle-based methods are mostly used for the numerical approximation of peridynamics equations. [7] provides an overview of current Peridynamics software developments. In addition to this, many local research groups are also developing their software. Most of the listed tools are problem-specific or developed by a single person. The most sophisticated software tools are EMU and Peridigm. EMU is not open source, but researchers can request the code. However, due to the code developments at the Sandia National labs and the rules of development, the code is officially not usable because the rules violate the \"Treaty on the Non-Proliferation of Nuclear Weapons\".","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Peridigm is an open-source tool that can be used for large-scale problems. It includes multiple material laws, simple damage models. Peridigm is usable under a BSD license. Currently, there is some irregular development ongoing. It provides multiple ways of model input and provides Paraview readable output. The whole code allows the analysis of large-scale problems. A lot of research has been performed utilizing the software.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"sankey-beta\n    Installation,Run time,20\n    Build time, Run time, 10\n    Implementation / Debugging, Run time, 60\n    Calculation, Run time,10\n    Run time, Installation productive, 0\n    Run time, Build time productive, 10\n    Run time, Implementation / Debugging productive, 10\n    Run time, Calculation productive, 80","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"One challenge, however, remains. How can Peridynamics be widely adopted? Classical continuum mechanics is extensively utilized in the engineering field through the finite element method. There is a multitude of commercial and non-commercial software tools available for this purpose. In the case of Peridynamics, this is not the case. Peridigm as the most advanced one provides an open-source code with many functionalities. However, the implementation effort is substantial, and the installation process is difficult and time-consuming. To implement the simplest material law you have to edit at least five files. If you add new files and folders in the project you have to deal with cmake scripts and all challenges related to it.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Moreover, the program is only partially maintained. This results in valuable research findings being underutilized, and Peridynamics, as a result, finds limited application outside of specific niche problems. There is a significant need for software that combines functionality, easy installation, and seamless integration.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"quadrantChart\n    x-axis Low Functionalty --> High Functionalty\n    y-axis Hard to use --> Simple to use\n    Peridigm: [0.85, 0.2]\n    PeriLab: [0.75, 0.8]\n    EMU: [0.95, 0.1]\n    PeriPy: [0.2, 0.7]\n    Peridynamics.jl: [0.7, 0.6]\n    PeriPyDIC: [0.2, 0.6]\n    LAMMPS: [0.3, 0.3]\n    PeriFlakes: [0.35, 0.4]\n    Relation-Based Software: [0.4, 0.25]\n    BB_PD: [0.2, 0.50]\n    PeriDEM: [0.13, 0.3]","category":"page"},{"location":"#Questions?","page":"Introduction","title":"Questions?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If there is something you expect PeriLab to be capable of, but cannot figure out how to do, please reach out with questions in Domains/Data on Discourse.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Please report bugs by opening an issue.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can follow the source links throughout the documentation to jump right to the source files on GitHub to make pull requests for improving the documentation and function capabilities.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Please review PeriLab contributing guidelines before submitting your first PR!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Information on specific versions can be found on the Release page.","category":"page"},{"location":"#Package-Manual","page":"Introduction","title":"Package Manual","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"man/basics.md\",\n         \"man/getting_started.md\"]\nDepth = 2","category":"page"},{"location":"#API","page":"Introduction","title":"API","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Only exported (i.e. available for use without PeriLab. qualifier after loading the PeriLab.jl package with using PeriLab) types and functions are considered a part of the public API of the PeriLab.jl package. In general all such objects are documented in this manual (in case some documentation is missing please kindly report an issue here).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"theory/theory_damage/#Damage-Models-Theory","page":"Damage Models Theory","title":"Damage Models Theory","text":"","category":"section"},{"location":"theory/theory_damage/#Critical-stretch","page":"Damage Models Theory","title":"Critical stretch","text":"","category":"section"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"The critical stretch model is widely used in literature [1], [33]. It defines the critical length change, or stretch s as a criterion for a damage.","category":"page"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"s_critleq s frac underlinemathbfY  underlinemathbfX ","category":"page"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"The advantage of this criterion is, that the implementation is rather simple. Also the result is purely geometrical and therefore not influenced by the origin of the bond, because it is neighborhood independent. However, for complex load cases it is to simple and won't work well.","category":"page"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"Some literature describes the possibility to compute the critical stretch based on the energy release rate.","category":"page"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"s_crit = sqrtfracG_0C3G+(frac34)^4(K-frac5G3)delta","category":"page"},{"location":"theory/theory_damage/#Critical-energy","page":"Damage Models Theory","title":"Critical energy","text":"","category":"section"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"The critical energy model introduced by [34] is valid for state-based peridynamic analysis. The bond energy is defined as:","category":"page"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"w_bond = int_boldsymboleta_final (mathbfunderlineTxtlangle x-xrangle - mathbfunderlineTxtlangle x-xrangle)dboldsymboleta","category":"page"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"with the relative displacement vector as:","category":"page"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"boldsymboleta=mathbfunderlineuxt-mathbfunderlineuxt","category":"page"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"If the bond energy is greater than or equal to the critical energy value, then the bond is considered to be broken:","category":"page"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"w_crit leq w_bond","category":"page"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"Following [34] the critical bond energy can be defined as:","category":"page"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"w_crit = frac4G_0Cpidelta^4","category":"page"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"info: Direction\nBecause the bond energy potential can be different in ij compared to ji, the stiffness matrix can become unsymmetric. This is a difference to the critical stretch model. However, the critical stretch varies this might occur as well.","category":"page"},{"location":"theory/theory_damage/","page":"Damage Models Theory","title":"Damage Models Theory","text":"","category":"page"},{"location":"man/basics/#First-Steps-with-PeriLab","page":"First Steps with PeriLab","title":"First Steps with PeriLab","text":"","category":"section"},{"location":"man/basics/#Setting-up-the-Environment","page":"First Steps with PeriLab","title":"Setting up the Environment","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with PeriLab","title":"First Steps with PeriLab","text":"If want to use the PeriLab package you need to install it first. You can do it using the following commands:","category":"page"},{"location":"man/basics/","page":"First Steps with PeriLab","title":"First Steps with PeriLab","text":"using Pkg\n\nPkg.add(\"PeriLab\")","category":"page"},{"location":"man/basics/","page":"First Steps with PeriLab","title":"First Steps with PeriLab","text":"or","category":"page"},{"location":"man/basics/","page":"First Steps with PeriLab","title":"First Steps with PeriLab","text":"julia> ] # ']' should be pressed\n\n(@v1.9) pkg> add PeriLab","category":"page"},{"location":"man/basics/","page":"First Steps with PeriLab","title":"First Steps with PeriLab","text":"Additionally, it is recommended to check the version of PeriLab that you have installed with the status command.","category":"page"},{"location":"man/basics/","page":"First Steps with PeriLab","title":"First Steps with PeriLab","text":"julia> ]\n\n(@v1.9) pkg> status PeriLab\n      Status `~\\v1.6\\Project.toml`\n  [a93c6f00] PeriLab v1.0.0","category":"page"},{"location":"man/basics/","page":"First Steps with PeriLab","title":"First Steps with PeriLab","text":"Throughout the rest of the tutorial we will assume that you have installed the PeriLab package and have already typed using PeriLab which loads the package:","category":"page"},{"location":"man/basics/","page":"First Steps with PeriLab","title":"First Steps with PeriLab","text":"using PeriLab","category":"page"},{"location":"man/basics/","page":"First Steps with PeriLab","title":"First Steps with PeriLab","text":"If you want to make sure everything works as expected you can run the tests bundled with PeriLab:","category":"page"},{"location":"man/basics/","page":"First Steps with PeriLab","title":"First Steps with PeriLab","text":"using Pkg\n\nPkg.test(\"PeriLab\") # This will take a few minutes.","category":"page"},{"location":"man/basics/","page":"First Steps with PeriLab","title":"First Steps with PeriLab","text":"","category":"page"},{"location":"lib/data_manager_functions/#Data-Manager-Functions","page":"Data Manager","title":"Data Manager - Functions","text":"","category":"section"},{"location":"lib/data_manager_functions/#Index","page":"Data Manager","title":"Index","text":"","category":"section"},{"location":"lib/data_manager_functions/","page":"Data Manager","title":"Data Manager","text":"Pages = [\"data_manager_functions.md\"]","category":"page"},{"location":"lib/data_manager_functions/#Data_manager","page":"Data Manager","title":"Data_manager","text":"","category":"section"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager._get_field-Tuple{String}","page":"Data Manager","title":"PeriLab.Data_manager._get_field","text":"_get_field(name::String)\n\nReturns the field with the given name.\n\nArguments\n\nname::String: The name of the field.\n\nReturns\n\nfield::Field: The field with the given name.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.add_active_model","page":"Data Manager","title":"PeriLab.Data_manager.add_active_model","text":"add_active_model(key::String, module_name::Module)\n\nAdd the main modules to an OrderedDict which are active.\n\nArguments\n\nkey::String: Name of the model.\nactive_module::Module: Module of the active models.\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.check_property-Tuple{Int64, String}","page":"Data Manager","title":"PeriLab.Data_manager.check_property","text":"check_property(block_id::Int64, property::String)\n\nChecks if the specified property exists for the given block_id.\n\nArguments\n\nblock_id::Int64: The ID of the block.\nproperty::String: The name of the property to check.\n\nReturns\n\nBool: true if the property exists, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.create_bond_field","page":"Data Manager","title":"PeriLab.Data_manager.create_bond_field","text":"create_bond_field(name::String, type::Type, dof::Int64)\n\nCreates a bond field with the given name, data type, and degree of freedom.\n\nArguments\n\nname::String: The name of the bond field.\nvartype::Type: The data type of the bond field.\ndof::Int64: The degrees of freedom per bond.\nVectorOrArray::String (optional) - Vector or Materix; Default is vector\n\nReturns\n\nbond_field::Field: The created bond field for the current time step.\nbond_field_np1::Field: The created bond field for the next time step.\n\nExample:\n\ncreate_bond_field(\"stress\", Float64, 6)  # creates a stress bond field with 6 degrees of freedom\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.create_constant_bond_field","page":"Data Manager","title":"PeriLab.Data_manager.create_constant_bond_field","text":"create_constant_bond_field(name::String, type::Type, dof::Int64, default_value::Union{Int64,Float64,Bool}=0))\n\nCreates a constant bond field with the given name, data type, and degree of freedom.\n\nArguments\n\nname::String: The name of the bond field.\nvartype::Type: The data type of the bond field.\ndof::Int64: The degrees of freedom per bond.\ndefault_value::Union{Int64,Float64,Bool}=0) (optional) - filled with zero or false\n\nReturns\n\nconstant_bond_field::Field: The created constant bond field.\n\nExample:\n\ncreate_constant_bond_field(\"density\", Float64, 1)  # creates a density constant bond field\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.create_constant_element_field","page":"Data Manager","title":"PeriLab.Data_manager.create_constant_element_field","text":"create_constant_element_field(name::String, type::Type, dof::Int64)\n\nCreates a constant element field with the given name, data type, and degree of freedom.\n\nArguments\n\nname::String: The name of the element field.\nvartype::Type: The data type of the element field.\ndof::Int64: The degrees of freedom per element.\nVectorOrArray::String (optional) - Vector or Materix; Default is vector\n\nReturns\n\nconstant_element_field::Field: The created constant element field.\n\nExample:\n\ncreate_constant_element_field(\"temperature\", Float64, 1)  # creates a temperature constant element field\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.create_constant_node_field","page":"Data Manager","title":"PeriLab.Data_manager.create_constant_node_field","text":"create_constant_node_field(name::String, type::Type, dof::Int64)\n\nCreates a constant node field with the given name, data type, and degree of freedom.\n\nArguments\n\nname::String: The name of the node field.\nvartype::Type: The data type of the node field.\ndof::Int64: The degrees of freedom per node.\nVectorOrArray::String (optional) - Vector or Materix; Default is vector\n\nReturns\n\nconstant_node_field::Field: The created constant node field.\n\nExample:\n\ncreate_constant_node_field(\"temperature\", Float64, 1)  # creates a temperature constant node field\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.create_field","page":"Data Manager","title":"PeriLab.Data_manager.create_field","text":"create_field(name::String, vartype::Type, bondNode::String, dof::Int64, default_value::Any=0)\n\nCreate a field with the given name for the specified vartype. If the field already exists, return the existing field. If the field does not exist, create a new field with the specified characteristics.\n\nArguments\n\nname::String: The name of the field.\nvartype::Type: The data type of the field.\ndof::Int64: The degrees of freedom per node.\ndefault_value::Any: The default value of the field.\n\nReturns\n\nThe field with the given name and specified characteristics.\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.create_node_field","page":"Data Manager","title":"PeriLab.Data_manager.create_node_field","text":"create_node_field(name::String, type::Type, dof::Int64)\n\nCreates a node field with the given name, data type, and degree of freedom.\n\nArguments\n\nname::String: The name of the node field.\ntype::Type: The data type of the node field.\ndof::Int64: The degree of freedom of each node.\nVectorOrArray::String (optional) - Vector or Materix; Default is vector\n\nReturns\n\nnode_field::Field: The created node field for the current time step.\nnode_field_np1::Field: The created node field for the next time step.\n\nExample:\n\ncreate_node_field(\"displacement\", Float64, 3)  # creates a displacement node field with 3 degrees of freedom\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.fem_active-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.fem_active","text":"fem_active()\n\nReturns if FEM is active (true) or not (false).\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_accuracy_order-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_accuracy_order","text":"get_accuracy_order()\n\nReturns the accuracy order for the \"bond associated correspondence\" implementation.\n\nArguments\n\nvalue::Int64: The value of the accuracy_order.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_active_models","page":"Data Manager","title":"PeriLab.Data_manager.get_active_models","text":"get_active_models()\n\nReturns a list active model modules.\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_all_blocks-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_all_blocks","text":"get_all_blocks()\n\nGives back a global list of all block, initially. Is reduced to the outer (not free) surfaces of the contact blocks.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_all_field_keys-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_all_field_keys","text":"get_all_field_keys()\n\nReturns a list of all field keys.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_all_positions-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_all_positions","text":"get_all_positions()\n\nGives back a global list of current positions, initially. Is reduced to the outer (not free) surfaces of the contact blocks.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_aniso_crit_values-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_aniso_crit_values","text":"get_aniso_crit_values()\n\nRetrieves the critical values matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_bc_free_dof-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_bc_free_dof","text":"get_bc_free_dof()\n\nGet all dof without displacment boundary conditions.\n\nReturns\n\nVector{Tuple{Int64, Int64}}: The point and dof without boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_block_id_list-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_block_id_list","text":"get_block_id_list()\n\nReturns a list of all block IDs.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_block_name_list-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_block_name_list","text":"get_block_name_list()\n\nReturns a list of all block IDs.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_bond_damage-Tuple{String}","page":"Data Manager","title":"PeriLab.Data_manager.get_bond_damage","text":"get_bond_damage(time::String)\n\nGet the bond damage\n\nArguments\n\ntime::String: The time of the field.\n\nReturns\n\ndamage::Field: The bond damage field.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_cancel-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_cancel","text":"get_cancel()\n\nThis function returns the cancel flag.\n\nReturns\n\ncancel::Bool: The value of the cancel variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_comm-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_comm","text":"get_comm()\n\nGet the MPI communicator\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_contact_overlap_map-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_contact_overlap_map","text":"get_contact_overlap_map()\n\nGet the contact overlap map\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_coupling_dict-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_coupling_dict","text":"get_coupling_dict()\n\nGet the PD - FE coupling dict\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_coupling_fe_nodes-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_coupling_fe_nodes","text":"get_coupling_fe_nodes()\n\nGet the FE nodes involved in the coupling\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_crit_values_matrix-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_crit_values_matrix","text":"get_crit_values_matrix()\n\nRetrieves the critical values matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_current_time-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_current_time","text":"get_current_time()\n\nGet the current time of the simulation.\n\nReturns\n\nFloat64: The current time of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_damage-Tuple{String}","page":"Data Manager","title":"PeriLab.Data_manager.get_damage","text":"get_damage(time::String)\n\nGet the damage\n\nArguments\n\ntime::String: The time of the field.\n\nReturns\n\ndamage::Field: The damage field.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_dof-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_dof","text":"get_dof()\n\nRetrieves the degree of freedom (dof) value.\n\nReturns\n\ndof (integer): The current degree of freedom value.\n\nExample:\n\nget_dof()  # returns the current degree of freedom\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_element_rotation-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_element_rotation","text":"get_element_rotation()\n\nThis function returns the element_rotation flag.\n\nReturns\n\nelement_rotation::Bool: The value of the element_rotation variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_field","page":"Data Manager","title":"PeriLab.Data_manager.get_field","text":"get_field(name::String, time::String)\n\nReturns the field with the given name and time.\n\nArguments\n\nname::String: The name of the field.\ntime::String: The time of the field.\n\nReturns\n\nfield::Field: The field with the given name and time.\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_field_if_exists","page":"Data Manager","title":"PeriLab.Data_manager.get_field_if_exists","text":"get_field_if_exists(name::String, time::String)\n\nReturns the field with the given name if it exists.\n\nArguments\n\nname::String: The name of the field.\ntime::String: The time of the field.\n\nReturns\n\nfield::Field: The field with the given name and time.\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_field_type-Tuple{String}","page":"Data Manager","title":"PeriLab.Data_manager.get_field_type","text":"get_field_type()\n\nGet the type of a field\n\nReturns\n\nget_field_type (string): returns the type of a field\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_filtered_nlist-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_filtered_nlist","text":"get_filtered_nlist()\n\nGet the neighborhood list.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_inverse_nlist-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_inverse_nlist","text":"get_inverse_nlist()\n\nGet the inverse of the neighborhood list.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_iteration-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_iteration","text":"get_step()\n\nGet the iteration of the simulation.\n\nReturns\n\nInt64: The iteration of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_local_nodes-Tuple{Any}","page":"Data Manager","title":"PeriLab.Data_manager.get_local_nodes","text":"get_local_nodes()\n\nDetermines the local node numbering.\n\nReturns\n\nget_local_nodes (array): returns local nodes.\n\nExample:\n\nget_local_nodes()  # returns local nodes or if they do not exist at the core an empty array\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_local_synch_fields-Tuple{String}","page":"Data Manager","title":"PeriLab.Data_manager.get_local_synch_fields","text":"get_local_synch_fields(model::String)\n\nmodel - class of models; before computation of these models the synchronisation occurs\nGet the fields to synchronize\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_max_rank-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_max_rank","text":"get_max_rank()\n\nThis function returns the maximal rank of MPI the max_rank.\n\nReturns\n\nmax_rank::Number: The value of the max_rank variable.\n\nExample\n\n```julia rank = getmaxrank()\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_max_step-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_max_step","text":"get_max_step()\n\nGet the max_step of the simulation.\n\nReturns\n\nInt64: The max_step of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_nlist-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_nlist","text":"get_nlist()\n\nGet the neighborhood list.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_nnodes-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_nnodes","text":"get_nnodes()\n\nRetrieves the number of nodes.\n\nReturns\n\nnum_controller::Int64 : The current number of nodes.\n\nExample:\n\nget_nnodes()  # returns the current number of controler nodes. The neighbors are not included\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_nnsets-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_nnsets","text":"get_nnsets()\n\nGet the number of node sets.\n\nReturns\n\nnnsets::Int: The number of node sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_nsets-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_nsets","text":"get_nsets()\n\nGet the node sets\n\nReturns\n\nnsets::Dict{String,Vector{Int64}}: The node sets dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_num_elements-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_num_elements","text":"get_num_elements()\n\nGet the the number of finite elements\n\nReturns\n\nget_num_elements::Int64: The number of finite elements\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_num_responder-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_num_responder","text":"get_num_responder()\n\nGet the the number of responder nodes\n\nReturns\n\nnum_responder::Int64: The number of responder nodes\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_output_frequency-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_output_frequency","text":"get_output_frequency()\n\nThis function returns the output_frequency variable.\n\nReturns\n\noutput_frequency::Any: The value of the output_frequency variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_overlap_map-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_overlap_map","text":"get_overlap_map()\n\nGet the overlap map\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_pre_calculation_order-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_pre_calculation_order","text":"get_pre_calculation_order()\n\nreturn the order of the pre calculation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_properties-Tuple{Int64, String}","page":"Data Manager","title":"PeriLab.Data_manager.get_properties","text":"get_properties(block_id::Int64, property::String)\n\nThis function retrieves the value of a specified property for a given block_id if it exists in the properties dictionary.\n\nArguments\n\nblock_id::Int64: The identifier of the block for which to retrieve the property.\nproperty::String: The dictionary entrycontaining the properties for the blocks.\n\nReturns\n\nproperty_value::Any: The value associated with the specified property for the given block_id.\nDict(): An empty dictionary if the specified property does not exist for the given block_id.\n\nExample\n\n```julia block_properties = Dict(     1 => Dict(\"color\" => \"red\", \"size\" => 10),     2 => Dict(\"color\" => \"blue\", \"height\" => 20) )\n\nRetrieve the 'color' property for block 1\n\ncolorvalue = getproperties(1, \"color\")  # Returns \"red\"\n\nTry to retrieve a non-existent property for block 2\n\nnonexistentvalue = get_properties(2, \"width\")  # Returns an empty dictionary\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_property-Tuple{Int64, String, String}","page":"Data Manager","title":"PeriLab.Data_manager.get_property","text":"get_property(block_id::Int64, property::String, value_name::String)\n\nThis function retrieves a specific value_name associated with a specified property for a given block_id if it exists in the properties dictionary.\n\nArguments\n\nblock_id::Int64: The identifier of the block for which to retrieve the property.\nproperty::String: The String property type (e.g. Material model) for the blocks.\nvalue_name::String: The name of the value within the specified property.\n\nReturns\n\nvalue::Any: The value associated with the specified value_name within the property for the given block_id.\nnothing: If the specified block_id, property, or value_name does not exist in the dictionary.\n\nExample\n\n```julia\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_rank-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_rank","text":"get_rank()\n\nThis function returns the rank of the core.\n\nReturns\n\nrank::Any: The value of the rank variable.\n\nExample\n\n```julia currentrank = getrank()\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_rotation-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_rotation","text":"get_rotation()\n\nThis function returns the rotation flag.\n\nReturns\n\nrotation::Bool: The value of the rotation variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_silent-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_silent","text":"get_silent()\n\nThis function returns the silent flag.\n\nReturns\n\nsilent::Bool: The value of the silent variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_step-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_step","text":"get_step()\n\nGet the step of the simulation.\n\nReturns\n\nInt64: The step of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_synch_fields-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_synch_fields","text":"get_synch_fields()\n\nGet the fields to synchronize\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.get_verbose-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.get_verbose","text":"get_verbose()\n\nThis function returns the verbose flag.\n\nReturns\n\nverbose::Bool: The value of the verbose variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.has_key-Tuple{String}","page":"Data Manager","title":"PeriLab.Data_manager.has_key","text":"has_key(field_name::String)\n\nControl if a key exists.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.init_properties-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.init_properties","text":"init_properties()\n\nThis function initializes the properties dictionary. Order of dictionary defines, in which order the models are called later on.\n\nReturns\n\nkeys(properties[1]): The keys of the properties dictionary in defined order for the Model_Factory.jl.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.initialize_data-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.initialize_data","text":"initialize_data()\n\nInitialize all parameter in the datamanager and sets them to the default values.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.loc_to_glob-Tuple{Union{UnitRange{Int64}, Vector{Int64}}}","page":"Data Manager","title":"PeriLab.Data_manager.loc_to_glob","text":"loc_to_glob(range::UnitRange{Int64})\n\nConverts the local index to the global index.\n\nArguments\n\nrange::Union{UnitRange{Int64}, Vector{Int64}}: The range of the local index.\n\nExample:\n\nloc_to_glob(1:10)  # converts the local index to the global index\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.remove_active_model-Tuple{String}","page":"Data Manager","title":"PeriLab.Data_manager.remove_active_model","text":"remove_active_model(module_name::Module)\n\nRemoves main modules from OrderedDict.\n\nArguments\n\nkey::String: Key of the entry.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_NP1_to_N-Tuple{String, Type}","page":"Data Manager","title":"PeriLab.Data_manager.set_NP1_to_N","text":"set_NP1_to_N(name::String, type::Type)\n\nSets the NP1toN dataset\n\nArguments\n\nname::String: The name of the field.\ntype::Type The field type\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_accuracy_order-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_manager.set_accuracy_order","text":"set_accuracy_order(value::Int64)\n\nSets the accuracy order for the \"bond associated correspondence\" implementation.\n\nArguments\n\nvalue::Int64: The value of the accuracy_order.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_aniso_crit_values-Tuple{Dict{Int64, Any}}","page":"Data Manager","title":"PeriLab.Data_manager.set_aniso_crit_values","text":"setanisocritvalues(critvalues::Dict{Int64,Any})\n\nSets the anisotropic critical values globally.\n\nArguments\n\ncrit_values::Dict{Int64,Any}: The critical values.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_bc_free_dof-Tuple{Vector{Int64}}","page":"Data Manager","title":"PeriLab.Data_manager.set_bc_free_dof","text":"set_bc_free_dof(values::Vector{Tuple{Int64, Int64}})\n\nSet all dof without displacment boundary conditions.\n\nReturns\n\n\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_block_id_list-Tuple{Vector{Int64}}","page":"Data Manager","title":"PeriLab.Data_manager.set_block_id_list","text":"set_block_id_list(blocks_id_list::Vector{Int64})\n\nSets the block list globally.\n\nArguments\n\nblocks_id_list::Vector{Int64}: The block list.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_block_name_list-Tuple{Vector{String}}","page":"Data Manager","title":"PeriLab.Data_manager.set_block_name_list","text":"set_block_name_list(blocks_name_list::Vector{String})\n\nSets the block list globally.\n\nArguments\n\nblocks_name_list::Vector{String}: The block list.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_cancel-Tuple{Bool}","page":"Data Manager","title":"PeriLab.Data_manager.set_cancel","text":"set_cancel(value::Int64)\n\nSets the cancel flag.\n\nArguments\n\nvalue::Bool: The cancel flag.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_comm-Tuple{MPI.Comm}","page":"Data Manager","title":"PeriLab.Data_manager.set_comm","text":"set_comm(comm::MPI.Comm)\n\nSet the MPI communicator\n\nArguments\n\ncomm::MPI.Comm: MPI communicator\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_contact_overlap_map-Tuple{Any}","page":"Data Manager","title":"PeriLab.Data_manager.set_contact_overlap_map","text":"set_contact_overlap_map(topo)\n\nSets the contact overlap map globally.\n\nArguments\n\ntopo: The overlap map.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_coupling_dict-Tuple{Dict{Int64, Int64}}","page":"Data Manager","title":"PeriLab.Data_manager.set_coupling_dict","text":"set_coupling_dict(coupling_dict::Dict{Int64,Int64})\n\nSets the FE - PD couplings. PD nodes -> FE Elements.\n\nArguments\n\ncoupling_dict::Dict{Int64,Int64}: The coupling dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_coupling_fe_nodes-Tuple{Vector{Int64}}","page":"Data Manager","title":"PeriLab.Data_manager.set_coupling_fe_nodes","text":"set_coupling_fe_nodes()\n\nGet the FE nodes involved in the coupling\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_crit_values_matrix-Tuple{Array{Float64, 3}}","page":"Data Manager","title":"PeriLab.Data_manager.set_crit_values_matrix","text":"set_crit_values_matrix(crit_values::Array{Float64,3})\n\nSets the critical values matrix globally.\n\nArguments\n\ncrit_values::Array{Float64,3}: The critical values matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_current_time-Tuple{Union{Nothing, Float64}}","page":"Data Manager","title":"PeriLab.Data_manager.set_current_time","text":"set_current_time(time::Float64)\n\nSet the current time of the simulation.\n\nArguments\n\ntime::Float64: The current time of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_distribution-Tuple{Vector{Int64}}","page":"Data Manager","title":"PeriLab.Data_manager.set_distribution","text":"set_distribution(values::Vector{Int64})\n\nSets the distribution globally.\n\nArguments\n\nvalues::Vector{Int64}: The distribution.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_dof-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_manager.set_dof","text":"set_dof(n::Int64)\n\nSets the degree of freedom (dof) value globally.\n\nArguments\n\nn::Int64: The value to set as the degree of freedom.\n\nExample:\n\nset_dof(3)  # sets the degree of freedom to 3\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_element_rotation-Tuple{Bool}","page":"Data Manager","title":"PeriLab.Data_manager.set_element_rotation","text":"set_element_rotation(value::Int64)\n\nSets the element_rotation flag.\n\nArguments\n\nvalue::Bool: The element_rotation flag.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_fem-Tuple{Bool}","page":"Data Manager","title":"PeriLab.Data_manager.set_fem","text":"set_fem(value::Bool)\n\nActivates and deactivates the FEM option in PeriLab\n\nArguments\n\nvalue::Bool: The value to set FEM active (true) or not (false).\n\nExample:\n\nset_fem(true)  # sets the fem_option to true\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_glob_to_loc-Tuple{Dict}","page":"Data Manager","title":"PeriLab.Data_manager.set_glob_to_loc","text":"set_glob_to_loc(dict)\n\nSets the global-to-local mapping dict globally.\n\nArguments\n\ndict (array): The dict representing the global-to-local mapping.\n\nExample:\n\nset_glob_to_loc([1, 3, 5])  # sets the global-to-local mapping dict\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_inverse_nlist-Tuple{Vector{Dict{Int64, Int64}}}","page":"Data Manager","title":"PeriLab.Data_manager.set_inverse_nlist","text":"set_inverse_nlist(inv_nlist::Vector{Dict{Int64,Int64}})\n\nSets the inverse nlist globally.\n\nArguments\n\ninv_nlist::Vector{Dict{Int64,Int64}}: The inverse nlist.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_iteration-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_manager.set_iteration","text":"set_iteration(iteration::Int64)\n\nSet the iteration of the simulation.\n\nArguments\n\niteration::Int64: The iteration of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_local_synch","page":"Data Manager","title":"PeriLab.Data_manager.set_local_synch","text":"set_local_synch(model, name, download_from_cores, upload_to_cores, dof=0)\n\nSets the synchronization dictionary locally during the model update process. Should be used carefully, to avoid unessary communication.\n\nArguments\n\nname::String: The name of the field.\ndownload_from_cores::Bool: Whether to download the field from the cores.\nupload_to_cores::Bool: Whether to upload the field to the cores.\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_max_rank-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_manager.set_max_rank","text":"set_max_rank(value::Int64)\n\nSets the maximum rank globally.\n\nArguments\n\nvalue::Int64: The value to set as the maximum rank.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_max_step-Tuple{Union{Nothing, Int64}}","page":"Data Manager","title":"PeriLab.Data_manager.set_max_step","text":"set_max_step(max_step::Int64)\n\nSet the max_step of the simulation.\n\nArguments\n\nmax_step::Int64: The max_step of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_nnodes-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.set_nnodes","text":"set_nnodes()\n\nSets the number all nodes of one core globally.\n\nArguments\n\nExample: ```\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_nnsets-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_manager.set_nnsets","text":"set_nnsets(n::Int64)\n\nSet the number of node sets.\n\nArguments\n\nn::Int64: The number of node sets to be set.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_nset-Tuple{String, Vector{Int64}}","page":"Data Manager","title":"PeriLab.Data_manager.set_nset","text":"set_nset(name, nodes)\n\nSet the nodes associated with a named node set.\n\nArguments\n\nname::String: The name of the node set.\nnodes::Vector{Int}: The node indices associated with the node set.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_num_controller-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_manager.set_num_controller","text":"set_num_controller(n::Int64)\n\nSets the number of controller nodes globally. For one core the number of nodes is equal to the number of controller nodes.\n\nArguments\n\nn::Int64: The value to set as the number of nodes.\n\nExample:\n\nset_num_controller(10)  # sets the number of nodes to 10\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_num_responder-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_manager.set_num_responder","text":"set_num_responder(n::Int64)\n\nSets the number of responder nodes globally. For one core the number of responder is zero. responder hold the information of the neighbors, of one node, but are not evaluated.\n\nArguments\n\nn::Int64: The value to set as the number of nodes.\n\nExample:\n\nset_num_responder(10)  # sets the number of responder nodes to 10\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_output_frequency-Tuple{Any}","page":"Data Manager","title":"PeriLab.Data_manager.set_output_frequency","text":"set_output_frequency(value)\n\nSets the output frequency globally.\n\nArguments\n\nvalue: The value to set as the output frequency.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_overlap_map-Tuple{Any}","page":"Data Manager","title":"PeriLab.Data_manager.set_overlap_map","text":"set_overlap_map(topo)\n\nSets the overlap map globally.\n\nArguments\n\ntopo: The overlap map.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_pre_calculation_order-Tuple{Vector{String}}","page":"Data Manager","title":"PeriLab.Data_manager.set_pre_calculation_order","text":"set_pre_calculation_order(values::Vector{String})\n\nSets the order of the pre calculation options globally.\n\nArguments\n\nvalues::Vector{String}: The order of models.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_properties-Tuple{Any, Any, Any}","page":"Data Manager","title":"PeriLab.Data_manager.set_properties","text":"set_properties(block_id, property, values)\n\nSets the values of a specified property for a given block_id.\n\nArguments\n\nblock_id::Int64: The identifier of the block for which to set the property.\nproperty::String: The name of the property.\nvalues::Any: The values to set for the specified property.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_properties-Tuple{Any, Any}","page":"Data Manager","title":"PeriLab.Data_manager.set_properties","text":"set_properties(property, values)\n\nSets the values of a specified property for a all blocks. E.g. for FEM, because it corresponds not to a block yet,\n\nArguments\n\nproperty::String: The name of the property.\nvalues::Any: The values to set for the specified property.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_property-Tuple{Int64, String, String, Any}","page":"Data Manager","title":"PeriLab.Data_manager.set_property","text":"set_property(block_id, property, value_name, value)\n\nSets the value of a specified property for a given block_id.\n\nArguments\n\nblock_id::Int64: The identifier of the block for which to set the property.\nproperty::String: The name of the property.\nvalue_name::String: The name of the value within the specified property.\nvalue::Any: The value to set for the specified value_name.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_rank-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_manager.set_rank","text":"set_rank(value::Int64)\n\nSets the rank globally.\n\nArguments\n\nvalue::Int64: The value to set as the rank.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_rotation-Tuple{Bool}","page":"Data Manager","title":"PeriLab.Data_manager.set_rotation","text":"set_rotation(value::Int64)\n\nSets the rotation flag.\n\nArguments\n\nvalue::Bool: The rotation flag.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_silent-Tuple{Bool}","page":"Data Manager","title":"PeriLab.Data_manager.set_silent","text":"set_silent(value::Bool)\n\nSets the silent flag.\n\nArguments\n\nvalue::Bool: The silent flag.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_step-Tuple{Union{Nothing, Int64}}","page":"Data Manager","title":"PeriLab.Data_manager.set_step","text":"set_step(step::Int64)\n\nSet the step of the simulation.\n\nArguments\n\nstep::Int64: The step of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_synch","page":"Data Manager","title":"PeriLab.Data_manager.set_synch","text":"set_synch(name, download_from_cores, upload_to_cores)\n\nSets the synchronization dictionary globally.\n\nArguments\n\nname::String: The name of the field.\ndownload_from_cores::Bool: Whether to download the field from the cores.\nupload_to_cores::Bool: Whether to upload the field to the cores.\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.set_verbose-Tuple{Bool}","page":"Data Manager","title":"PeriLab.Data_manager.set_verbose","text":"set_verbose(value::Bool)\n\nSets the verbose flag.\n\nArguments\n\nvalue::Bool: The verbose flag.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.switch_NP1_to_N-Tuple{}","page":"Data Manager","title":"PeriLab.Data_manager.switch_NP1_to_N","text":"switch_NP1_to_N()\n\nSwitches the fields from NP1 to N.active\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_manager.synch_manager-Tuple{Any, String}","page":"Data Manager","title":"PeriLab.Data_manager.synch_manager","text":"synch_manager(synchronise_field, direction::String)\n\nSynchronises the fields.\n\nArguments\n\nsynchronise_field: The function to synchronise the field.\ndirection::String: The direction of the synchronisation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/","page":"Data Manager","title":"Data Manager","text":"","category":"page"},{"location":"lib/model_factory_functions/#Model-Factory-Functions","page":"Model Factory","title":"Model Factory - Functions","text":"","category":"section"},{"location":"lib/model_factory_functions/#Index","page":"Model Factory","title":"Index","text":"","category":"section"},{"location":"lib/model_factory_functions/","page":"Model Factory","title":"Model Factory","text":"Pages = [\"model_factory_functions.md\"]","category":"page"},{"location":"lib/model_factory_functions/#Models","page":"Model Factory","title":"Models","text":"","category":"section"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.add_model","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.add_model","text":"add_model(datamanager::Module, model_name::String)\n\nIncludes the models in the datamanager and checks if the model definition is correct or not.\n\nArguments\n\ndatamanager::Module: Datamanager\nmodel_name::String: The block nodes\n\nReturns\n\ndatamanager::Module: Datamanager\n\n\n\n\n\n","category":"function"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.compute_models-Tuple{Module, Dict{Int64, Vector{Int64}}, Float64, Float64, Vector{String}, Any, TimerOutputs.TimerOutput}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.compute_models","text":"compute_models(datamanager::Module, block_nodes::Dict{Int64,Vector{Int64}}, dt::Float64, time::Float64, options::Vector{String}, synchronise_field, to::TimerOutput)\n\nComputes the models models\n\nArguments\n\ndatamanager::Module: The datamanager\nblock_nodes::Dict{Int64,Vector{Int64}}: The block nodes\ndt::Float64: The time step\ntime::Float64: The current time of the solver\noptions::Vector{String}: The options\nsynchronise_field: The synchronise field\nto::TimerOutput: The timer output\n\nReturns\n\ndatamanager: The datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.get_block_model_definition","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.get_block_model_definition","text":"get_block_model_definition(params::Dict, block_id_list::Int64, prop_keys::Vector{String}, properties)\n\nGet block model definition.\n\nSpecial case for pre calculation. It is set to all blocks, if no block definition is defined, but pre calculation is.\n\nArguments\n\nparams::Dict: Parameters.\nblock_id_list::Vector{Int64}: List of block id's.\nprop_keys::Vector{String}: Property keys.\nproperties: Properties function.\n\nReturns\n\nproperties: Properties function.\n\n\n\n\n\n","category":"function"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.init_models-Tuple{Dict, Module, Dict{Int64, Vector{Int64}}, Dict, Any, TimerOutputs.TimerOutput}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.init_models","text":"init_models(params::Dict, datamanager::Module, block_nodes::Dict{Int64,Vector{Int64}}, solver_options::Dict)\n\nInitialize models\n\nArguments\n\nparams::Dict: Parameters.\ndatamanager::Module: Datamanager.\nblock_nodes::Dict{Int64,Vector{Int64}}: block nodes.\nsolver_options::Dict: Solver options.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.read_properties-Tuple{Dict, Module, Bool}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.read_properties","text":"read_properties(params::Dict, datamanager::Module, material_model::Bool)\n\nRead properties of material.\n\nArguments\n\nparams::Dict: Parameters.\ndatamanager::Data_manager: Datamanager.\nmaterial_model::Bool: Material model.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.set_heat_capacity-Tuple{Dict, Dict, Vector{Float64}}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.set_heat_capacity","text":"set_heat_capacity(params::Dict, block_nodes::Dict, heat_capacity::Vector{Float64})\n\nSets the heat capacity of the nodes in the dictionary.\n\nArguments\n\nparams::Dict: The parameters\nblock_nodes::Dict: The block nodes\nheat_capacity::Vector{Float64}: The heat capacity array\n\nReturns\n\nheat_capacity::SubArray: The heat capacity array\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#Additive","page":"Model Factory","title":"Additive","text":"","category":"section"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Additive.compute_model-Tuple{Module, AbstractVector{Int64}, Dict, Int64, Float64, Float64, TimerOutputs.TimerOutput}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Additive.compute_model","text":"compute_model(datamanager::Module, nodes::AbstractVector{Int64}, model_param::Dict, block::Int64, time::Float64, dt::Float64,to::TimerOutput,)\n\nComputes the addtive models\n\nArguments\n\ndatamanager::Module: The datamanager\nnodes::AbstractVector{Int64}: The nodes\nmodel_param::Dict: The model parameters\nblock::Int64: The block\ntime::Float64: The current time\ndt::Float64: The time step\n\nReturns\n\ndatamanager::Module: The datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Additive.fields_for_local_synchronization-Tuple{Any, Any, Any}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Additive.fields_for_local_synchronization","text":"fields_for_local_synchronization(datamanager, model, block)\n\nDefines all synchronization fields for local synchronization\n\nArguments\n\ndatamanager::Module: datamanager.\nmodel::String: Model class.\nblock::Int64: block ID\n\nReturns\n\ndatamanager::Module: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Additive.init_fields-Tuple{Module}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Additive.init_fields","text":"init_fields(datamanager::Module)\n\nInitialize additive model fields\n\nArguments\n\ndatamanager::Data_manager: Datamanager.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Additive.init_model-Tuple{Module, AbstractVector{Int64}, Int64}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Additive.init_model","text":"init_model(datamanager::Module, nodes::AbstractVector{Int64}, block::Int64)\n\nInitialize the additive models.\n\nArguments\n\ndatamanager::Module: The data manager module where the additive model will be initialized.\nnodes::AbstractVector{Int64}: Nodes for the additive model.\nblock::Int64: Block identifier for the additive model.\n\nReturns\n\ndatamanager: The modified data manager module with the initialized additive model.\n\nExample\n\n```julia datamanager = initmodel(mydata_manager, [1, 2, 3], 1)\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#Damage","page":"Model Factory","title":"Damage","text":"","category":"section"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Damage.compute_model-Tuple{Module, AbstractVector{Int64}, Dict, Int64, Float64, Float64, TimerOutputs.TimerOutput}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Damage.compute_model","text":"compute_model(datamanager::Module, nodes::AbstractVector{Int64}, model_param::Dict, block::Int64, time::Float64, dt::Float64,to::TimerOutput,)\n\nComputes the damage model\n\nArguments\n\ndatamanager::Module: The datamanager\nnodes::AbstractVector{Int64}: The nodes\nmodel_param::Dict: The model parameters\nblock::Int64: The block\ntime::Float64: The current time\ndt::Float64: The time step\n\nReturns\n\ndatamanager::Module: The datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Damage.damage_index-Tuple{Module, AbstractVector{Int64}, Vector{Vector{Int64}}}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Damage.damage_index","text":"damage_index(datamanager,::Union{SubArray, Vector{Int64})\n\nFunction calculates the damage index related to the neighborhood volume for a set of corresponding nodes. The damage index is defined as damaged volume in relation the neighborhood volume. damageIndex = sumi (brokenBondsi * volume_i) / volumeNeighborhood\n\nArguments\n\ndatamanager::Data_manager: all model data\nnodes::Union{SubArray, Vector{Int64}}: corresponding nodes to this model\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Damage.fields_for_local_synchronization-Tuple{Any, Any, Any}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Damage.fields_for_local_synchronization","text":"fields_for_local_synchronization(datamanager, model, block)\n\nDefines all synchronization fields for local synchronization\n\nArguments\n\ndatamanager::Module: datamanager.\nmodel::String: Model class.\nblock::Int64: block ID\n\nReturns\n\ndatamanager::Module: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Damage.init_aniso_crit_values-Tuple{Module, Dict, Int64}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Damage.init_aniso_crit_values","text":"init_aniso_crit_values(datamanager::Module, params::Dict, block_id::Int64)\n\nInitialize the anisotropic critical values\n\nArguments\n\ndatamanager::Module: The datamanager\nparams::Dict: The parameters\nblock_id::Int64: current block\n\nReturns\n\ndatamanager::Module: The datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Damage.init_fields-Tuple{Module}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Damage.init_fields","text":"init_fields(datamanager::Module)\n\nInitialize damage model fields\n\nArguments\n\ndatamanager::Data_manager: Datamanager.\nparams::Dict: Parameters.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Damage.init_interface_crit_values-Tuple{Module, Dict, Int64}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Damage.init_interface_crit_values","text":"init_interface_crit_values(datamanager::Module, params::Dict, block_id::Int64)\n\nInitialize the critical values\n\nArguments\n\ndatamanager::Module: The datamanager\nparams::Dict: The parameters\nblock_id::Int64: current block\n\nReturns\n\ndatamanager::Module: The datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Damage.init_model-Tuple{Module, AbstractVector{Int64}, Int64}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Damage.init_model","text":"init_model(datamanager::Module, nodes::AbstractVector{Int64}, block::Int64)\n\nInitialize the damage models.\n\nArguments\n\ndatamanager::Module: The data manager module where the degradation model will be initialized.\nnodes::AbstractVector{Int64}: Nodes for the degradation model.\nblock::Int64: Block identifier for the degradation model.\n\nReturns\n\ndatamanager: The modified data manager module with the initialized degradation model.\n\nExample\n\n```julia datamanager = initmodel(mydata_manager, [1, 2, 3], 1)\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#Material","page":"Model Factory","title":"Material","text":"","category":"section"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Material.check_material_symmetry-Tuple{Int64, Dict}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Material.check_material_symmetry","text":"check_material_symmetry(dof::Int64, prop::Dict)\n\nCheck the symmetry of the material.\n\nArguments\n\ndof::Int64: The degree of freedom.\nprop::Dict: The material property.\n\nReturns\n\nprop::Dict: The material property.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Material.compute_model-Tuple{Module, AbstractVector{Int64}, Dict, Int64, Float64, Float64, TimerOutputs.TimerOutput}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Material.compute_model","text":"compute_model(datamanager::Module, nodes::AbstractVector{Int64}, model_param::Dict, block::Int64, time::Float64, dt::Float64,to::TimerOutput,)\n\nComputes the material models\n\nArguments\n\ndatamanager::Module: The datamanager\nnodes::AbstractVector{Int64}: The nodes\nmodel_param::Dict: The model parameters\nblock::Int64: The block\ntime::Float64: The current time\ndt::Float64: The time step\n\nReturns\n\ndatamanager::Module: The datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Material.determine_isotropic_parameter-Tuple{Module, Dict}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Material.determine_isotropic_parameter","text":"determine_isotropic_parameter(datamanager::Module, prop::Dict)\n\nDetermine the isotropic parameter.\n\nArguments\n\nprop::Dict: The material property.\n\nReturns\n\nprop::Dict: The material property.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Material.distribute_force_densities-Union{Tuple{T}, Tuple{T, AbstractVector{Int64}}} where T","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Material.distribute_force_densities","text":"distribute_force_densities(datamanager::Module, nodes::AbstractVector{Int64})\n\nDistribute the force densities.\n\nArguments\n\ndatamanager::Data_manager: Datamanager.\nnodes::AbstractVector{Int64}: The nodes.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Material.fields_for_local_synchronization-Tuple{Any, Any, Any}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Material.fields_for_local_synchronization","text":"fields_for_local_synchronization(datamanager, model, block)\n\nDefines all synchronization fields for local synchronization\n\nArguments\n\ndatamanager::Module: datamanager.\nmodel::String: Model class.\nblock::Int64: block ID\n\nReturns\n\ndatamanager::Module: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Material.init_fields-Tuple{Module}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Material.init_fields","text":"init_fields(datamanager::Module)\n\nInitialize material model fields\n\nArguments\n\ndatamanager::Data_manager: Datamanager.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Material.init_model-Tuple{Module, AbstractVector{Int64}, Int64}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Material.init_model","text":"init_model(datamanager::Module, nodes::Union{SubArray,Vector{Int64}, block::Int64)\n\nInitializes the material model.\n\nArguments\n\ndatamanager::Data_manager: Datamanager\nnodes::AbstractVector{Int64}: The nodes.\nblock::Int64: Block.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#Thermal","page":"Model Factory","title":"Thermal","text":"","category":"section"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Thermal.compute_model-Tuple{Module, AbstractVector{Int64}, Dict, Int64, Float64, Float64, TimerOutputs.TimerOutput}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Thermal.compute_model","text":"compute_model(datamanager::Module, nodes::AbstractVector{Int64}, model_param::Dict, block::Int64, time::Float64, dt::Float64,to::TimerOutput,)\n\nComputes the thermal models\n\nArguments\n\ndatamanager::Module: The datamanager\nnodes::AbstractVector{Int64}: The nodes\nmodel_param::Dict: The model parameters\nblock::Int64: The block\ntime::Float64: The current time\ndt::Float64: The time step\n\nReturns\n\ndatamanager::Module: The datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Thermal.init_fields-Tuple{Module}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Thermal.init_fields","text":"init_fields(datamanager::Module)\n\nInitialize thermal model fields\n\nArguments\n\ndatamanager::Data_manager: Datamanager.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Thermal.init_model-Tuple{Module, AbstractVector{Int64}, Int64}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Thermal.init_model","text":"init_model(datamanager::Module, nodes::Union{SubArray,Vector{Int64}, block::Int64)\n\nInitializes the thermal model.\n\nArguments\n\ndatamanager::Data_manager: Datamanager\nnodes::AbstractVector{Int64}: The nodes.\nblock::Int64: Block.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#Pre_Calculation","page":"Model Factory","title":"Pre_Calculation","text":"","category":"section"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Pre_Calculation.check_dependencies-Tuple{Module, Dict{Int64, Vector{Int64}}}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Pre_Calculation.check_dependencies","text":"check_dependencies(datamanager::Module, block_nodes::Dict{Int64,Vector{Int64}}\n\nCheck if materials are used which needs a form of pre calculation. If so, the option will be set.\n\nArguments\n\ndatamanager::Module: Datamanager.\nblock_nodes::Dict{Int64,Vector{Int64}}: block nodes.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Pre_Calculation.compute_model-Tuple{Module, AbstractVector{Int64}, Union{Dict, OrderedCollections.OrderedDict}, Int64, Float64, Float64, TimerOutputs.TimerOutput}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Pre_Calculation.compute_model","text":"compute_model(datamanager::Module, nodes::AbstractVector{Int64}, model_param::Dict, block::Int64, time::Float64, dt::Float64,to::TimerOutput,)\n\nComputes the pre calculation models\n\nArguments\n\ndatamanager::Module: The datamanager\nnodes::AbstractVector{Int64}: The nodes\nmodel_param::Dict: The model parameters\nblock::Int64: The block\ntime::Float64: The current time\ndt::Float64: The time step\n\nReturns\n\ndatamanager::Module: The datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Pre_Calculation.init_fields-Tuple{Module}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Pre_Calculation.init_fields","text":"init_fields(datamanager::Module)\n\nInitializes the fields.\n\nArguments\n\ndatamanager::Data_manager: Datamanager\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Pre_Calculation.init_model-Tuple{Module, AbstractVector{Int64}, Int64}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Pre_Calculation.init_model","text":"init_model(datamanager::Module, nodes::Union{SubArray,Vector{Int64}, block::Int64)\n\nInitializes the model.\n\nArguments\n\ndatamanager::Data_manager: Datamanager\nnodes::AbstractVector{Int64}: The nodes.\nblock::Int64: Block.\n\nReturns\n\ndatamanager::Data_manager: Datamanager.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#Set_modules","page":"Model Factory","title":"Set_modules","text":"","category":"section"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Material.Set_modules.create_module_specifics-Tuple{Union{String, SubString}, Vector{Any}, Dict{String, String}, Tuple}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Material.Set_modules.create_module_specifics","text":"create_module_specifics(name::String, module_list::Dict{String,AbstractString}(),specifics::Dict{String,String}(), values::Tuple)\n\nSearches for a specific function within a list of modules and calls that function if found.\n\nThis function iterates over a list of modules specified in module_list and looks for a module-specific function specified in the specifics dictionary. If the module and function are found, it calls that function with the provided values tuple.\n\nArguments\n\nname::String: The name to match against the module names.\nmodule_list::Dict{String, AbstractString}: A dictionary of module names mapped to abstract strings.\nspecifics::Dict{String, String}: A dictionary specifying the module-specific function to call for each module.\nvalues::Tuple: A tuple of values to be passed as arguments to the module-specific function.\n\nExample\n\n```julia modulelist = Dict(\"Module1\" => \"Module1Name\", \"Module2\" => \"Module2Name\") specifics = Dict(\"Module1Name\" => \"module1function\", \"Module2Name\" => \"module2function\") values = (arg1, arg2) createmodulespecifics(\"Module1Name\", modulelist, specifics, values)\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Material.Set_modules.create_module_specifics-Tuple{Union{String, SubString}, Vector{Any}, Dict{String, String}}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Material.Set_modules.create_module_specifics","text":"create_module_specifics(name::String, module_list::Dict{String,AbstractString}(),specifics::Dict{String,String}())\n# Returns: the function itself\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Material.Set_modules.find_jl_files-Tuple{AbstractString}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Material.Set_modules.find_jl_files","text":"find_jl_files(directory::AbstractString)\n\nRecursively find Julia files (.jl) in a directory.\n\nThis function recursively searches for Julia source files with the \".jl\" extension in the specified directory and its subdirectories. It returns a vector of file paths for all the found .jl files.\n\nArguments\n\ndirectory::AbstractString: The directory in which to search for .jl files.\n\nReturns\n\nA vector of strings, where each string is a file path to a .jl file found in the specified directory and its subdirectories.\n\nExample\n\n```julia jlfiles = findjlfiles(\"/path/to/modules\") for jlfile in jlfiles     println(\"Found Julia file: \", jlfile) end\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Material.Set_modules.find_module_files-Tuple{AbstractString, String}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Material.Set_modules.find_module_files","text":"find_module_files(directory::AbstractString, specific::String)\n\nSearch for Julia modules containing a specific function in a given directory.\n\nThis function searches for Julia modules (files with .jl extension) in the specified directory and checks if they contain a specific function. It returns a list of dictionaries where each dictionary contains the file path and the name of the module where the specific function is found.\n\nArguments\n\ndirectory::AbstractString: The directory to search for Julia modules.\nspecific::String: The name of the specific function to search for.\n\nReturns\n\nAn array of dictionaries, where each dictionary has the following keys:\n\n\"File\": The file path to the module where the specific function is found.\n\"Module Name\": The name of the module where the specific function is found.\n\nExample\n\n```julia result = findmodulefiles(\"/path/to/modules\", \"myfunction\") for moduleinfo in result     println(\"Function found in module: \", moduleinfo[\"Module Name\"])     println(\"Module file path: \", moduleinfo[\"File\"]) end\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_control.Model_Factory.Material.Set_modules.include_files-Tuple{Vector{Any}}","page":"Model Factory","title":"PeriLab.Solver_control.Model_Factory.Material.Set_modules.include_files","text":"include_files(module_list::Vector{Any})\n\nInclude files specified in a list of modules.\n\nThis function iterates over a list of modules and includes the files specified in each module's \"File\" key.\n\nArguments\n\nmodule_list::Vector{Any}: A list of modules where each module is expected to be a dictionary-like object with a \"File\" key specifying the file path.\n\nExamples\n\n```julia include_files([Dict(\"File\" => \"module1.jl\"), Dict(\"File\" => \"module2.jl\")])\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/","page":"Model Factory","title":"Model Factory","text":"","category":"page"},{"location":"theory/theory_FEM_PD_coupling/#Finite-Element-Peridynamics-coupling","page":"Finite Element - Peridynamics coupling","title":"Finite Element - Peridynamics coupling","text":"","category":"section"},{"location":"theory/theory_FEM_PD_coupling/","page":"Finite Element - Peridynamics coupling","title":"Finite Element - Peridynamics coupling","text":"Module Related Model in PeriLab\nArlequin_coupling Arlequin Method","category":"page"},{"location":"theory/theory_FEM_PD_coupling/","page":"Finite Element - Peridynamics coupling","title":"Finite Element - Peridynamics coupling","text":"To couple PD with FEM the distance between the expected PD deformation and the FEM deformation has to be computed [28].","category":"page"},{"location":"theory/theory_FEM_PD_coupling/","page":"Finite Element - Peridynamics coupling","title":"Finite Element - Peridynamics coupling","text":"mathbfz(mathbfu)=mathbfz_0mathbfZmathbfu","category":"page"},{"location":"theory/theory_FEM_PD_coupling/","page":"Finite Element - Peridynamics coupling","title":"Finite Element - Peridynamics coupling","text":"Assume the displacement constraints in the overlapping zone between local and non-local domains are described as: mathbfz=d-sum_OmegamathbfN_i(boldsymbolxi)mathbfu_i with mathbfd the displacement of the PD point and sum_OmegamathbfN_i(boldsymbolxi)mathbfu_i the displacement within the finite element.","category":"page"},{"location":"theory/theory_FEM_PD_coupling/","page":"Finite Element - Peridynamics coupling","title":"Finite Element - Peridynamics coupling","text":"With","category":"page"},{"location":"theory/theory_FEM_PD_coupling/","page":"Finite Element - Peridynamics coupling","title":"Finite Element - Peridynamics coupling","text":"mathbfK_z=kappabeginbmatrix\nmathbfI  mathbfN_d \nmathbfN^T_d  mathbfN^T_dmathbfN_d\nendbmatrixbeginbmatrix\nmathbfd  \nmathbfu\nendbmatrix","category":"page"},{"location":"theory/theory_FEM_PD_coupling/#Arlequin","page":"Finite Element - Peridynamics coupling","title":"Arlequin","text":"","category":"section"},{"location":"theory/theory_FEM_PD_coupling/","page":"Finite Element - Peridynamics coupling","title":"Finite Element - Peridynamics coupling","text":"Following [28] for the Arlequng method the equation of motion of the coupled system in discretized form looks as follows:","category":"page"},{"location":"theory/theory_FEM_PD_coupling/","page":"Finite Element - Peridynamics coupling","title":"Finite Element - Peridynamics coupling","text":"kappabeginbmatrix\nfracalphaV_elmathbfM_FE   \n  (1-alpha)rho_PD\nendbmatrixbeginbmatrix\nddotmathbfd  \nddotmathbfu\nendbmatrix + beginbmatrix\nfracalphaV_elmathbfK_FE   \n  (1-alpha)mathbff_PD\nendbmatrixbeginbmatrix\nmathbfd  \nmathbfu\nendbmatrix + mathbfK_zbeginbmatrix\nmathbfd_0  \nmathbfu_0\nendbmatrix=beginbmatrix\nfracalphaV_elmathbfF_FE  \n(1-alpha)mathbfb_PD\nendbmatrix","category":"page"},{"location":"theory/theory_FEM_PD_coupling/","page":"Finite Element - Peridynamics coupling","title":"Finite Element - Peridynamics coupling","text":"The Integration is illustrated in [29].","category":"page"},{"location":"theory/theory_FEM_PD_coupling/","page":"Finite Element - Peridynamics coupling","title":"Finite Element - Peridynamics coupling","text":"","category":"page"},{"location":"lib/logging_functions/#Logging-Functions","page":"Logging","title":"Logging - Functions","text":"","category":"section"},{"location":"lib/logging_functions/#Index","page":"Logging","title":"Index","text":"","category":"section"},{"location":"lib/logging_functions/","page":"Logging","title":"Logging","text":"Pages = [\"logging_functions.md\"]","category":"page"},{"location":"lib/logging_functions/#Logging_module","page":"Logging","title":"Logging_module","text":"","category":"section"},{"location":"lib/logging_functions/#PeriLab.Logging_module.get_log_file-Tuple{}","page":"Logging","title":"PeriLab.Logging_module.get_log_file","text":"get_log_file()\n\nGet the log file.\n\nReturns\n\nlog_file::String: The log file.\n\n\n\n\n\n","category":"method"},{"location":"lib/logging_functions/#PeriLab.Logging_module.init_logging-Tuple{String, Bool, Bool, Int64, Int64}","page":"Logging","title":"PeriLab.Logging_module.init_logging","text":"init_logging(filename::String, debug::Bool, silent::Bool, rank::Int64, size::Int64)\n\nInitialize the logging.\n\nArguments\n\nfilename::String: The filename.\ndebug::Bool: If debug is true.\nsilent::Bool: If silent is true.\nrank::Int64: The rank.\nsize::Int64: The size.\n\n\n\n\n\n","category":"method"},{"location":"lib/logging_functions/#PeriLab.Logging_module.print_table-Tuple{Matrix, Module}","page":"Logging","title":"PeriLab.Logging_module.print_table","text":"print_table(data::Matrix, datamanager::Module)\n\nPrint the table.\n\nArguments\n\ndata::Matrix: The data.\ndatamanager::Module: The data manager.\n\n\n\n\n\n","category":"method"},{"location":"lib/logging_functions/#PeriLab.Logging_module.progress_filter-Tuple{Any}","page":"Logging","title":"PeriLab.Logging_module.progress_filter","text":"progress_filter(log_args)\n\nFilter progress messages.\n\nArguments\n\nlog_args: The log arguments.\n\nReturns\n\ntrue: If the message is not a progress message.\nfalse: If the message is a progress message.\n\n\n\n\n\n","category":"method"},{"location":"lib/logging_functions/#PeriLab.Logging_module.set_log_file-Tuple{String, Bool, Int64, Int64}","page":"Logging","title":"PeriLab.Logging_module.set_log_file","text":"set_log_file(filename::String)\n\nSet the log file.\n\nArguments\n\nfilename::String: The filename.\n\nReturns\n\nlog_file::String: The log file.\n\n\n\n\n\n","category":"method"},{"location":"lib/logging_functions/#PeriLab.Logging_module.set_result_files-Tuple{Vector{Dict}}","page":"Logging","title":"PeriLab.Logging_module.set_result_files","text":"set_result_files(result_files_temp::Vector{Dict})\n\nSet the result files.\n\nArguments\n\nresult_files_temp::Vector{Dict}: The result files.\n\n\n\n\n\n","category":"method"},{"location":"lib/logging_functions/","page":"Logging","title":"Logging","text":"","category":"page"},{"location":"man/models/additive/#Additive-Models","page":"Additive Models","title":"Additive Models","text":"","category":"section"},{"location":"man/models/additive/","page":"Additive Models","title":"Additive Models","text":"Additive Model Simple\nPrint Temperature âœ”ï¸","category":"page"},{"location":"man/models/additive/#Simple","page":"Additive Models","title":"Simple","text":"","category":"section"},{"location":"man/models/additive/","page":"Additive Models","title":"Additive Models","text":"To realize an additive model all bonds from a point are disconnected from it's neighbors by setting all underlineomegalangleboldsymbolxirangle = 0. Within the mesh input an activation time is specified t_activate. If this time is reached during the simulation process the point is activated.","category":"page"},{"location":"man/models/additive/","page":"Additive Models","title":"Additive Models","text":"underlineomegalangleboldsymbolxirangle in mathcalH_textbfx =    leftbeginarrayl\n0 qquadtextfor tt_activate\n1  qquadtextfor t geq t_activate\nendarrayright","category":"page"},{"location":"man/models/additive/","page":"Additive Models","title":"Additive Models","text":"Depended on the process modeled, additional information can be passed to the point or the bonds connected with him. For this simple printing process a printing temperature is added utilized the heat source S_i. In the presented model, the bonding is ideal an no phase or chemical changes occur. However, in principal such models are applicable. Also it must be noted, that due to mechanical or thermo-mechanical loading bonds can be damaged, if a damage model is applied. In that case it won't be activated again.","category":"page"},{"location":"man/models/additive/","page":"Additive Models","title":"Additive Models","text":"Within this process the t_activate can be user defined. However, to reproduce real processes an interface with the G-code is needed. This interface provides the information when the tool arrives at a specific point and defines the activation time as shown in the figure (taken from [9]).","category":"page"},{"location":"man/models/additive/","page":"Additive Models","title":"Additive Models","text":"(Image: Virtual printing process)","category":"page"},{"location":"man/models/additive/","page":"Additive Models","title":"Additive Models","text":"","category":"page"},{"location":"lecture/seminar_4/#Seminar-4:-From-bond-based-to-state-based-I-(Theory)","page":"Seminar 4","title":"Seminar 4: From bond-based to state-based I (Theory)","text":"","category":"section"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"Definition of states","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"A state is not in general a linear function of xi .\nA state is not in general a continuous function of xi.\nThe real Euclidean space V is infinite-dimensional, while the real Euclidean space mathcalL_2 (the set of second order tensors) has dimension 9","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"Definitions","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"scalar state","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinealangle boldsymbolxirangle","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"vector state","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinemathbfAlangle boldsymbolxirangle","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"Shape tensor","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"mathbfK = underlinemathbfX*underlinemathbfX = int_mathcalHunderlineomegalangle boldsymbolxirangleunderlinemathbfXlangle boldsymbolxirangleotimesunderlinemathbfXlangle boldsymbolxirangle dV","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"is positive definite","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"(Image: )","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"Figure taken from [14]","category":"page"},{"location":"lecture/seminar_4/#Constitutive-Models","page":"Seminar 4","title":"Constitutive Models","text":"","category":"section"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"(Image: )","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"boldsymbolxi = mathbfx-mathbfx","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"Deformation vector state field","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinemathbfYmathbfxtlangle boldsymbolxirangle=mathbfy(mathbfx+boldsymbolxit)-mathbfy(mathbfxt)","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"A material is elastic if there exists a differentiable scalar valued function W()  mathcalV rightarrow mathbbR such that","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinemathbfT= hatunderlinemathbfT(underlinemathbfY)= nabla W(underlinemathbfY)","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"W","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"is the strain energy density function.","category":"page"},{"location":"lecture/seminar_4/#Ordinary-state-based","page":"Seminar 4","title":"Ordinary state-based","text":"","category":"section"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"Ordinary and elastic means","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"It is mobile\nThere exists a scalar-valued function w","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"W(underlinemathbfY)= w(underliney)qquadtextandqquad underliney=underlinemathbfY","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"For this w","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinet(underliney)= nabla w(underliney)","category":"page"},{"location":"lecture/seminar_4/#PD-solid-elastic","page":"Seminar 4","title":"PD solid elastic","text":"","category":"section"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"Concept uses LamÃ© coefficients boldsymbolsigma = 2Gboldsymbolvarepsilon + K  operatornametr(boldsymbolvarepsilon) I","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlineelangleboldsymbolxirangle=mathbfFboldsymbolxi - boldsymbolxi=varepsilon_ijfracxi_ixi_jboldsymbolxi","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"varepsilon_ij=frac12(u_ij+u_ji)","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinee^dlangleboldsymbolxirangle=varepsilon_ij^dfracxi_ixi_jboldsymbolxi","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"W=fracalpha2int_mathcalHunderlineomegalangleboldsymbolxirangle(underlinee^dlangleboldsymbolxirangle)^2dV_boldsymbolxi","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"under assumption of a spherical non-local domain.","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"W = fracalpha m15varepsilon_ij^dvarepsilon_ij^d","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"compared with the strain energy density of the classical model.","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"Omega=Gvarepsilon_ij^dvarepsilon_ij^d","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"alpha=frac15Gm","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinex=underlinemathbfX=boldsymbolxiquadunderliney=underlinemathbfY","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinee=underliney-underlinex=boldsymboleta","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underliney-underlinexneqboldsymboleta","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinet=underlinemathbfT","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"Weighted volume","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"m_V = int_mathcalH underlineomegalangle boldsymbolxirangle underlinex underlinex dV","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"Dilatation","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"theta = frac3m_V = int_mathcalHunderlineomegalangle boldsymbolxirangle underlinex underlineelangle boldsymbolxirangle dV","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinet = fracomegalangle boldsymbolxirangle m_Vleft3K theta underlinex + 15G underlinee^d  right","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"Decomposition in the devatoring and isotropic part of the strain","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinee^dlangle boldsymbolxirangle = epsilon_ij^dxi_ifracx_jboldsymbolxi","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinee^ilangle boldsymbolxirangle = epsilon_ij^ixi_ifracx_jboldsymbolxi","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"The force density can be determined as","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinemathbfT=underlinetfracunderlinemathbfYunderlinemathbfY","category":"page"},{"location":"lecture/seminar_4/#Correspondence","page":"Seminar 4","title":"Correspondence","text":"","category":"section"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinemathbfYlangle boldsymbolxirangle=mathbfFboldsymbolxi","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"Then the peridynamic constitutive model corresponds to the classical constitutive model at mathbfF [14].","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"mathbfF=int_mathcalH(underlineomegalangle boldsymbolxirangleunderlinemathbfYlangle boldsymbolxirangleotimesunderlinemathbfXlangle boldsymbolxirangle dV )cdot mathbfK^-1","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"mathbfK=int_mathcalHunderlineomegalangle boldsymbolxirangleunderlinemathbfXlangle boldsymbolxirangleotimesunderlinemathbfXlangle boldsymbolxirangle dV","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"boldsymbolsigma = f(mathbfF t T )","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"mathbfP = textdet(mathbfF)boldsymbolsigmamathbfF^-T","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinemathbfT = underlineomegalangle boldsymbolxiranglemathbfPmathbfK^-1mathbfxi","category":"page"},{"location":"lecture/seminar_4/#Zero-energy-modes","page":"Seminar 4","title":"Zero-energy modes","text":"","category":"section"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"For correspondence models, the so called zero-energy modes could occur [15]. These modes are non-physical and lead to unstable or unreasonable solutions. Several stabilization methods were published to overcome this problem [16], [17], [18], [19],[20],[21].","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinemathbfT^C=underlinemathbfT+underlinemathbfT^S","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinemathbfT^Slangle boldsymbolxirangle = underlineomegalangleboldsymbolxiranglemathbfC_1underlinemathbfz","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"underlinemathbfzlangle boldsymbolxirangle= underlinemathbfYlangleboldsymbolxi rangle-mathbfFboldsymbolxi","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"mathbfC_1=mathbfCcdotcdotmathbfK^-1","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"\nx = [1,2,3,4,5]\n\na = [1,2,3,4,5]\n\nintegral_a = sum(a)\n\nb=[1,2,3.1,3.9,5]\n\nintegral_b = sum(b)\n\ndisplay(integral_a - integral_b)","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"\nfunction def_grad(x,y)\n    K = sum(x)\n    F = sum(y)/K\n    display(\"F*x $(F.*x')\")\n    display(\"z $(F.*x' - y)\")\nend\n\nx = [1,2,3,4]\ny = [0.5 1. 1.5 2]\n\nprintln(\"Constant deformation gradient in non-local domain\")\ndef_grad(x,y)\n\n\ny = [0.5 0.9 1.6 2]\nprintln(\"Non-Constant deformation gradient in non-local domain\")\ndef_grad(x,y)\n","category":"page"},{"location":"lecture/seminar_4/#Properties-of-\\mathbf{K}-and-\\mathbf{F}","page":"Seminar 4","title":"Properties of mathbfK and mathbfF","text":"","category":"section"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"using LinearAlgebra\nx = [1 0;0 1;0 -1; -1 0; 1 1; -1 -1]\nK = x'*x\n\ndisplay(K'-K)\ndisplay(rank(K))\n\ny = [1.1 0;0 1.0;0 -1; -1 0; 1 1; -1 -1]\n\nF = y'*x / K\n\ndisplay(F'-F)\ndisplay(rank(F))\n\nstrain = 0.5*(F'*F - I)\ndisplay(strain'-strain)\ndisplay(rank(strain))\n","category":"page"},{"location":"lecture/seminar_4/","page":"Seminar 4","title":"Seminar 4","text":"","category":"page"},{"location":"man/models/overview/#Models","page":"Overview","title":"Models","text":"","category":"section"},{"location":"man/models/overview/","page":"Overview","title":"Overview","text":"mindmap\n  root((Models))\n    Material Models\n      Bond Based\n        Bond-based Elastic\n        Unified Bond-based Elastic\n      Ordinary\n        PD Solid Elastic\n        PD Solid Plastic\n      Correspondence\n        Correspondence Elastic\n        Correspondence Plastic\n        Bond-associated (optional)\n    Damage Models\n      Critical Stretch\n      Critical Energy\n    Thermal Models\n      Thermal Expansion\n      Thermal Flow\n      Heat Transfer\n    Additive Models\n        Simple","category":"page"},{"location":"man/models/overview/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"lecture/seminar_1/#Seminar-1:-Trusses-and-structure-of-matrices","page":"Seminar 1","title":"Seminar 1: Trusses and structure of matrices","text":"","category":"section"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"For a truss everything is a scalar. The norms are given for better illustration.","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"i","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"point","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"j","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"neighbor","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"xi = x_j-x_i","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"eta = u_j - u_i","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"Bond force","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"f_ij = c_iomega_ij sfracxi+etaxi + eta = c_iomega_ij s","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"s = fracxi + eta - xixi = fracetaxi","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"rho ddotu_i = frac12sum_j (f_jiV_i-f_ijV_j)+b_i","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"point based is solved like this","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"info: 2D and 3D\nthe bond force f_ij becomes mathbff_ij and is mathbff_ij=c_iomega_ij sfracboldsymbolxi + etaboldsymbolxi + eta","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"Matrix based","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"beginbmatrix\nK_11  cdots  K_1j  0 0\nvdots  ddots  \nK_j1    K_jj \n0   \nvdots   ddots\n0  cdotsK_nn\nendbmatrixbeginbmatrixu_1vdotsu_ju_j+1vdots u_nendbmatrix = mathbfF_internal","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"K_ij = -fraccxi_ij omega_ijV_j quad textfor  i ne jquad K_ii = -sum_j ne i K_ij i=1n quad textand quad j=i+1n_neighborsi+1","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"mathbfF_internal","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"is the force density in leftfracNm^3right","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"1D [31] rightarrow c = frac2EAdelta^2 2D For FEM","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"mathbfK=fracEALbeginbmatrix1-1-11endbmatrix","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"Test the local model case. (Image: )","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"Assumptions","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"delta = L n_neighborsi=1 omega_ij=1 V_i=V=const","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"V=AL","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"info: Volume\nMust be AL, because the sum of the neighborvolume must represent the whole volume of the neighborhood, which is AL.","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"c=05frac2EAL^2","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"K_11=-K_12=-05fraccxi V=-05fraccL V=-fracEAL^3AL=-fracEL^2","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"mathbfK=fracEL^2beginbmatrix1-1-11endbmatrix","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"bring it in local form of the stiffness matrix the forces and not the force densities the stiffness has to be multiplied by V.","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"^forcesK_11=-^forcesK_12=-fracEL^2AL=fracEAL","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"mathbfK=fracEALbeginbmatrix1-1-11endbmatrix","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"","category":"page"},{"location":"lecture/seminar_1/#Analysis-of-matrix-behavior","page":"Seminar 1","title":"Analysis of matrix behavior","text":"","category":"section"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"using LinearAlgebra\nE = 1\nV = 1\nL = 1\nnp = 4\nnn = np-1\ndelta = 1\nomega=ones(np, np)\n##\nc=zeros(np)\nc .= 2*E/delta^2\n#c[4]=1.5 .*c[4]\nK=zeros(np,np)\nfor iID in 1:np\n  for jID in -nn:nn\n    if jID != 0 && iID + jID > 0 && iID + jID < np + 1\n      xi = L*abs(jID)\n      K[iID, iID + jID] -= 0.5 * c[iID] / xi * V * omega[iID, iID + jID]\n      K[iID, iID]      +=  0.5 *c[iID] / xi * V * omega[iID, iID + jID]\n    end\n  end\nend\neigvals(K)\ndisplay(K)\nrank(K)\neigvals(K)\ndet(K)\n\n## Damage\n\nomega[1,2] = 0\n\nK=zeros(np,np)\nfor iID in 1:np\n  for jID in -nn:nn\n    if jID != 0 && iID + jID > 0 && iID + jID < np + 1\n      xi = L*abs(jID)\n      K[iID, iID + jID] -= 0.5 * c[iID] / xi * V * omega[iID, iID + jID]\n      K[iID, iID]      +=  0.5 *c[iID] / xi * V * omega[iID, iID + jID]\n    end\n  end\nend\n\ndisplay(K)\n","category":"page"},{"location":"lecture/seminar_1/#Perilab","page":"Seminar 1","title":"Perilab","text":"","category":"section"},{"location":"lecture/seminar_1/#Mesh","page":"Seminar 1","title":"Mesh","text":"","category":"section"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"header: x y block_id volume\n0 0 1 1\n1 0 1 1\n2 0 1 1\n3 0 1 1\n4 0 1 1","category":"page"},{"location":"lecture/seminar_1/#Yaml","page":"Seminar 1","title":"Yaml","text":"","category":"section"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"PeriLab:\n  Discretization:\n    Node Sets:\n      Node Set 1: 1\n      Node Set 2: 5\n    Type: \"Text File\"\n    Input Mesh File: \"truss.txt\"\n  Models:\n    Material Models:\n      Test:\n        Material Model: \"Bond-based Elastic\"\n        Symmetry: \"isotropic plane stress\"\n        Young's Modulus: 7000\n        Poisson's Ratio: 0.3\n  Blocks:\n    block_1:\n      Block ID: 1\n      Material Model: \"Test\"\n      Density: 2e-9\n      Horizon: 2\n  Boundary Conditions:\n    BC_1:\n      Variable: \"Displacements\"\n      Node Set: \"Node Set 1\"\n      Coordinate: \"x\"\n      Value: \"100*t\"\n      Type: Dirichlet\n    BC_2:\n      Variable: \"Displacements\"\n      Coordinate: \"x\"\n      Node Set: \"Node Set 2\"\n      Value: \"0.1*t\"\n      Type: Dirichlet\n  Solver:\n    Material Models: True\n    Initial Time: 0.0\n    Final Time: 1.0\n    Number of Steps: 20\n    Static:\n      Show solver iteration: true\n      Residual tolerance: 1e-7\n      Solution tolerance: 1e-8\n      Residual scaling: 7000\n      m: 550\n      Maximum number of iterations: 100\n  Outputs:\n    Output1:\n      Output Filename: \"truss\"\n      Output File Type: Exodus\n      Number of Output Steps: 20\n      Output Variables:\n        Displacements: True\n        Number of Neighbors: True\n        Forces: True","category":"page"},{"location":"lecture/seminar_1/","page":"Seminar 1","title":"Seminar 1","text":"","category":"page"},{"location":"theory/theory_correspondence/#Non-ordinary-state-based-Peridynamics","page":"Non-Ordinary state-based","title":"Non-ordinary state based Peridynamics","text":"","category":"section"},{"location":"theory/theory_correspondence/#Correspondence-Peridynamics","page":"Non-Ordinary state-based","title":"Correspondence Peridynamics","text":"","category":"section"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"The correspondence formulation is a non-ordinary state-based formulation provided by [14]. It has the goal to apply classical models to Peridynamics.","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"The non-local deformation gradient is defined as","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"mathbfF=int_mathcalHunderlineomegalangle boldsymbolxirangleunderlinemathbfYlangle boldsymbolxirangleotimesunderlinemathbfXlangle boldsymbolxirangle dV cdot mathbfK^-1","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"with the positive definite shape tensor as","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"mathbfK=int_mathcalHunderlineomegalangle boldsymbolxirangleunderlinemathbfXlangle boldsymbolxirangleotimesunderlinemathbfXlangle boldsymbolxirangle dV","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"info: Positive definiteness in numerics\nIn numerical applications if bonds break the shape tensor is positive semi definite. detmathbfK=0 can occur and the inversion of the shape tensor won't work.","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"Based on this definition strain measures can be created to calculate the Cauchy stresses","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"boldsymbolsigma = f(mathbfF t T )","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"To get the force densities the First-Piola Kirchhoff stress tensor has to be calculated by","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"mathbfP = textdet(mathbfF)boldsymbolsigmamathbfF^-T","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"and finaly the force density vector can be determined as","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"underlinemathbfT = underlineomegalangle boldsymbolxiranglemathbfPmathbfK^-1mathbfxi","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"The 2D plane strain or plane stress models are represented in the Cauchy stresses by assuming that the strain in the third direction are zero or the stresses.","category":"page"},{"location":"theory/theory_correspondence/#Zero-energy-modes","page":"Non-Ordinary state-based","title":"Zero-energy modes","text":"","category":"section"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"For correspondence models, the so called zero-energy modes could occur [15]. These modes are non-physical and lead to unstable or unreasonable solutions. Several stabilization methods were published to overcome this problem [16], [17], [18], [19],[20],[21].","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"A promising approach implemented as global control in PeriLab was published by Wan et al. in 2019 [22]. Instead of a bond-based stabilization method proposed by Silling [23] Wan et al. developed a state-based stabilization method. As positive side effect this method stabilizes the solution for anisotropic material as well. The corrected force density state underlinemathbfT^C with suppression of the zero-energy mode is:","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"underlinemathbfT^C=underlinemathbfT+underlinemathbfT^S","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"Following Wan et al. \\cite{WanJ2019} the suppression force density state underlinemathbfT^S is:","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"underlinemathbfT^Slangle boldsymbolxirangle = underlineomegalangleboldsymbolxiranglemathbfC_1underlinemathbfz","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"with underlinemathbfz as the non-uniform deformation state","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"underlinemathbfzlangle boldsymbolxirangle= underlinemathbfYlangleboldsymbolxi rangle-mathbfFboldsymbolxi","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"caused by the zero-energy mode. If the approximated non-local deformation gradient mathbfF exactly maps each undeformed bond to the deformed configuration  no zero-energy mode occur. In that case the non-uniform deformation state is zero and the corrected force density state underlinemathbfT^C is equal to the force density state underlinemathbfT. The second order tensor mathbfC_1 is given as","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"mathbfC_1=mathbfCcdotcdotmathbfK^-1","category":"page"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"utilizing the elasticity tensor.","category":"page"},{"location":"theory/theory_correspondence/#Bond-associated-correspondence-Peridynamics","page":"Non-Ordinary state-based","title":"Bond-associated correspondence Peridynamics","text":"","category":"section"},{"location":"theory/theory_correspondence/","page":"Non-Ordinary state-based","title":"Non-Ordinary state-based","text":"","category":"page"},{"location":"lib/glossar/#Glossar","page":"Glossar","title":"Glossar","text":"","category":"section"},{"location":"lib/glossar/#Abbreviations","page":"Glossar","title":"Abbreviations","text":"","category":"section"},{"location":"lib/glossar/","page":"Glossar","title":"Glossar","text":"Abbreviation Full\ndof degree of freedom\nFEM Finite Element Method\nPD Peridynamics","category":"page"},{"location":"lib/glossar/#Variables","page":"Glossar","title":"Variables","text":"","category":"section"},{"location":"lib/glossar/","page":"Glossar","title":"Glossar","text":"Parameter Name\nmathcalH Neighborhood [-]\nV Volume leftm^3right\nmathbfx Position of point leftmright\nmathbfx Position of neighbor leftmright\nt Time leftsright\nmathbfb Body force densities leftNm^3right\nmathbfu Displacements leftmright\nddotmathbfu Accelerations leftms^2right\nunderlinemathbfT Force density state leftNm^6right\nrho Mass density leftkgm^3right\ntau Temperature leftKright\nDelta Delta of a variable left-right\nmathbfH Heat flux leftWm^2right\nmathbfF Force density leftNm^3right","category":"page"},{"location":"lib/glossar/","page":"Glossar","title":"Glossar","text":"","category":"page"},{"location":"lib/io_functions/#IO-Functions","page":"IO","title":"IO - Functions","text":"","category":"section"},{"location":"lib/io_functions/#Index","page":"IO","title":"Index","text":"","category":"section"},{"location":"lib/io_functions/","page":"IO","title":"IO","text":"Pages = [\"io_functions.md\"]","category":"page"},{"location":"lib/io_functions/#IO","page":"IO","title":"IO","text":"","category":"section"},{"location":"lib/io_functions/#PeriLab.IO._init_overlap_map_-Tuple{Any}","page":"IO","title":"PeriLab.IO._init_overlap_map_","text":"_init_overlap_map_(size)\n\nInitialize the overlap map.\n\nArguments\n\nsize::Int64: The number of ranks.\n\nReturns\n\noverlap_map::Dict{Int64,Dict{Int64,Dict{String,Vector{Int64}}}}: The overlap map.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.apply_bond_filters-Tuple{Vector{Vector{Int64}}, DataFrames.DataFrame, Dict, Int64}","page":"IO","title":"PeriLab.IO.apply_bond_filters","text":"apply_bond_filters(nlist::Vector{Vector{Int64}}, mesh::DataFrame, params::Dict, dof::Int64)\n\nApply the bond filters to the neighborhood list.\n\nArguments\n\nnlist::Vector{Vector{Int64}}: The neighborhood list.\nmesh::DataFrame: The mesh.\nparams::Dict: The parameters.\ndof::Int64: The degrees of freedom.\n\nReturns\n\nnlist::Vector{Vector{Int64}}: The filtered neighborhood list.\nnlist_filtered_ids::Vector{Vector{Int64}}: The filtered neighborhood list.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.area_of_polygon-Tuple{Any}","page":"IO","title":"PeriLab.IO.area_of_polygon","text":"area_of_polygon(vertices)\n\nCalculate the area of a polygon.\n\nArguments\n\nvertices: The vertices of the polygon.\n\nReturns\n\narea: The area of the polygon.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.bond_intersect_infinite_plane-NTuple{4, Vector{Float64}}","page":"IO","title":"PeriLab.IO.bond_intersect_infinite_plane","text":"bond_intersect_infinite_plane(p0::Vector{Float64}, p1::Vector{Float64}, lower_left_corner::Vector{Float64}, normal::Vector{Float64})\n\nCheck if a line segment intersects an infinite plane.\n\nArguments\n\np0::Vector{Float64}: The start point of the line segment.\np1::Vector{Float64}: The end point of the line segment.\nlower_left_corner::Vector{Float64}: The lower left corner of the plane.\nnormal::Vector{Float64}: The normal of the plane.\n\nReturns\n\nBool: True if the line segment intersects the plane, False otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.bond_intersect_rectangle_plane-Tuple{Union{Vector{Float64}, Vector{Int64}}, Union{Vector{Float64}, Vector{Int64}}, Union{Vector{Float64}, Vector{Int64}}, Union{Vector{Float64}, Vector{Int64}}, Real, Real}","page":"IO","title":"PeriLab.IO.bond_intersect_rectangle_plane","text":"bond_intersect_rectangle_plane(x::Vector{Float64}, lower_left_corner::Vector{Float64}, bottom_unit_vector::Vector{Float64}, normal::Vector{Float64}, side_length::Float64, bottom_length::Float64)\n\nCheck if a bond intersects a rectangle plane.\n\nArguments\n\nx::Vector{Float64}: The point.\nlower_left_corner::Vector{Float64}: The lower left corner of the rectangle.\nbottom_unit_vector::Vector{Float64}: The unit vector along the bottom of the rectangle.\nnormal::Vector{Float64}: The normal of the plane.\nside_length::Float64: The side length of the rectangle.\nbottom_length::Float64: The bottom length of the rectangle.\n\nReturns\n\nBool: True if the point is inside the rectangle, False otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.bond_intersects_disc-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64}","page":"IO","title":"PeriLab.IO.bond_intersects_disc","text":"bond_intersects_disc(p0::Vector{Float64}, p1::Vector{Float64}, center::Vector{Float64}, normal::Vector{Float64}, radius::Float64)\n\nCheck if a line segment intersects a disk.\n\nArguments\n\np0::Vector{Float64}: The start point of the line segment.\np1::Vector{Float64}: The end point of the line segment.\ncenter::Vector{Float64}: The center of the disk.\nnormal::Vector{Float64}: The normal of the plane.\nradius::Float64: The radius of the disk.\n\nReturns\n\nBool: True if the line segment intersects the disk, False otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.calculate_block-Tuple{Module, String, Union{Int64, Vector{Int64}}, String, Int64}","page":"IO","title":"PeriLab.IO.calculate_block","text":"calculate_block(datamanager::Module, field_key::String, dof::Int64, calculation_type::String, block::Int64)\n\nCalculate the global value of a field for a given block.\n\nArguments\n\ndatamanager::Data_manager: Datamanager.\nfield_key::String: Field key.\ndof::Union{Int64,Vector{Int64}}: Degree of freedom\ncalculation_type::String: Calculation type.\nblock::Int64: Block number.\n\nReturns\n\nvalue::Float64: Global value.\nnnodes::Int64: Number of nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.calculate_nodelist-Tuple{Module, String, Union{Int64, Vector{Int64}}, String, Union{Int64, Vector{Int64}}}","page":"IO","title":"PeriLab.IO.calculate_nodelist","text":"calculate_nodelist(datamanager::Module, field_key::String, dof::Union{Int64,Vector{Int64}}, calculation_type::String, local_nodes::Vector{Int64})\n\nCalculate the global value of a field for a given set of nodes.\n\nArguments\n\ndatamanager::Data_manager: Datamanager.\nfield_key::String: Field key.\ndof::Union{Int64,Vector{Int64}}: Degree of freedom\ncalculation_type::String: Calculation type.\nlocal_nodes::Vector{Int64}: Node set.\n\nReturns\n\nvalue::Vector: Global value.\nnnodes::Int64: Number of nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.calculate_volume-Tuple{String, Vector{Vector{Float64}}}","page":"IO","title":"PeriLab.IO.calculate_volume","text":"calculate_volume(element_type::String, vertices::Vector{Vector{Float64}})\n\nCalculate the volume of a element.\n\nArguments\n\nelement_type: The element type of the element.\nvertices: The vertices of the element.\n\nReturns\n\nvolume: The volume of the element.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.check_for_duplicate_in_dataframe-Tuple{DataFrames.DataFrame}","page":"IO","title":"PeriLab.IO.check_for_duplicate_in_dataframe","text":"check_for_duplicate_in_dataframe(mesh::DataFrame)\n\ncheck duplicated entries and throws an error if one is there. If not everything is ok.\n\nArguments\n\nmesh::DataFrame: The input mesh data represented as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.check_mesh_elements-Tuple{DataFrames.DataFrame, Int64}","page":"IO","title":"PeriLab.IO.check_mesh_elements","text":"check_mesh_elements(mesh, dof)\n\nProcess and analyze mesh data to create an dictionary containing information about mesh elements for further processing.\n\nArguments\n\nmesh::DataFrame: The input mesh data represented as a DataFrame.\ndof::Int64: The degrees of freedom (DOF) for the mesh elements.\n\nReturns\n\nA dictionary containing information about mesh elements, which can be used for further processing or uploading.\n\nExample\n\n```julia meshdata = DataFrame(x1 = [1.0, 2.0, 3.0], x2 = [4.0, 5.0, 6.0], volume = [10.0, 20.0, 30.0]) dof = 3 result = checkmeshelements(meshdata, dof)\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.check_types_in_dataframe-Tuple{DataFrames.DataFrame}","page":"IO","title":"PeriLab.IO.check_types_in_dataframe","text":"check_types_in_dataframe(mesh::DataFrame)\n\ncheck if block_id in mesh contains only int.\n\nArguments\n\nmesh::DataFrame: The input mesh data represented as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.clearNP1-Tuple{String}","page":"IO","title":"PeriLab.IO.clearNP1","text":"clearNP1(name::String)\n\nClears the NP1 from the name\n\nArguments\n\nname::String: The name\n\nReturns\n\nname::String: The cleared name\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.close_result_file-Tuple{Dict}","page":"IO","title":"PeriLab.IO.close_result_file","text":"close_result_file(result_file::Dict)\n\nCloses the result file\n\nArguments\n\nresult_file::Dict: The result file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.close_result_files-Tuple{Vector{Dict}, Dict{Int64, Dict}}","page":"IO","title":"PeriLab.IO.close_result_files","text":"close_result_files(result_files::Vector{Dict}, outputs::Dict{Int64,Dict{}})\n\nCloses the result files if the flush_file flag is not set\n\nArguments\n\nresult_files::Vector{Dict}: The result files\noutputs::Dict{Int64,Dict{}}: The output settings\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.close_result_files-Tuple{Vector{Dict}}","page":"IO","title":"PeriLab.IO.close_result_files","text":"close_result_files(result_files::Vector{Dict})\n\nCloses the result files\n\nArguments\n\nresult_files::Vector{Dict}: The result files\n\nReturns\n\ntrue: File is closed\nfalse: File was already closed\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_and_distribute_bond_norm-Tuple{MPI.Comm, Module, Vector{Vector{Int64}}, Vector{Vector{Int64}}, Vector{Any}, Int64}","page":"IO","title":"PeriLab.IO.create_and_distribute_bond_norm","text":"create_and_distribute_bond_norm(comm::MPI.Comm, datamanager::Module, nlist_filtered_ids::Vector{Vector{Int64}}, distribution::Vector{Int64}, bond_norm::Vector{Float64}, dof::Int64)\n\nCreate and distribute the bond norm\n\nArguments\n\ncomm::MPI.Comm: MPI communicator\ndatamanager::Module: Data manager\nnlist_filtered_ids::Vector{Vector{Int64}}: The filtered neighborhood list\ndistribution::Vector{Int64}: The distribution\nbond_norm::Vector{Float64}: The bond norm\ndof::Int64: The degree of freedom\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_distribution-Tuple{Int64, Int64}","page":"IO","title":"PeriLab.IO.create_distribution","text":"create_distribution(nnodes::Int64, size::Int64)\n\nCalculate the initial size of each chunk for a nearly equal number of nodes vs. cores this algorithm might lead to the problem, that the last core is not equally loaded\n\nArguments\n\nnnodes::Int64: The number of nodes.\nsize::Int64: The number of cores.\n\nReturns\n\ndistribution::Array{Int64,1}: The distribution of the nodes.\npoint_to_core::Array{Int64,1}: The number of nodes in each rank.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_distribution_neighbor_based-Tuple{Int64, Vector{Vector{Int64}}, Int64}","page":"IO","title":"PeriLab.IO.create_distribution_neighbor_based","text":"create_distribution_neighbor_based(nnodes::Int64,nlist::Vector{Vector{Int64}}, size::Int64)\n\nCalculate the initial size of each chunk for a nearly equal number of nodes vs. cores this algorithm might lead to the problem, that the last core is not equally loaded\n\nArguments\n\nnnodes::Int64: The number of nodes.\nnlist::Vector{Vector{Int64}}: The neighborhood list.\nsize::Int64: The number of cores.\n\nReturns\n\ndistribution::Array{Int64,1}: The distribution of the nodes.\npoint_to_core::Array{Int64,1}: The number of nodes in each rank.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_distribution_node_based-Tuple{Int64, Vector{Vector{Int64}}, Int64}","page":"IO","title":"PeriLab.IO.create_distribution_node_based","text":"create_distribution_node_based(nnodes::Int64,nlist::Vector{Vector{Int64}}, size::Int64)\n\nCalculate the initial size of each chunk for a nearly equal number of nodes vs. cores this algorithm might lead to the problem, that the last core is not equally loaded\n\nArguments\n\nnnodes::Int64: The number of nodes.\nnlist::Vector{Vector{Int64}}: The neighborhood list.\nsize::Int64: The number of cores.\n\nReturns\n\ndistribution::Array{Int64,1}: The distribution of the nodes.\npoint_to_core::Array{Int64,1}: The number of nodes in each rank.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_global_to_local_mapping-Tuple{Any}","page":"IO","title":"PeriLab.IO.create_global_to_local_mapping","text":"glob_to_loc(distribution)\n\nGet the global to local mapping\n\nArguments\n\ndistribution: The distribution\n\nReturns\n\ncreate_global_to_local_mapping: The global to local mapping\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_neighborhoodlist-Tuple{DataFrames.DataFrame, Dict, Int64}","page":"IO","title":"PeriLab.IO.create_neighborhoodlist","text":"create_neighborhoodlist(mesh::DataFrame, params::Dict, dof::Int64)\n\nCreate the neighborhood list of the mesh elements.\n\nArguments\n\nmesh::DataFrame: The input mesh data represented as a DataFrame.\nparams::Dict: The input parameters.\ndof::Int64: The degrees of freedom (DOF) for the mesh elements.\n\nReturns\n\nnlist::Array{Array{Int64,1},1}: The neighborhood list of the mesh elements.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_overlap_map-Tuple{Vector{Vector{Int64}}, Vector{Int64}, Int64}","page":"IO","title":"PeriLab.IO.create_overlap_map","text":"create_overlap_map(distribution, ptc, size)\n\nCreate the overlap map.\n\nArguments\n\ndistribution::Array{Int64,1}: The distribution of the nodes.\nptc::Array{Int64,1}: The number of nodes in each rank.\nsize::Int64: The number of ranks.\n\nReturns\n\noverlap_map::Dict{Int64,Dict{Int64,Dict{String,Vector{Int64}}}}: The overlap map.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_result_file","page":"IO","title":"PeriLab.IO.create_result_file","text":"create_result_file(filename::Union{AbstractString,String}, num_nodes::Int64, num_dim::Int64, num_elem_blks::Int64, num_node_sets::Int64)\n\nCreates a exodus file for the results\n\nArguments\n\nfilename::Union{AbstractString,String}: The name of the file to create\nnum_nodes::Int64: The number of nodes\nnum_dim::Int64: The number of dimensions\nnum_elem_blks::Int64: The number of element blocks\nnum_node_sets::Int64: The number of node sets\n\nReturns\n\nresult_file::Dict{String,Any}: A dictionary containing the filename and the exodus file\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.IO.create_result_file-Tuple{String, Dict}","page":"IO","title":"PeriLab.IO.create_result_file","text":"create_result_file(filename::String, outputs::Dict)\n\nCreates a csv file for the results\n\nArguments\n\nfilename::String: The name of the file to create\noutputs::Dict: The outputs dictionary\n\nReturns\n\nDict: The result file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.csv_reader-Tuple{String}","page":"IO","title":"PeriLab.IO.csv_reader","text":"csv_reader(filename::String)\n\nRead csv and return it as a DataFrame.\n\nArguments\n\nfilename::String: The path to the mesh file.\n\nReturns\n\ncsvData::DataFrame: The csv data a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.define_nsets-Tuple{Dict{String, Vector{Int64}}, Module}","page":"IO","title":"PeriLab.IO.define_nsets","text":"define_nsets(nsets::Dict{String,Vector{Int64}}, datamanager::Module)\n\nDefines the node sets\n\nArguments\n\nnsets::Dict{String,Vector{Int64}}: Node sets read from files\ndatamanager::Module: Data manager\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.delete_files-Tuple{Vector{Dict}, String}","page":"IO","title":"PeriLab.IO.delete_files","text":"delete_files(result_files::Vector{Dict})\n\nDeletes the result files\n\nArguments\n\nresult_files: The result files\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.disk_filter-Tuple{Int64, Matrix{Float64}, Dict, Vector{Vector{Int64}}, Int64}","page":"IO","title":"PeriLab.IO.disk_filter","text":"disk_filter(nnodes::Int64, data::Matrix{Float64}, filter::Dict, nlist::Vector{Vector{Int64}}, dof::Int64)\n\nApply the disk filter to the neighborhood list.\n\nArguments\n\nnnodes::Int64: The number of nodes.\ndata::Matrix{Float64}: The data.\nfilter::Dict: The filter.\nnlist::Vector{Vector{Int64}}: The neighborhood list.\ndof::Int64: The degrees of freedom.\n\nReturns\n\nfilter_flag::Vector{Bool}: The filter flag.\nnormal::Vector{Float64}: The normal vector of the disk.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.distribute_neighborhoodlist_to_cores-Tuple{MPI.Comm, Module, Vector{Vector{Int64}}, Vector{Vector{Int64}}, Bool}","page":"IO","title":"PeriLab.IO.distribute_neighborhoodlist_to_cores","text":"distribute_neighborhoodlist_to_cores(comm::MPI.Comm, datamanager::Module, nlist, distribution)\n\nDistributes the neighborhood list to the cores.\n\nArguments\n\ncomm::MPI.Comm: MPI communicator\ndatamanager::Module: Data manager\nnlist: neighborhood list\ndistribution Array{Int64}: global nodes distribution at cores\n\nReturns\n\ndatamanager::Module: data manager\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.distribution_to_cores-Tuple{MPI.Comm, Module, DataFrames.DataFrame, Vector{Vector{Int64}}, Int64}","page":"IO","title":"PeriLab.IO.distribution_to_cores","text":"distribution_to_cores(comm::MPI.Comm, datamanager::Module, mesh, distribution, dof::Int64)\n\nDistributes the mesh data to the cores\n\nArguments\n\ncomm::MPI.Comm: MPI communicator\ndatamanager::Module: Data manager\nmesh: Mesh\ndistribution Array{Int64}: global nodes distribution at cores\ndof::Int64: Degree of freedom\n\nReturns\n\ndatamanager::Module: data manager\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.element_distribution-Tuple{Vector{Vector{Int64}}, Vector{Int64}, Int64}","page":"IO","title":"PeriLab.IO.element_distribution","text":"element_distribution(topology::Vector{Vector{Int64}}, ptc::Vector{Int64}, size::Int64)\n\nCreate the distribution of the finite elements. Is needed to avoid multiple element calls. Each element should run only one time at the cores.\n\nArguments\n\ntopology::Vector{Vector{Int64}}: The topology list of the mesh elements.\nnlist::Vector{Vector{Int64}}: The neighborhood list of the mesh elements.\nsize::Int64: The number of ranks.\n\nReturns\n\ndistribution::Vector{Vector{Int64}}: The distribution of the nodes.\netc::Vector{Int64}: The number of nodes in each rank.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.extrude-Tuple{Any, Any}","page":"IO","title":"PeriLab.IO.extrude","text":"extrude(cmds, dataobject)\n\nExample extrusion callback for G1 which calculates total length of filament extruded.\n\nThe extruded filament length is obtained by watching the E axis movement in the g-code file.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.extrude_surface_mesh-Tuple{DataFrames.DataFrame, Dict}","page":"IO","title":"PeriLab.IO.extrude_surface_mesh","text":"extrude_surface_mesh(mesh::DataFrame)\n\nextrude the mesh at the surface of the block\n\nArguments\n\nmesh::DataFrame: The input mesh data represented as a DataFrame.\nparams::Dict: The input parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.find_global_core_value!-Tuple{Union{Float64, Int64}, String, Int64, Module}","page":"IO","title":"PeriLab.IO.find_global_core_value!","text":"find_global_core_value!(global_value::Union{Int64,Float64}, calculation_type::String, nnodes::Int64, datamanager::Module)\n\nFind global core value.\n\nArguments\n\nglobal_value::Union{Int64,Float64}: The global value\ncalculation_type::String: The calculation type\nnnodes::Int64: The number of nodes\ndatamanager::Module: The datamanager\n\nReturns\n\nglobal_value::Union{Int64,Float64}: The global value\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_block_nodes-Tuple{AbstractVector{Int64}, Int64}","page":"IO","title":"PeriLab.IO.get_block_nodes","text":"get_block_nodes(block_Id::AbstractVector{Int64}, block::Int64)\n\nReturns the nodes of a block\n\nArguments\n\nblock_Id::AbstractVector{Int64}: The block Id\nblock::Int64: The block\n\nReturns\n\nnodes::Vector{Int64}: The nodes of the block\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_bond_geometry-Tuple{Module}","page":"IO","title":"PeriLab.IO.get_bond_geometry","text":"get_bond_geometry(datamanager::Module)\n\nGets the bond geometry\n\nArguments\n\ndatamanager::Module: Data manager\n\nReturns\n\ndatamanager::Module: data manager\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_file_size-Tuple{Vector{Dict}}","page":"IO","title":"PeriLab.IO.get_file_size","text":"get_file_size(result_files::Vector{Dict})\n\nGets the file size of the result files\n\nArguments\n\nresult_files: The result files\n\nReturns\n\ntotal_file_size: The total file size\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_global_values-Tuple{Dict, Module}","page":"IO","title":"PeriLab.IO.get_global_values","text":"get_global_values(output::Dict, datamanager::Module)\n\nGet global values.\n\nArguments\n\noutput::Dict: The output\ndatamanager::Module: The datamanager\n\nReturns\n\nglobal_values::Vector: The global values\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_local_element_topology-Tuple{Module, Vector{Vector{Int64}}, Vector{Int64}}","page":"IO","title":"PeriLab.IO.get_local_element_topology","text":"get_local_element_topology(datamanager::Module, topology::Vector{Vector{Int64}}, distribution::Vector{Int64})\n\nGet the local element topology\n\nArguments\n\ndatamanager::Module: The datamanager\ntopology::Vector{Vector{Int64}}: The topology\ndistribution::Vector{Int64}: The distribution\n\nReturns\n\ndatamanager::Module: The datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_local_neighbors-Tuple{Any, Any}","page":"IO","title":"PeriLab.IO.get_local_neighbors","text":"get_local_neighbors(mapping, nlist_core)\n\nGets the local neighborhood list from the global neighborhood list\n\nArguments\n\nmapping: mapping function\nnlist_core: global neighborhood list\n\nReturns\n\nnlist_core: local neighborhood list\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_local_overlap_map-Tuple{Any, Vector{Vector{Int64}}, Int64}","page":"IO","title":"PeriLab.IO.get_local_overlap_map","text":"get_local_overlap_map()\n\nChanges entries in the overlap map from the global numbering to the local computer core one.\n\nArguments\n\noverlap_map::Dict{Int64, Dict{Int64, String}}: overlap map with global nodes.\ndistribution::Vector{Vector{Int64}}: global nodes distribution at cores, needed for the gobal to local mapping\nranks Array{Int64} : number of used computer cores\n\nReturns\n\noverlap_map::Dict{Int64, Dict{Int64, String}}: returns overlap map with local nodes.\n\nExample:\n\nget_local_overlap_map(overlap_map, distribution, ranks)  # returns local nodes\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_mpi_rank_string-Tuple{Int64, Int64}","page":"IO","title":"PeriLab.IO.get_mpi_rank_string","text":"get_mpi_rank_string(rank::Int64, max_rank::Int64)\n\nGet MPI rank string.\n\nArguments\n\nvalue::Int64: The rank\nmax_rank::Int64: The max rank\n\nReturns\n\nresult::String: The result\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_number_of_neighbornodes-Tuple{Vector{Vector{Int64}}, Bool}","page":"IO","title":"PeriLab.IO.get_number_of_neighbornodes","text":"get_number_of_neighbornodes(nlist::Vector{Vector{Int64}})\n\nGet the number of neighbors for each node.\n\nArguments\n\nnlist::Vector{Vector{Int64}}: The neighborhood list of the mesh elements.\n\nReturns\n\nlength_nlist::Vector{Int64}: The number of neighbors for each node.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_paraview_coordinates-Tuple{Int64, Int64}","page":"IO","title":"PeriLab.IO.get_paraview_coordinates","text":"get_paraview_coordinates(dof::Int64, refDof::Int64)\n\nReturns the paraview specific dof\n\nArguments\n\ndof::Int64: The degrees of freedom\nrefDof::Int64: The reference degrees of freedom\n\nReturns\n\nparaview_specifics::String: The paraview specific dof\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_results_mapping-Tuple{Dict, String, Module}","page":"IO","title":"PeriLab.IO.get_results_mapping","text":"get_results_mapping(params::Dict, path::String, datamanager::Module)\n\nGets the results mapping\n\nArguments\n\nparams::Dict: The parameters\npath::String: The path\ndatamanager::Module: The datamanager\n\nReturns\n\noutput_mapping::Dict{Int64,Dict{}}: The results mapping\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.global_value_avg-Tuple{VecOrMat{Float64}, Union{Int64, Vector{Int64}}, AbstractVector{Int64}}","page":"IO","title":"PeriLab.IO.global_value_avg","text":"global_value_avg(field::Union{Vector{Float64},Matrix{Float64}}, dof::Union{Int64,Vector{Int64}}, nodes::AbstractVector{Int64})\n\nCalculate the global average of a field for given nodes.\n\nArguments\n\nfield::Union{Vector{Float64},Matrix{Float64}}: Field.\ndof::Union{Int64,Vector{Int64}}: Degree of freedom\nnodes::AbstractVector{Int64}: Nodes.\n\nReturns\n\nreturnValue::Vector: Global value.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.global_value_max-Tuple{VecOrMat{Float64}, Union{Int64, Vector{Int64}}, AbstractVector{Int64}}","page":"IO","title":"PeriLab.IO.global_value_max","text":"global_value_max(field::Union{Vector{Float64},Matrix{Float64}}, dof::Union{Int64,Vector{Int64}}, nodes::AbstractVector{Int64})\n\nCalculate the global maximum of a field for given nodes.\n\nArguments\n\nfield::Union{Vector{Float64},Matrix{Float64}}: Field.\ndof::Union{Int64,Vector{Int64}}: Degree of freedom\nnodes::AbstractVector{Int64}: Nodes.\n\nReturns\n\nreturnValue::Vector: Global value.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.global_value_min-Tuple{VecOrMat{Float64}, Union{Int64, Vector{Int64}}, AbstractVector{Int64}}","page":"IO","title":"PeriLab.IO.global_value_min","text":"global_value_min(field::Union{Vector{Float64},Matrix{Float64}}, dof::Union{Int64,Vector{Int64}}, nodes::AbstractVector{Int64})\n\nCalculate the global minimum of a field for given nodes.\n\nArguments\n\nfield::Union{Vector{Float64},Matrix{Float64}}: Field.\ndof::Union{Int64,Vector{Int64}}: Degree of freedom\nnodes::AbstractVector{Int64}: Nodes.\n\nReturns\n\nreturnValue::Vector: Global value.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.global_value_sum-Tuple{Union{Array{Float64, 3}, VecOrMat{Float64}}, Union{Int64, Vector{Int64}}, AbstractVector{Int64}}","page":"IO","title":"PeriLab.IO.global_value_sum","text":"global_value_sum(field::Union{Vector{Float64},Matrix{Float64}}, dof::Union{Int64,Vector{Int64}}, nodes::AbstractVector{Int64})\n\nCalculate the global sum of a field for given nodes.\n\nArguments\n\nfield::Union{Vector{Float64},Matrix{Float64}}: Field.\ndof::Union{Int64,Vector{Int64}: Degree of freedom\nnodes::AbstractVector{Int64}: Nodes.\n\nReturns\n\nreturnValue::Vector: Global value.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.hex8_volume-Tuple{Matrix{Float64}}","page":"IO","title":"PeriLab.IO.hex8_volume","text":"hex8volume(hexvertices)\n\nCalculate the volume of a hex.\n\nArguments\n\nhex_vertices: The vertices of the wedge.\n\nReturns\n\nvolume: The volume of the wedge.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.hex8_volume-Tuple{Vector{Vector{Float64}}}","page":"IO","title":"PeriLab.IO.hex8_volume","text":"hex8volume(hexvertices)\n\nCalculate the volume of a hex.\n\nArguments\n\nhex_vertices: The vertices of the wedge.\n\nReturns\n\nvolume: The volume of the wedge.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.init_data-Tuple{Dict, String, Module, MPI.Comm, TimerOutputs.TimerOutput}","page":"IO","title":"PeriLab.IO.init_data","text":"init_data(params::Dict, path::String, datamanager::Module, comm::MPI.Comm, to::TimerOutput)\n\nInitializes the data for the mesh.\n\nArguments\n\nparams::Dict: The parameters for the simulation.\npath::String: The path to the mesh file.\ndatamanager::Data_manager: The data manager.\ncomm::MPI.Comm: The MPI communicator.\nto::TimerOutput: The timer output.\n\nReturns\n\ndatamanager::Data_manager: The data manager.\nparams::Dict: The parameters for the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.init_orientations-Tuple{Module}","page":"IO","title":"PeriLab.IO.init_orientations","text":"init_orientations(datamanager::Module)\n\nInitialize orientations.\n\nArguments\n\ndatamanager::Module: The datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.init_results_in_exodus","page":"IO","title":"PeriLab.IO.init_results_in_exodus","text":"init_results_in_exodus(exo::ExodusDatabase, output::Dict{}, coords::Union{Matrix{Int64},Matrix{Float64}}, block_Id::Vector{Int64}, block_list::Vector{String}, nsets::Dict{String,Vector{Int64}}, global_ids::Vector{Int64}, PERILAB_VERSION::String)\n\nInitializes the results in exodus\n\nArguments\n\nexo::ExodusDatabase: The exodus database\noutput::Dict{String,Any}: The output\ncoords::Union{Matrix{Int64},Matrix{Float64}}: The coordinates\nblock_Id::Vector{Int64}: The block Id\nblock_list::Vector{String}: The unique blocks\nnsets::Dict{String,Vector{Int64}}: The node sets\nglobal_ids::Vector{Int64}: The global ids\n\nReturns\n\nresult_file::Dict{String,Any}: The result file\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.IO.init_write_results-Tuple{Dict, String, String, Module, String}","page":"IO","title":"PeriLab.IO.init_write_results","text":"init_write_results(params::Dict, output_dir::String, path::String, datamanager::Module, nsteps::Int64, PERILAB_VERSION::String)\n\nInitialize write results.\n\nArguments\n\nparams::Dict: The parameters\noutput_dir::String: The output directory.\npath::String: The path\ndatamanager::Module: The datamanager\nnsteps::Int64: The number of steps\n\nReturns\n\nresult_files::Array: The result files\noutputs::Dict: The outputs\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.initialize_data-Tuple{String, String, Module, MPI.Comm, TimerOutputs.TimerOutput}","page":"IO","title":"PeriLab.IO.initialize_data","text":"initialize_data(filename::String, filedirectory::String, datamanager::Module, comm::MPI.Comm, to::TimerOutputs.TimerOutput)\n\nInitialize data.\n\nArguments\n\nfilename::String: The name of the input file.\nfiledirectory::String: The directory of the input file.\ndatamanager::Module: The datamanager\ncomm::MPI.Comm: The MPI communicator\nto::TimerOutputs.TimerOutput: The TimerOutput\n\nReturns\n\ndata::Dict: The data\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.load_and_evaluate_mesh-Tuple{Dict, String, Int64, TimerOutputs.TimerOutput, Bool}","page":"IO","title":"PeriLab.IO.load_and_evaluate_mesh","text":"load_and_evaluate_mesh(params::Dict, path::String, ranksize::Int64, to::TimerOutput)\n\nLoad and evaluate the mesh data.\n\nArguments\n\nparams::Dict: The input parameters.\npath::String: The path to the mesh file.\nranksize::Int64: The number of ranks.\nto::TimerOutput: The timer output\n\nReturns\n\ndistribution::Array{Int64,1}: The distribution of the mesh elements.\nmesh::DataFrame: The mesh data as a DataFrame.\nntype::Dict: The type of the mesh elements.\noverlap_map::Array{Array{Int64,1},1}: The overlap map of the mesh elements.\nnlist::Array{Array{Int64,1},1}: The neighborhood list of the mesh elements.\ndof::Int64: The degrees of freedom (DOF) for the mesh elements.\nnsets::Dict: The node sets\ntopology::Int64::Array{Int64,nelement:nodes}`: The topology of elements.\nel_distribution::Array{Int64,1}: The distribution of the finite elements.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.local_nodes_from_dict-Tuple{Dict{Int64, Int64}, Vector{Int64}}","page":"IO","title":"PeriLab.IO.local_nodes_from_dict","text":"local_nodes_from_dict(create_global_to_local_mapping::Dict{Int,Int}, global_nodes::Vector{Int64})\n\nChanges entries in the overlap map from the global numbering to the local computer core one.\n\nArguments\n\ncreate_global_to_local_mapping::Dict{Int,Int}: global to local mapping\nglobal_nodes::Vector{Int64}: global nodes\n\nReturns\n\noverlap_map::Dict{Int64, Dict{Int64, String}}: returns overlap map with local nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.merge_exodus_file-Tuple{AbstractString}","page":"IO","title":"PeriLab.IO.merge_exodus_file","text":"merge_exodus_file(file_name::Union{AbstractString,String})\n\nMerges the exodus file\n\nArguments\n\nfile_name::Union{AbstractString,String}: The name of the file to merge\n\nReturns\n\nexo::ExodusDatabase: The exodus file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.merge_exodus_files-Tuple{Vector{Dict}, String}","page":"IO","title":"PeriLab.IO.merge_exodus_files","text":"merge_exodus_files(result_files::Vector{Any}, output_dir::String)\n\nMerges exodus output files\n\nArguments\n\nresult_files::Vector{Any}: The result files\noutput_dir::String: The file directory\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.movement-Tuple{Any, Any}","page":"IO","title":"PeriLab.IO.movement","text":"movement(cmds, dataobject)\n\nExample movement callback for G0 and G1 which calculates the total distance moved in all axes.\n\nIt is calculated by watching the X, Y and Z axes movement.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.neighbors-Tuple{DataFrames.DataFrame, Dict, Union{Vector{Int64}, Vector{String}}}","page":"IO","title":"PeriLab.IO.neighbors","text":"neighbors(mesh, params::Dict, coor)\n\nCompute the neighbor list for each node in a mesh based on their proximity using a BallTree data structure.\n\nArguments\n\nmesh: A mesh data structure containing the coordinates and other information.\nparams: paramss needed for computing the neighbor list.\ncoor: A vector of coordinate names along which to compute the neighbor list.\n\nReturns\n\nAn array of neighbor lists, where each element represents the neighbors of a node in the mesh.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.node_distribution","page":"IO","title":"PeriLab.IO.node_distribution","text":"node_distribution(nlist::Vector{Vector{Int64}}, size::Int64)\n\nCreate the distribution of the nodes.\n\nArguments\n\nnlist::Vector{Vector{Int64}}: The neighborhood list of the mesh elements.\nsize::Int64: The number of ranks.\ndistribution_type::String: The distribution type.\n\nReturns\n\ndistribution::Vector{Vector{Int64}}: The distribution of the nodes.\nptc::Vector{Int64}: Defines at which core / rank each node lies.\nntype::Dict: The type of the nodes.\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.IO.open_result_file-Tuple{Dict}","page":"IO","title":"PeriLab.IO.open_result_file","text":"open_result_file(result_file::Dict)\n\nOpens the result file\n\nArguments\n\nresult_file::Dict: The result file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.paraview_specifics-Tuple{Int64}","page":"IO","title":"PeriLab.IO.paraview_specifics","text":"paraview_specifics(dof::Int64)\n\nReturns the paraview specific dof\n\nArguments\n\ndof::Int64: The degrees of freedom\n\nReturns\n\nparaview_specifics::String: The paraview specific dof\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.parseLine","page":"IO","title":"PeriLab.IO.parseLine","text":"parseLine(line::String, returnPair::Bool = true)::Array{Union{String,Pair{String,String}},1}\n\nParse a single line of g-code and return an array of Pair{String,String} or an array of String containing the parsed commands.\n\nThe first command usually defines what to do (ie. G01 - linear interpolation) and following commands are the arguments (ie. X 14.312);\n\nExamples\n\njulia> parseLine(\"G10 X5.Y3. E6.\")\n4-element Array{Union{Pair{String,String}, String},1}:\n \"G\" => \"10\"\n \"X\" => \"5.\"\n \"Y\" => \"3.\"\n \"E\" => \"6.\"\n\nReturn array of strings\n\njulia> parseLine(\"G10 X5.Y3. E6.\", false)\n4-element Array{Union{Pair{String,String}, String},1}:\n \"G10\"\n \"X5.\"\n \"Y3.\"\n \"E6.\"\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.IO.read_external_topology-Tuple{String}","page":"IO","title":"PeriLab.IO.read_external_topology","text":"read_external_topology(filename::String)\n\nRead external topoloy data from a file and return it as a DataFrame.\n\nArguments\n\nfilename::String: The path to the mesh file.\n\nReturns\n\nexternal_topology::DataFrame: The external topology data as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.read_input-Tuple{String}","page":"IO","title":"PeriLab.IO.read_input","text":"read_input(filename::String)\n\nReads the input deck from a yaml file\n\nArguments\n\nfilename::String: The name of the yaml file\n\nReturns\n\nparams::Dict{String,Any}: The parameters read from the yaml file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.read_input_file-Tuple{String}","page":"IO","title":"PeriLab.IO.read_input_file","text":"read_input_file(filename::String)\n\nReads the input deck from a yaml file\n\nArguments\n\nfilename::String: The name of the yaml file\n\nReturns\n\nDict{String,Any}: The validated parameters read from the yaml file.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.read_mesh-Tuple{String, Dict}","page":"IO","title":"PeriLab.IO.read_mesh","text":"read_mesh(filename::String, params::Dict)\n\nRead mesh data from a file and return it as a DataFrame.\n\nArguments\n\nfilename::String: The path to the mesh file.\nparams::Dict: The input parameters.\n\nReturns\n\nmesh::DataFrame: The mesh data as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.rectangular_plane_filter-Tuple{Int64, Matrix{Float64}, Dict, Vector{Vector{Int64}}, Int64}","page":"IO","title":"PeriLab.IO.rectangular_plane_filter","text":"rectangular_plane_filter(nnodes::Int64, data::Matrix{Float64}, filter::Dict, nlist::Vector{Vector{Int64}}, dof::Int64)\n\nApply the rectangular plane filter to the neighborhood list.\n\nArguments\n\nnnodes::Int64: The number of nodes.\ndata::Matrix{Float64}: The data.\nfilter::Dict: The filter.\nnlist::Vector{Vector{Int64}}: The neighborhood list.\ndof::Int64: The degrees of freedom.\n\nReturns\n\nfilter_flag::Vector{Bool}: The filter flag.\nnormal::Vector{Float64}: The normal vector of the disk.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.set_dof-Tuple{DataFrames.DataFrame}","page":"IO","title":"PeriLab.IO.set_dof","text":"set_dof(mesh::DataFrame)\n\nSet the degrees of freedom (DOF) for the mesh elements.\n\nArguments\n\nmesh::DataFrame: The input mesh data represented as a DataFrame.\n\nReturns\n\ndof::Int64: The degrees of freedom (DOF) for the mesh elements.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.set_output_frequency","page":"IO","title":"PeriLab.IO.set_output_frequency","text":"set_output_frequency(params::Dict, datamanager::Module, nsteps::Int64, step_id::Int64)\n\nSets the output frequency.\n\nArguments\n\nparams::Dict: The parameters\ndatamanager::Module: The datamanager\nnsteps::Int64: The number of steps\nstep_id::Int64: The step id\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.IO.show_block_summary-Tuple{Dict, Dict, String, Bool, MPI.Comm, Module}","page":"IO","title":"PeriLab.IO.show_block_summary","text":"show_block_summary(solver_options::Dict, params::Dict, log_file::String, silent::Bool, comm::MPI.Comm, datamanager::Module)\n\nShow block summary.\n\nArguments\n\nsolver_options::Dict: The solver options\nparams::Dict: The params\nlog_file::String: The log file\nsilent::Bool: The silent flag\ncomm::MPI.Comm: The comm\ndatamanager::Module: The datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.show_mpi_summary-Tuple{String, Bool, MPI.Comm, Module}","page":"IO","title":"PeriLab.IO.show_mpi_summary","text":"show_mpi_summary(log_file::String, silent::Bool, comm::MPI.Comm, datamanager::Module)\n\nShow MPI summary.\n\nArguments\n\nlog_file::String: The log file\nsilent::Bool: The silent flag\ncomm::MPI.Comm: The comm\ndatamanager::Module: The datamanager\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.stripComments-Tuple{String}","page":"IO","title":"PeriLab.IO.stripComments","text":"stripComments(line::String)::String\n\nReturn a copy of string line with stripped comments inside parentheses and all characters after a semicolon.\n\nThis function also removes whitespace as it it not needed for further parsing.\n\nExamples\n\njulia> stripComments(\"G92 (G10(aaa)))) ((comment)G) Z0.2 ; this is a comment\")\n\"G92Z0.2\"\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.tetrahedron_volume-Tuple{Matrix{Float64}}","page":"IO","title":"PeriLab.IO.tetrahedron_volume","text":"tetrahedron_volume(tet_vertices)\n\nCalculate the volume of a tetrahedron.\n\nArguments\n\ntet_vertices: The vertices of the tetrahedron.\n\nReturns\n\nvolume: The volume of the tetrahedron.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.tetrahedron_volume-Tuple{Vector{Vector{Float64}}}","page":"IO","title":"PeriLab.IO.tetrahedron_volume","text":"tetrahedron_volume(tet_vertices)\n\nCalculate the volume of a tetrahedron.\n\nArguments\n\ntet_vertices: The vertices of the tetrahedron.\n\nReturns\n\nvolume: The volume of the tetrahedron.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.wedge6_volume-Tuple{Vector{Vector{Float64}}}","page":"IO","title":"PeriLab.IO.wedge6_volume","text":"wedge6_volume(wedge_vertices)\n\nCalculate the volume of a wedge.\n\nArguments\n\nwedge_vertices: The vertices of the wedge.\n\nReturns\n\nvolume: The volume of the wedge.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.write_global_results_in_csv-Tuple{IOStream, Float64, Any}","page":"IO","title":"PeriLab.IO.write_global_results_in_csv","text":"write_global_results_in_csv(csv_file::IOStream, time::Float64, global_values)\n\nWrites the global results to the csv file\n\nArguments\n\ncsv_file::IOStream: The csv file\nglobal_values: The global values\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.write_global_results_in_exodus-Tuple{Exodus.ExodusDatabase, Int64, Any}","page":"IO","title":"PeriLab.IO.write_global_results_in_exodus","text":"write_global_results_in_exodus(exo::ExodusDatabase, step::Int64, global_values)\n\nWrites the global results in the exodus file\n\nArguments\n\nexo::ExodusDatabase: The exodus file\nstep::Int64: The step\nglobal_values: The global values\n\nReturns\n\nexo::ExodusDatabase: The exodus file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.write_nodal_results_in_exodus-Tuple{Exodus.ExodusDatabase, Int64, Dict, Module}","page":"IO","title":"PeriLab.IO.write_nodal_results_in_exodus","text":"write_nodal_results_in_exodus(exo::ExodusDatabase, step::Int64, output::Dict, datamanager::Module)\n\nWrites the nodal results in the exodus file\n\nArguments\n\nexo::ExodusDatabase: The exodus file\nstep::Int64: The step\noutput::Dict: The output\ndatamanager::Module: The datamanager\n\nReturns\n\nexo::ExodusDatabase: The exodus file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.write_results-Tuple{Vector{Dict}, Float64, Float64, Dict, Module}","page":"IO","title":"PeriLab.IO.write_results","text":"write_results(result_files::Vector{Any}, time::Float64, max_damage::Float64, outputs::Dict, datamanager::Module)\n\nWrite results.\n\nArguments\n\nresult_files::Vector{Any}: The result files\ntime::Float64: The time\nmax_damage::Float64: The maximum damage\noutputs::Dict: The outputs\ndatamanager::Module: The datamanager\n\nReturns\n\nresult_files::Vector{Any}: The result files\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.write_step_and_time-Tuple{Exodus.ExodusDatabase, Int64, Float64}","page":"IO","title":"PeriLab.IO.write_step_and_time","text":"write_step_and_time(exo::ExodusDatabase, step::Int64, time::Float64)\n\nWrites the step and time in the exodus file\n\nArguments\n\nexo::ExodusDatabase: The exodus file\nstep::Int64: The step\ntime::Float64: The time\n\nReturns\n\nexo::ExodusDatabase: The exodus file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#parameter_handling","page":"IO","title":"parameter_handling","text":"","category":"section"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling._get_values","page":"IO","title":"PeriLab.IO.Parameter_Handling._get_values","text":"_get_values(params::Dict, block_id::Int64, valueName::String, defaultValue::Union{Float64,Bool,Nothing})\n\nGet the value of a block.\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: The ID of the block\nvalueName::String: The name of the value\ndefaultValue::Union{Float64,Bool,Nothing: The default value\n\nReturns\n\nvalue::Float64: The value of the block\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.check_for_duplicates-Tuple{Vector{String}}","page":"IO","title":"PeriLab.IO.Parameter_Handling.check_for_duplicates","text":"check_for_duplicates(filenames)\n\nCheck for duplicate filenames.\n\nArguments\n\nfilenames::Vector{String}: The filenames\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_all_keys-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_all_keys","text":"get_all_keys(params::Dict)\n\nGet all the keys in the parameters\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nkeys_list::Array: The keys list\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_angles-Tuple{Dict, Int64, Int64}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_angles","text":"get_angles(params::Dict, block_id::Int64, dof::Int64)\n\nGet the horizon of a block.\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: The ID of the block\ndof::Int64: The dof\n\nReturns\n\nangles::Float64: The angles of the block\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_bc_definitions-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_bc_definitions","text":"get_bc_definitions(params::Dict)\n\nGet the boundary condition definitions\n\nArguments\n\nparams::Dict: The parameters\n\nReturns\n\nbcs::Dict{String,Any}: The boundary conditions\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_block_names_and_ids-Tuple{Dict, Vector{Int64}, Bool}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_block_names_and_ids","text":"get_block_names_and_ids(params::Dict, block_ids::Vector{Int64})\n\nGet the names of the blocks.\n\nArguments\n\nparams::Dict: The parameters dictionary.\nblock_ids::Vector{Int64}: The IDs of the blocks\n\nReturns\n\nblock_names::Vector{String}: The names of the blocks.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_bond_filters-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_bond_filters","text":"get_bond_filters(params::Dict)\n\nReturns the bond filters from the parameters\n\nArguments\n\nparams::Dict: The parameters\n\nReturns\n\ncheck::Bool: Whether the bond filters are defined\nbfList::Dict{String,Dict{String,Any}}: The bond filters\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_calculation_options-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_calculation_options","text":"get_calculation_options(params::Dict)\n\nGet the calculation options\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nsolver_options::Dict: The solver options\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_computes-Tuple{Dict, Vector{String}}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_computes","text":"get_computes(params::Dict, variables::Vector{String})\n\nGet the computes.\n\nArguments\n\nparams::Dict: The parameters dictionary.\nvariables::Vector{String}: The variables.\n\nReturns\n\ncomputes::Dict{String,Dict{Any,Any}}: The computes.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_computes_names-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_computes_names","text":"get_computes_names(params::Dict)\n\nGet the names of the computes.\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\ncomputes_names::Vector{String}: The names of the computes.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_density-Tuple{Dict, Int64}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_density","text":"get_density(params::Dict, block_id::Int64)\n\nGet the density of a block.\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: The ID of the block\n\nReturns\n\ndensity::Float64: The density of the block\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_end_time-Tuple{Dict, String}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_end_time","text":"get_end_time(outputs::Dict, output::String)\n\nGet the end_time.\n\nArguments\n\noutputs::Dict: The outputs\noutput::String: The output\n\nReturns\n\nend_time::Float64: The value\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_external_topology_name-Tuple{Dict, Any}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_external_topology_name","text":"get_external_topology_name(params::Dict, path)\n\nReturns the name of the mesh file from the parameters\n\nArguments\n\nparams::Dict: The parameters\npath::String: Path of the working folder\n\nReturns\n\nString: The name of the finite element topology file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_fem_block-Tuple{Dict, Int64}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_fem_block","text":"get_fem_block(params::Dict, block_id::Int64)\n\nGet the fem_block of a block.\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: The ID of the block\n\nReturns\n\nfem_block::Float64: The fem_block of the block\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_final_time-Tuple{Dict, Module}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_final_time","text":"get_final_time(params::Dict)\n\nGet the final time\n\nArguments\n\nparams::Dict: The parameters dictionary.\ndatamanager::Module: The data manager module\n\nReturns\n\nfinal_time::Float64: The final time\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_fixed_dt-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_fixed_dt","text":"get_fixed_dt(params::Dict)\n\nGet the fixed time step\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nfixed_dt::Float64: The fixed time step\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_flush_file-Tuple{Dict, String}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_flush_file","text":"get_flush_file(outputs::Dict, output::String)\n\nGets the flush file.\n\nArguments\n\noutputs::Dict: The outputs\noutput::String: The output\n\nReturns\n\nflush_file::Bool: The flush file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_header-Tuple{AbstractString}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_header","text":"get_header(filename::Union{String,AbstractString})\n\nReturns the header line and the header.\n\nArguments\n\nfilename::Union{String,AbstractString}: The filename of the file.\n\nReturns\n\nheader_line::Int: The header line.\nheader::Vector{String}: The header.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_heat_capacity-Tuple{Dict, Int64}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_heat_capacity","text":"get_heat_capacity(params::Dict, block_id::Int64)\n\nGet the heat capacity of a block.\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: The ID of the block\n\nReturns\n\nheat_capacity::Float64: The heat capacity of the block\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_horizon-Tuple{Dict, Int64}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_horizon","text":"get_horizon(params::Dict, block_id::Int64)\n\nGet the horizon of a block.\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: The ID of the block\n\nReturns\n\nhorizon::Float64: The horizon of the block\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_initial_time-Tuple{Dict, Module}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_initial_time","text":"get_initial_time(params::Dict, datamanager::Module)\n\nGet the initial time\n\nArguments\n\nparams::Dict: The parameters dictionary.\ndatamanager::Module: The data manager module\n\nReturns\n\ninitial_time::Float64: The initial time\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_max_damage-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_max_damage","text":"getmaxdamage(params::Dict)\n\nGet the maximum damage.\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nmax_damage::Float64: The value\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_mesh_name-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_mesh_name","text":"get_mesh_name(params::Dict)\n\nReturns the name of the mesh file from the parameters\n\nArguments\n\nparams::Dict: The parameters\n\nReturns\n\nString: The name of the mesh file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_model_options-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_model_options","text":"get_model_options(params::Dict)\n\nGet the solver options\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nsolver_options::Dict: The solver options\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_model_parameter","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_model_parameter","text":"get_model_parameter(params, model, id)\n\nRetrieve a model parameter from a dictionary of parameters.\n\nThis function retrieves a specific model parameter from a dictionary of parameters based on the provided model and identifier (id).\n\nArguments\n\nparams::Dict: A dictionary containing various parameters.\nmodel::String: The model type for which the parameter is sought.\nid::String: The identifier (name) of the specific model parameter.\n\nReturns\n\nparameter::Any: The retrieved model parameter, or nothing if the parameter is not found.\n\nErrors\n\nIf the specified model is defined in blocks but no model definition block exists, an error message is logged, and the function returns nothing.\nIf the model with the given identifier is defined in blocks but missing in the model's definition, an error message is logged, and the function returns nothing.\n\nExample\n\n```julia params = Dict(     \"Models\" => Dict(         \"Models\" => Dict(             \"ModelA\" => 42,             \"ModelB\" => 24         )     ) )\n\nmodel = \"Models\" id = \"ModelA\"\n\nresult = getmodelparameter(params, model, id) if result !== nothing     println(\"Parameter id: result\") else     println(\"Parameter not found.\") end\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_node_sets-Tuple{Dict, String, DataFrames.DataFrame}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_node_sets","text":"get_node_sets(params::Dict, path::String)\n\nReturns the node sets from the parameters\n\nArguments\n\nparams::Dict: The parameters\npath::String: The path to the mesh file\n\nReturns\n\nnsets::Dict{String,Any}: The node sets\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_nsteps-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_nsteps","text":"get_nsteps(params::Dict)\n\nGet the fixed time step\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nnsteps::Int64: The fixed time step\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_numerical_damping-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_numerical_damping","text":"get_numerical_damping(params::Dict)\n\nGet the numerical damping\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nnumerical_damping::Float64: The numerical damping\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_output_fieldnames-Tuple{Dict, Vector{String}, Vector{String}, String}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_output_fieldnames","text":"get_output_fieldnames(outputs::Dict, variables::Vector{String}, computes::Vector{String}, output_type::String)\n\nGets the output fieldnames.\n\nArguments\n\noutputs::Dict: The outputs\nvariables::Vector{String}: The variables\ncomputes::Vector{String}: The computes\noutput_type::String: The output type\n\nReturns\n\noutput_fieldnames::Vector{String}: The output fieldnames\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_output_filenames-Tuple{Dict, String}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_output_filenames","text":"get_output_filenames(params::Dict, output_dir::String)\n\nGets the output filenames.\n\nArguments\n\nparams::Dict: The parameters\noutput_dir::String: The file directory\n\nReturns\n\nfilenames::Vector{String}: The filenames\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_output_frequency-Tuple{Dict, Int64}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_output_frequency","text":"get_output_frequency(params::Dict, nsteps::Int64)\n\nGets the output frequency.\n\nArguments\n\nparams::Dict: The parameters\nnsteps::Int64: The number of steps\n\nReturns\n\nfreq::Vector{Int64}: The output frequency\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_output_type-Tuple{Dict, String}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_output_type","text":"get_output_type(outputs::Dict, output::String)\n\nGets the output type.\n\nArguments\n\noutputs::Dict: The outputs\noutput::String: The output\n\nReturns\n\noutput_type::String: The output type\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_output_variables-Tuple{String, Vector{String}}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_output_variables","text":"get_output_variables(output::String, variables::Vector{String})\n\nGet the output variable.\n\nArguments\n\noutput::String: The output variable.\nvariables::Vector{String}: The variables.\n\nReturns\n\noutput::String: The output variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_outputs-Tuple{Dict, Vector{String}, Vector{String}}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_outputs","text":"get_outputs(params::Dict, variables::Vector{String}, compute_names::Vector{String})\n\nGets the outputs.\n\nArguments\n\nparams::Dict: The parameters\nvariables::Vector{String}: The variables\ncompute_names::Vector{String}: The compute names\n\nReturns\n\noutputs::Dict: The outputs\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_safety_factor-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_safety_factor","text":"get_safety_factor(params::Dict)\n\nGet the safety factor\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nsafety_factor::Float64: The safety factor\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_solver_name-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_solver_name","text":"get_solver_name(params::Dict)\n\nGet the name of the solver\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nsolver_name::String: The name of the solver\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_solver_params-Tuple{Dict, Any}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_solver_params","text":"get_solver_params(params::Dict)\n\nGet the solver parameters\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nsolver_params::Dict: The solver parameters\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_solver_steps-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_solver_steps","text":"get_solver_steps(params::Dict)\n\nGet the solver steps\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nsolver_steps::List: The solver steps\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_start_time-Tuple{Dict, String}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_start_time","text":"get_start_time(outputs::Dict, output::String)\n\nGet the start_time.\n\nArguments\n\noutputs::Dict: The outputs\noutput::String: The output\n\nReturns\n\nstart_time::Float64: The value\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.get_write_after_damage-Tuple{Dict, String}","page":"IO","title":"PeriLab.IO.Parameter_Handling.get_write_after_damage","text":"get_write_after_damage(outputs::Dict, output::String)\n\nGet the write after damage.\n\nArguments\n\noutputs::Dict: The outputs\noutput::String: The output\n\nReturns\n\nwrite_after_damage::Bool: The value\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.validate_structure_recursive","page":"IO","title":"PeriLab.IO.Parameter_Handling.validate_structure_recursive","text":"validate_structure_recursive(expected::Dict, actual::Dict, validate::Bool, checked_keys::Array, path::String=\"\")\n\nValidates the parameters against the expected structure\n\nArguments\n\nexpected::Dict: The expected structure\nactual::Dict: The actual structure\nvalidate::Bool: The validation results\nchecked_keys::Array: The keys that have been checked\npath::String: The current path\n\nReturns\n\nvalidate::Bool: The validation result\nchecked_keys::Array: The keys that have been checked\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.IO.Parameter_Handling.validate_yaml-Tuple{Dict}","page":"IO","title":"PeriLab.IO.Parameter_Handling.validate_yaml","text":"validate_yaml(params::Dict)\n\nValidates the parameters against the expected structure\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nparams::Dict: The parameters dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/","page":"IO","title":"IO","text":"","category":"page"},{"location":"lib/geometry_functions/#IO-Functions","page":"Geometry","title":"IO - Functions","text":"","category":"section"},{"location":"lib/geometry_functions/#Index","page":"Geometry","title":"Index","text":"","category":"section"},{"location":"lib/geometry_functions/","page":"Geometry","title":"Geometry","text":"Pages = [\"geometry_functions.md\"]","category":"page"},{"location":"lib/geometry_functions/#Geometry","page":"Geometry","title":"Geometry","text":"","category":"section"},{"location":"lib/geometry_functions/","page":"Geometry","title":"Geometry","text":"```@autodocs Modules = [IO.Geometry] Order   = [:function, :type]","category":"page"},{"location":"lib/geometry_functions/","page":"Geometry","title":"Geometry","text":"","category":"page"},{"location":"theory/theory/#Theory-manual","page":"Basics","title":"Theory manual","text":"","category":"section"},{"location":"theory/theory/#Peridynamic-theory","page":"Basics","title":"Peridynamic theory","text":"","category":"section"},{"location":"theory/theory/","page":"Basics","title":"Basics","text":"The theory manual condenses the implemented features.","category":"page"},{"location":"theory/theory/","page":"Basics","title":"Basics","text":"Peridynamics is an integral continuum mechanics formulation. For a pure mechanical description it can be formulated as:","category":"page"},{"location":"theory/theory/","page":"Basics","title":"Basics","text":"int_mathcalHunderlinemathbfTlanglemathbfxtrangle-underlinemathbfTlanglemathbfxtrangle dV- mathbfb=rhoddotmathbfu","category":"page"},{"location":"theory/theory/","page":"Basics","title":"Basics","text":"The parameters are:","category":"page"},{"location":"theory/theory/","page":"Basics","title":"Basics","text":"Parameter Name\nmathcalH Neighborhood [-]\nV Volume [m^3]\nmathbfx Position of point [m]\nmathbfx Position of neighbor [m]\nt Time [s]\nmathbfb Body force densities [Nm^3]\nmathbfu Displacements [m]\nddotmathbfu Accelerations [ms^2]\nunderlinemathbfT Force density state [Nm^6]\nrho Mass density [kgm^3]","category":"page"},{"location":"theory/theory/","page":"Basics","title":"Basics","text":"To solve this three main types of formulations are usable; bond-based, ordinary state-based and non-ordinary state-based.","category":"page"},{"location":"theory/theory/","page":"Basics","title":"Basics","text":"Method Related Model in PeriLab\nBond-based Bond-based Elastic\nOrdinary state-based PD Solid Elastic PD Solid Plastic\nNon-ordinary state-based Correspondence Elastic Correspondence Plastic\nBond-associated correspondence \nUnified bond-based ","category":"page"},{"location":"theory/theory/#Finite-element-theory","page":"Basics","title":"Finite element theory","text":"","category":"section"},{"location":"theory/theory/","page":"Basics","title":"Basics","text":"Finite elements are used to model boundary conditions or to be computational more efficient. PeriLab is no FEM code. Within the theory manual the basic theory and the FEM-PD coupling methods are presented.","category":"page"},{"location":"theory/theory/","page":"Basics","title":"Basics","text":"","category":"page"},{"location":"man/dev/developement_guide/#Development-Guide","page":"Guide","title":"Development Guide","text":"","category":"section"},{"location":"man/dev/developement_guide/","page":"Guide","title":"Guide","text":"PeriLab is design to be extentable. Modules can be integrated with the so called factory modules. These modules are the interfaces to the higher functions.","category":"page"},{"location":"man/dev/developement_guide/","page":"Guide","title":"Guide","text":"info: Example\nThe solver calls compute_forces as a function. This function is integrated in the Material module. Within this module the relevant material model is integrated, using the set_modules module","category":"page"},{"location":"man/dev/developement_guide/#Model-structure","page":"Guide","title":"Model structure","text":"","category":"section"},{"location":"man/dev/developement_guide/","page":"Guide","title":"Guide","text":"PeriLab is structured in different ''Models''. These models are included in the model factory and split in two main parts. An init and compute part. All memory, parameter check, etc. takes place in the init phase. The computation should run without thowing warnings or errors due to input variable errors.","category":"page"},{"location":"man/dev/developement_guide/","page":"Guide","title":"Guide","text":"If you plan large scale implemention please contact us.","category":"page"},{"location":"man/dev/developement_guide/#Guidelines","page":"Guide","title":"Guidelines","text":"","category":"section"},{"location":"man/dev/developement_guide/","page":"Guide","title":"Guide","text":"try to fix the type of the variables in functions\nuse self explaining variables and functions\nwrite tests\nfull scale tests should check whole models and their interaction in the software\nunit tests should test exceptions and key features\ninputs are checked in the init part of models not during run time\nin code documentation in front of functions\ntheory and extensive model explainations in the documentation\nwrite issues\nask for help\nhave fun :)","category":"page"},{"location":"man/dev/developement_guide/","page":"Guide","title":"Guide","text":"info: References\nIf you are part of the developer or user of PeriLab feel free to use your references to improve the documentation. Especially for publications created with PeriLab.","category":"page"},{"location":"man/dev/developement_guide/","page":"Guide","title":"Guide","text":"","category":"page"},{"location":"man/dev/datamanager/#Datamanager","page":"Datamanager","title":"Datamanager","text":"","category":"section"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"The datamanager is a central part of PeriLab. You can create fields as you need them. ","category":"page"},{"location":"man/dev/datamanager/#Create-constant-node-fields","page":"Datamanager","title":"Create constant node fields","text":"","category":"section"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"Constant node fields are fields with the length of the number of nodes. It return one vector of type Type_of_variable. ","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"field = datamanager.create_constant_node_field(Fieldname::String, Type_of_variable::Type, Degree_of_freedom::Int64)","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"You can get constant fields  ","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"field = datamanager.get_field(Fieldname::String)","category":"page"},{"location":"man/dev/datamanager/#Create-non-constant-node-fields","page":"Datamanager","title":"Create non-constant node fields","text":"","category":"section"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"Non-constant node fields are fields with the length of the number of nodes. Each node could have any degree of freedom.  You will get a field with N and N+1 created it by this command","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"fieldN, fieldNP1 = datamanager.create_node_field(Fieldname::String, Type_of_variable::Type, Degree_of_freedom::Int64)","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"info: Switch values\nThe non-constant fields are switched automatically at the end of each time integration step. At the beginning of the next step NP1 is zero, wheras N is the NP1 from the previous step.","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"You can get non-constant fields as   ","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"fieldN = datamanager.get_field(Fieldname::String, \"N\")\nfieldNP1 = datamanager.get_field(Fieldname::String, \"NP1\")\nfieldN = datamanager.get_field(Fieldname*\"N\"::String)\nfieldNP1 = datamanager.get_field(Fieldname*\"NP1\"::String)","category":"page"},{"location":"man/dev/datamanager/#Create-constant-bond-fields","page":"Datamanager","title":"Create constant bond fields","text":"","category":"section"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"Constant bond fields are fields with the length of the number of nodes. Each node has a vector of lenght number of neighbors or bonds with a defined degree of freedom. It return one vector of type Type_of_variable.","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"field = datamanager.create_constant_node_field(Fieldname::String, Type_of_variable::Type, Degree_of_freedom::Int64)","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"You can get constant fields  ","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"field = datamanager.get_field(Fieldname::String)","category":"page"},{"location":"man/dev/datamanager/#Create-non-constant-bond-fields","page":"Datamanager","title":"Create non-constant bond fields","text":"","category":"section"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"Non-constant node fields are fields with the length of the number of nodes. Each node has a vector of lenght number of neighbors or bonds with a defined degree of freedom.  You will get a field of type Type_of_variable with N and N+1 created it by this command","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"fieldN, fieldNP1 = datamanager.create_bond_field(Fieldname::String, Type_of_variable::Type, Degree_of_freedom::Int64)","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"info: Switch values\nThe non-constant fields are switched automatically at the end of each time integration step. At the beginning of the next step NP1 is zero, wheras N is the NP1 from the previous step.","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"You can get non-constant fields as   ","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"fieldN = datamanager.get_field(Fieldname::String, \"N\")\nfieldNP1 = datamanager.get_field(Fieldname::String, \"NP1\")\nfieldN = datamanager.get_field(Fieldname*\"N\"::String)\nfieldNP1 = datamanager.get_field(Fieldname*\"NP1\"::String)","category":"page"},{"location":"man/dev/datamanager/#Other-Options","page":"Datamanager","title":"Other Options","text":"","category":"section"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"For node and bond fields (constant and non-constant) the following options are possible.","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"Matrix style","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"You can switch between vector and matrix. If you give the keyword MatrixorVector = \"Vector\" you get vector of length degree of freedom for each node or bond. If MatrixorVector = \"Matrix\" each node or bond gets matrix dof times dof","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"datamanager.create_node_field(Fieldname::String, Type_of_variable::Type, Matrix_or_Vector::String, Degree_of_freedom::Int64)","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"Pre-defined Values","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"You can add an optional value at the end. The default is zero.","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"datamanager.create_node_field(Fieldname::String, Type_of_variable::Type, Degree_of_freedom::Int64, Value::Type_of_variable)","category":"page"},{"location":"man/dev/datamanager/#Create-free-size-fields","page":"Datamanager","title":"Create free size fields","text":"","category":"section"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"Free size fields can be constant or non-constant. The size is defined by the user and must be a tuple. The field dimension is chosen by the user.","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":" field = datamanager.create_constant_free_size_field(Fieldname::String, Type_of_variable::Type, size::Tuple)\n fieldN, fieldNP1 = datamanager.create_free_size_field(Fieldname::String, Type_of_variable::Type, size::Tuple)","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"info: free size example\nA constant node field with a matrix 3times3 per node can be defined in a free size field by","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"field = datamanager.create_constant_free_size_field(\"Example\", Float64, (number_of_nodes, 3, 3))","category":"page"},{"location":"man/dev/datamanager/","page":"Datamanager","title":"Datamanager","text":"","category":"page"},{"location":"man/input_yaml/#PeriLab-Configuration-File","page":"Input File","title":"PeriLab Configuration File","text":"","category":"section"},{"location":"man/input_yaml/","page":"Input File","title":"Input File","text":"The PeriLab configuration file is a YAML file used to specify the parameters for running simulations in the PeriLab software. This structure represents the global configuration for PeriLab.","category":"page"},{"location":"man/input_yaml/","page":"Input File","title":"Input File","text":"The information is stored in the params dictionary","category":"page"},{"location":"man/input_yaml/#PeriLab","page":"Input File","title":"PeriLab","text":"","category":"section"},{"location":"man/input_yaml/","page":"Input File","title":"Input File","text":"Blocks: List of block configurations.\nblock_id: Block-specific parameters.\nDensity: Numeric value representing density. (Float64 or Int64)\nHorizon: Numeric value representing horizon. (Float64 or Int64)\nSpecific Heat Capacity: Numeric value representing specific heat capacity. (Float64 or Int64, optional)\nMaterial Model: String representing the material model. (optional)\nDamage Model: String representing the damage model. (optional)\nThermal Model: String representing the thermal model. (optional)\nAdditive Model: String representing the additive model. (optional)\nPre Calculation Model: String representing the pre-calculation model. (optional)\nAngle X: Numeric value representing angle in X direction. (Float64 or Int64, optional)\nAngle Y: Numeric value representing angle in Y direction. (Float64 or Int64, optional)\nAngle Z: Numeric value representing angle in Z direction. (Float64 or Int64, optional)","category":"page"},{"location":"man/input_yaml/#FEM-(optional)","page":"Input File","title":"FEM (optional)","text":"","category":"section"},{"location":"man/input_yaml/","page":"Input File","title":"Input File","text":"Element Type: String representing the type of finite element.\nDegree: Numeric value representing the degree. (String or Int64)\nMaterial Model: String representing the material model.\nCoupling: Coupling parameters. (optional)\nCoupling Type: String representing the type of coupling.","category":"page"},{"location":"man/input_yaml/#Boundary-Conditions-(optional)","page":"Input File","title":"Boundary Conditions (optional)","text":"","category":"section"},{"location":"man/input_yaml/","page":"Input File","title":"Input File","text":"Own_Name: List of boundary condition configurations.\nCoordinate: String representing the coordinate.\nNode Set: String representing the node set.\nVariable: String representing the variable.\nType: String representing the type of boundary condition.\nValue: Numeric value, string, or a combination representing the boundary condition value. (Float64, Int64, String)","category":"page"},{"location":"man/input_yaml/#Compute-Class-Parameters-(optional)","page":"Input File","title":"Compute Class Parameters (optional)","text":"","category":"section"},{"location":"man/input_yaml/","page":"Input File","title":"Input File","text":"Own_Name: List of compute class parameters.\nBlock: String representing the block.\nNode Set: String representing the node set.\nCalculation Type: String representing the calculation type.\nCompute Class: String representing the compute class.\nVariable: String representing the variable.","category":"page"},{"location":"man/input_yaml/#Discretization","page":"Input File","title":"Discretization","text":"","category":"section"},{"location":"man/input_yaml/","page":"Input File","title":"Input File","text":"Input Mesh File: String representing the input mesh file.\nInput External Topology: External topology parameters. (optional)\nFile: String representing the external topology file.\nAdd Neighbor Search: Boolean indicating whether to add neighbor search. (optional)\nNode Sets: Dictionary of node sets. (optional)\nOwn_Name: Numeric value or string representing the node set. (Int64 or String)\nType: String representing the type of discretization.\nDistribution Type: String representing the distribution type. (optional)\nBond Filters: List of bond filter configurations. (optional)\nOwn_Name: Bond filter parameters.\nType: String representing the bond filter type.\nNormal X/Y/Z: Numeric values representing normal components. (Float64 or Int64)\nLower Left Corner X/Y/Z: Numeric values representing lower-left corner components. (Float64 or Int64)\nBottom Unit Vector X/Y/Z: Numeric values representing bottom unit vector components. (Float64 or Int64)\nCenter X/Y/Z: Numeric values representing center components. (Float64 or Int64)\nRadius: Numeric value representing the radius. (Float64 or Int64)\nBottom Length: Numeric value representing the bottom length. (Float64 or Int64)\nSide Length: Numeric value representing the side length. (Float64 or Int64)\nAllow Contact: Boolean indicating whether to allow contact. (optional)\nSurface Extrusion: Surface extrusion parameters. (optional)\nDirection: String representing surface extrusion direction (e.g., 'X', or 'Y').\nStep_X/Y/Z: Numeric values representing step components for surface extrusion direction (Float64 or Int64).","category":"page"},{"location":"man/input_yaml/#Outputs-(optional)","page":"Input File","title":"Outputs (optional)","text":"","category":"section"},{"location":"man/input_yaml/","page":"Input File","title":"Input File","text":"Own_Name: List of output configurations.\nFlush File: Boolean indicating whether to flush the output file. (optional)\nOutput Frequency: Integer representing the output frequency.\nNumber of Output Steps: Integer representing the number of output steps.\nOutput File Type: String representing the output file type. (optional)\nOutput Filename: String representing the output filename.\nWrite After Damage: Boolean indicating whether to write after damage. (optional)\nOutput Variables: Dictionary of output variables.\nOwn_Name: Boolean indicating whether to output the variable.","category":"page"},{"location":"man/input_yaml/#Models-(optional)","page":"Input File","title":"Models (optional)","text":"","category":"section"},{"location":"man/input_yaml/","page":"Input File","title":"Input File","text":"Damage Models: Dictionary of damage models. (optional)\nOwn_Name: List of damage model configurations.\nCritical Value: Numeric value representing the critical value. (Float64 or Int64)\nDamage Model: String representing the damage model.\nInterblock Damage: Dictionary of interblock damage parameters.\nInterblock Critical Value: Numeric value representing interblock damage. (Float64 or Int64, required)\nAnisotropic Damage: Dictionary of anisotropic damage parameters.\nCritical Value X/Y: Numeric values representing critical values in X and Y directions. (Float64 or Int64, required)\nMaterial Models: Dictionary of material models. (optional)\nOwn_Name: List of material model configurations.\nMaterial Model: String representing the material model.\nSymmetry: String representing the symmetry. (optional)\nPoisson's Ratio/Young's Modulus/Bulk Modulus/Shear Modulus: Numeric values representing material properties. (Float64 or Int64, optional)\nYield Stress: Numeric value representing the yield stress. (Float64 or Int64, optional)\nZero Energy Control: String representing zero energy control. (optional)\nC11/C12/.../C66: Numeric values representing material constants. (Float64 or Int64, optional)\nThermal Models: Dictionary of thermal models. (optional)\nOwn_Name: List of thermal model configurations.\nThermal Model: String representing the thermal model.\nType: String representing the type of thermal model. (optional)\nHeat Transfer Coefficient/Environmental Temperature/Thermal Conductivity/Thermal Expansion Coefficient/Thermal Conductivity Print Bed/Print Bed Temperature: Numeric values representing thermal parameters. (Float64 or Int64, optional)\nAdditive Models: Dictionary of additive models. (optional)\nOwn_Name: List of additive model configurations.\nAdditive Model: String representing the additive model.\nPrint Temperature: Numeric value representing the print temperature. (Float64 or Int64, optional)\nPre Calculation Models: Dictionary of pre-calculation models. (optional)\nOwn_Name : List of pre calculation model configurations.. (optional).\nBond Associated Deformation Gradient/Deformation Gradient/Deformed Bond Geometry/Shape Tensor: Boolean values indicating whether to calculate the respective parameter. (optional)\nPre Calculation Global: Dictionary of pre-calculation parameters.\nBond Associated Deformation Gradient/Deformation Gradient/Deformed Bond Geometry/Shape Tensor: Boolean values indicating whether to calculate the respective parameter. (optional)","category":"page"},{"location":"man/input_yaml/#Solver","page":"Input File","title":"Solver","text":"","category":"section"},{"location":"man/input_yaml/","page":"Input File","title":"Input File","text":"Additive Models/Material Models/Damage Models/Thermal Models/Pre Calculation Models: Boolean values indicating whether to solve for the respective components. (optional)\nCalculate Cauchy: Boolean values indicating whether to calculate Cauchy stresses for deformation gradient and shape tensor calculations (optional).\nCalculate von Mises: Boolean values indicating whether to calculate von Mises stresses for deformation gradient and shape tensor calculations (optional).\nCalculate Strain : Boolean values indicating whether to calculate strain for deformation gradient and shape tensor calculations (optional).\nMaximum Damage: Numeric value representing the maximum damage. (Float64, optional)\nFinal Time/Initial Time: Numeric values representing the final and initial time. (Float64 or Int64, required)\nFixed dt/Number of Steps: Numeric values defining the step width. (Float64 or Int64, optional)\nVerlet: Dictionary of Verlet solver parameters.\nSafety Factor: Numeric values representing Verlet solver parameters. (Float64 or Int64, optional)\nNumerical Damping: Numeric value representing numerical damping. (Float64 or Int64, optional)\nStatic: Dictionary of Static solver parameters.\nNumber of Steps: Numeric value representing the number of steps. (Int64, optional)\nNLsolve,Solution tolerance  | Float, Residual tolerance, Maximum number of iterations, Show solver iteration, Residual scaling, Solver Type, m, Linear Start Value Numeric values representing Static solver parameters. (Float64, Bool, String or Int64, optional)","category":"page"},{"location":"man/input_yaml/#Surface-Correction-(optional)","page":"Input File","title":"Surface Correction (optional)","text":"","category":"section"},{"location":"man/input_yaml/","page":"Input File","title":"Input File","text":"Type: String defining what model is used, currently only Volume Correction is included\nUpdate: Bool defining if the surface is updated during the solving process, taking changes as fracture or additive processes into account","category":"page"},{"location":"man/input_yaml/","page":"Input File","title":"Input File","text":"","category":"page"},{"location":"man/models/damage/#Damage-Models","page":"Damage Models","title":"Damage Models","text":"","category":"section"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"Damage Model Critical Stretch Critical Energy\nCritical Value âœ”ï¸ âœ”ï¸\nInterblock Damage (âœ”ï¸) (âœ”ï¸)\nAnisotropic Damage (âœ”ï¸) (âœ”ï¸)","category":"page"},{"location":"man/models/damage/#Damage-index","page":"Damage Models","title":"Damage index","text":"","category":"section"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"The damage index phi of a material point is computed as [1] phi = fracint_mathcalH(1-chilangleboldsymbolxirangle)dV_xiint_mathcalHdV_xi=fracsum^n_i=1(1-chi_i dV_isum^n_i=1 dV_i with chi is the bond damage between 0 (broken) and 1 (unbroken), V is the volume and n is the number of neighbors.","category":"page"},{"location":"man/models/damage/#Critical-Stretch","page":"Damage Models","title":"Critical Stretch","text":"","category":"section"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"The critical value correspondends to the critical stretch for this model, defined in the theory manual.","category":"page"},{"location":"man/models/damage/#Critical-Energy","page":"Damage Models","title":"Critical Energy","text":"","category":"section"},{"location":"man/models/damage/#Interblock-Damage","page":"Damage Models","title":"Interblock Damage","text":"","category":"section"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"Interlaminar behaviour between different material blocks can be defined using the Interblock Critical Value parameter. If a Bond is crossing a block interface, a user defined critical damage value is applied to the bonds.","category":"page"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"As bonds are bidirectional, the critical damage value can be defined for both orientations, for example:","category":"page"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"Interblock Damage:\nInterblock Critical Value 1_2: 0.1\nInterblock Critical Value 2_1: 0.1","category":"page"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"Bonds that aren't crossing a block interface are not affected by the interblock damage model.","category":"page"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"(Image: InterBlockDamage)","category":"page"},{"location":"man/models/damage/#Local-damping","page":"Damage Models","title":"Local damping","text":"","category":"section"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"Silling proposed a local damping to reduce waves induced by cracked bonds in [1] in (EQ 2.34). This proposed algorithm is introduced in Material_Basis.jl.","category":"page"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"The bond force due to damping is computed as","category":"page"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"mathbft_damplangleboldsymbolxirangle = overlinephid cfraceta_i-eta_i-1dt v_0fraceta_ieta_i","category":"page"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"with the numerical local damping coefficient d, the bond stiffness c, the rate of bond extension dote=fraceta_i-eta_i-1dt where eta_i and eta_i-1 the length of the deformed bond vector at iteration step i and i-1 and dt is the time increment.","category":"page"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"The average damage index between point i and it's neighbor j can be computed as overlinephi=fracphi_i+phi_j2 and using the Young's modulus E and the mass density rho the dilatation wave speed [8] as","category":"page"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"v_0=fracErho","category":"page"},{"location":"man/models/damage/","page":"Damage Models","title":"Damage Models","text":"","category":"page"},{"location":"lecture/seminar_6/#Seminar-6:-Parallelization-and-contact","page":"Seminar 6","title":"Seminar 6: Parallelization and contact","text":"","category":"section"},{"location":"lecture/seminar_6/","page":"Seminar 6","title":"Seminar 6","text":"Concept of parallelization\nGPU based\navoided, because the whole paradigm is different","category":"page"},{"location":"lecture/seminar_6/#CPU-based","page":"Seminar 6","title":"CPU based","text":"","category":"section"},{"location":"lecture/seminar_6/","page":"Seminar 6","title":"Seminar 6","text":"beginbmatrix1  2  3  4  5  6  7 endbmatrix_allrightarrowbeginmatrix beginbmatrix 4  6  endbmatrix_C1-global\nbeginbmatrix1  2   7 endbmatrix_C2-global\nbeginbmatrix35endbmatrix_C3-globalendmatrixleftarrow rightarrowbeginmatrix beginbmatrix 1  2  endbmatrix_C1-local\nbeginbmatrix1  2   3 endbmatrix_C2-local\nbeginbmatrix12endbmatrix_C3-localendmatrix","category":"page"},{"location":"lecture/seminar_6/","page":"Seminar 6","title":"Seminar 6","text":"restructuring from fields","category":"page"},{"location":"lecture/seminar_6/","page":"Seminar 6","title":"Seminar 6","text":"info: Data access\nNot all data is avaiable at each core.","category":"page"},{"location":"lecture/seminar_6/","page":"Seminar 6","title":"Seminar 6","text":"$ julia\njulia> using MPI\njulia> MPI.install_mpiexecjl()","category":"page"},{"location":"lecture/seminar_6/","page":"Seminar 6","title":"Seminar 6","text":"Run PeriLab with two processors:","category":"page"},{"location":"lecture/seminar_6/","page":"Seminar 6","title":"Seminar 6","text":"$ mpiexecjl -n 2 julia -e 'using PeriLab; PeriLab.main(\"examples/DCB/DCBmodel.yaml\")'","category":"page"},{"location":"lecture/seminar_6/","page":"Seminar 6","title":"Seminar 6","text":"Run PeriLab with one processors:","category":"page"},{"location":"lecture/seminar_6/","page":"Seminar 6","title":"Seminar 6","text":"julia -e 'using PeriLab; PeriLab.main(\"examples/DCB/DCBmodel.yaml\")'","category":"page"},{"location":"lecture/seminar_6/#Multi-core-search-strategy","page":"Seminar 6","title":"Multi-core search strategy","text":"","category":"section"},{"location":"lecture/seminar_6/","page":"Seminar 6","title":"Seminar 6","text":"In Seminar","category":"page"},{"location":"lecture/seminar_6/","page":"Seminar 6","title":"Seminar 6","text":"","category":"page"},{"location":"lecture/seminar_5/#Seminar-5:-From-bond-based-to-state-based-II-(Application)","page":"Seminar 5","title":"Seminar 5: From bond-based to state-based II (Application)","text":"","category":"section"},{"location":"lecture/seminar_5/","page":"Seminar 5","title":"Seminar 5","text":"Convergence of the different methods","category":"page"},{"location":"lecture/seminar_5/","page":"Seminar 5","title":"Seminar 5","text":"(Image: )","category":"page"},{"location":"lecture/seminar_5/","page":"Seminar 5","title":"Seminar 5","text":"Figure taken from [35]","category":"page"},{"location":"lecture/seminar_5/","page":"Seminar 5","title":"Seminar 5","text":"PeriLab:\n  Discretization:\n    Node Sets:\n      Node Set 1: 1\n      Node Set 2: 5\n    Type: \"Text File\"\n    Input Mesh File: \"truss.txt\"\n  Models:\n    Material Models:\n      Test:\n        Material Model: \"PD Solid Elastic\"\n        Symmetry: \"isotropic plane stress\"\n        Young's Modulus: 7000\n        Poisson's Ratio: 0.3\n  Blocks:\n    block_1:\n      Block ID: 1\n      Material Model: \"Test\"\n      Density: 2e-9\n      Horizon: 2\n  Boundary Conditions:\n    BC_1:\n      Variable: \"Displacements\"\n      Node Set: \"Node Set 1\"\n      Coordinate: \"x\"\n      Value: \"100*t\"\n      Type: Dirichlet\n    BC_2:\n      Variable: \"Displacements\"\n      Coordinate: \"x\"\n      Node Set: \"Node Set 2\"\n      Value: \"0.1*t\"\n      Type: Dirichlet\n  Solver:\n    Material Models: True\n    Initial Time: 0.0\n    Final Time: 1.0\n    Number of Steps: 20\n    Static:\n      Show solver iteration: true\n      Residual tolerance: 1e-7\n      Solution tolerance: 1e-8\n      Residual scaling: 7000\n      m: 550\n      Maximum number of iterations: 100\n  Outputs:\n    Output1:\n      Output Filename: \"truss\"\n      Output File Type: Exodus\n      Number of Output Steps: 20\n      Output Variables:\n        Displacements: True\n        Number of Neighbors: True\n        Forces: True","category":"page"},{"location":"lecture/seminar_5/","page":"Seminar 5","title":"Seminar 5","text":"Ordinary PD Solid Elastic","category":"page"},{"location":"lecture/seminar_5/","page":"Seminar 5","title":"Seminar 5","text":"Difference to PD Solid.","category":"page"},{"location":"lecture/seminar_5/","page":"Seminar 5","title":"Seminar 5","text":"PeriLab:\n  Discretization:\n    Node Sets:\n      Node Set 1: 1\n      Node Set 2: 5\n    Type: \"Text File\"\n    Input Mesh File: \"truss.txt\"\n  Models:\n    Material Models:\n      Test:\n        Material Model: \"Correspondence Elastic\"\n        Symmetry: \"isotropic plane stress\"\n        Young's Modulus: 7000\n        Poisson's Ratio: 0.3\n        Global Control: true\n  Outputs:\n    Output1:\n      Output Filename: \"truss\"\n      Output File Type: Exodus\n      Number of Output Steps: 20\n      Output Variables:\n        Displacements: True\n        Number of Neighbors: True\n        Forces: True\n        Cauchy Stress: True","category":"page"},{"location":"lecture/seminar_5/","page":"Seminar 5","title":"Seminar 5","text":"Models for the seminar","category":"page"},{"location":"lecture/seminar_5/#Create-you-own-model","page":"Seminar 5","title":"Create you own model","text":"","category":"section"},{"location":"lecture/seminar_5/","page":"Seminar 5","title":"Seminar 5","text":"create a mesh (block.jl is an example)\nspecify node lists for boundary conditions\ndefine your yaml file\nrun your model\nanalyse it in Paraview","category":"page"},{"location":"lecture/seminar_5/","page":"Seminar 5","title":"Seminar 5","text":"","category":"page"},{"location":"lecture/lecture/#Lecture-Non-local-structural-mechanics-and-peridynamics","page":"Course Description","title":"Lecture Non-local structural mechanics and peridynamics","text":"","category":"section"},{"location":"lecture/lecture/","page":"Course Description","title":"Course Description","text":"This lecture currently running as a cooperation between the Magdeburg-Stendal University of applied sciences and the Otto von Guericke University Magdeburg.","category":"page"},{"location":"lecture/lecture/","page":"Course Description","title":"Course Description","text":"","category":"page"},{"location":"lecture/lecture/","page":"Course Description","title":"Course Description","text":"In past decades non-local field theories were developed and utilized to capture complex phenomena such as damage and fracture. In this course, basic approaches to develop a non-local theory are introduced starting from elementary structures such as rod and beam and towards the three-dimensional solids. Examples of the analysis of engineering components undergoing damage processes will be presented. The learning competence is the development and use of powerful computational methods to evaluate the mechanical behavior of components.","category":"page"},{"location":"lecture/lecture/","page":"Course Description","title":"Course Description","text":"(Image: )","category":"page"},{"location":"lecture/lecture/","page":"Course Description","title":"Course Description","text":"","category":"page"},{"location":"lecture/lecture/","page":"Course Description","title":"Course Description","text":"Lecture 1\nSeminar 1: Trusses and structure of matrices\nSeminar 2: Material point method and solver\nSeminar 3: Convergence and fracture\nSeminar 4: From bond-based to state-based I (Theory)\nSeminar 5: From bond-based to state-based II (Application)\nSeminar 6: Parallelization and contact\nSeminar 7: Multi-physics\nSeminar 8: Additive manufacturing\nSeminar 9: PeriLab - Implement your own model","category":"page"},{"location":"lecture/lecture/","page":"Course Description","title":"Course Description","text":"","category":"page"},{"location":"lecture/seminar_7/#Seminar-7:-Multi-physics","page":"Seminar 7","title":"Seminar 7: Multi-physics","text":"","category":"section"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"The theory is taken from [9]","category":"page"},{"location":"lecture/seminar_7/#Thermo-mechanics","page":"Seminar 7","title":"Thermo-mechanics","text":"","category":"section"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"boldsymbolvarepsilon=boldsymbolvarepsilon_mechanical + boldsymbolvarepsilon_thermal","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"boldsymbolvarepsilon_thermal =- boldsymbolalphatau","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"boldsymbolsigma=mathbfCcdotcdotleft(boldsymbolvarepsilon_mechanical - boldsymbolalphatau right)","category":"page"},{"location":"lecture/seminar_7/#Thermal-flux","page":"Seminar 7","title":"Thermal flux","text":"","category":"section"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"rho C_vdottau = int_mathcalH(underlineh(textbfxt)langleboldsymbolxirangle-underlineh(textbfxt)langleboldsymbolxirangle)dV_textbfx+ S_i","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"underlineh(textbfxt)langleboldsymbolxirangle = mathbfq^TmathbfK^-1(textbfx)boldsymbolxi","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"nablacdotmathbfq = int_mathcalHleftmathbfq(textbfx)^TmathbfK^-1(textbfx)+mathbfq(textbfx)^TmathbfK^-1(textbfx)rightboldsymbolxidV_textbfx","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"mathbfq = -boldsymbollambdanablatau","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"nablatau = mathbfK^-1int_mathcalHlefttau(mathbfx)-tau(mathbfx)rightboldsymbolxiunderlineomegalangleboldsymbolxirangle dV_mathbfx","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"The numerical solving process is then","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"rho C_v fractau^t+dt-tau^tdt=nablamathbfq + S_i","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"tau^t+dt = dtfracnablamathbfq + S_irho C_v + tau^t","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"(Image: )","category":"page"},{"location":"lecture/seminar_7/#Heat-transfer-to-environment","page":"Seminar 7","title":"Heat transfer to environment","text":"","category":"section"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"S_i = fracq_bcDelta","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"q_bc = kappa (tau-tau_env)","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"2D","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"V_2D=2pidelta^2 h geq int_mathcalHdV","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"3D","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"V_3D=frac43pidelta^3 geq int_mathcalHdV","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"f_limit leq V_specific =  fracint_mathcalHdVV_2Dor3D","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"tau_i^t+dt = dtfracnablamathbfq_i + frackappa (tau_i^t-tau_env)dx(rho C_v)_i + tau^t_i","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"(Image: ) (Image: )","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"using DifferentialEquations\nusing Plots\n\n########################\nN = 201 # number of points to discretize\n# PD discretization\ndx = 0.00005\n# free length minus width of PD boundary\nL = 0.02 - 4*dx  # conduction\nh = L / (N - 1)\nX = collect(0:h:L)\nk = 3\n########################\n\nfunction odefunc!(dudt, u, p, t)\n    dudt[1] = 0  # constant at boundary condition\n    dudt[end] = 0\n    # spatial second order differentiation\n    # utilizing second order finite difference\n    for i in 2:(N-1)\n        dudt[i] = k * (u[i-1] - 2*u[i] + u[i+1]) / h^2\n    end\n    return nothing\nend\n\ninit = zeros(length(X))  # initial temperature\ninit[1] = 10.0  # one boundary condition\ninit[end] = 0   # the other boundary condition\n\ntspan = (0.0, 2e-5)\ntsave = collect(0:3e-7:2e-5)\n\n# Define the ODE problem\nprob = ODEProblem(odefunc!, init, tspan)\n\n# Solve the ODE\nsol = solve(prob, saveat=tsave)\n\n# Access solution: sol[i, j] gives u_i at time t_j\n# sol.t gives the time points\n# sol.u gives the solution at each time point\n\n# Plotting\n# Plot temperature profiles at different times\nplot(X, sol.u[1], label=\"t = $(sol.t[1])\", xlabel=\"Position (m)\", ylabel=\"Temperature\",\n     title=\"Temperature Distribution Over Time\", linewidth=2)\n\n# Add profiles at several time points\ntime_indices = [1, length(sol.t)Ã·4, length(sol.t)Ã·2, 3*length(sol.t)Ã·4, length(sol.t)]\nfor idx in time_indices[2:end]\n    plot!(X, sol.u[idx], label=\"t = $(round(sol.t[idx], digits=6))\", linewidth=2)\nend\n\n# Create heatmap showing evolution over time\n# Convert solution to matrix format (space x time)\nu_matrix = hstack([u for u in sol.u])\n\n# Create heatmap\nheatmap(sol.t, X, u_matrix, xlabel=\"Time (s)\", ylabel=\"Position (m)\",\n        title=\"Temperature Evolution\", colorbar_title=\"Temperature\")\n\n# Create animation of temperature evolution\nanim = @animate for i in 1:length(sol.t)\n    plot(X, sol.u[i], ylim=(0, 10.5), xlabel=\"Position (m)\",\n         ylabel=\"Temperature\", title=\"Temperature at t = $(round(sol.t[i], digits=6)) s\",\n         linewidth=3, color=:red, legend=false)\nend\ngif(anim, \"heat_conduction.gif\", fps=10)\n","category":"page"},{"location":"lecture/seminar_7/#Time-step","page":"Seminar 7","title":"Time step","text":"","category":"section"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"Delta t  textminleft(fracleft(rho C_vright)_isum_j=1^Nfractextmax(texteig(boldsymbollambda))mathbfxi_ijV_jright)","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"[24]","category":"page"},{"location":"lecture/seminar_7/#Alternative-diffusion-based-models","page":"Seminar 7","title":"Alternative diffusion based models","text":"","category":"section"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"A fracp^t+dt-p^tdt=nablamathbfe + S_i","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"Parameter Description\nA is a model factor\np is the status variable\nmathbfe is the flow variable","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"Examples are [36]","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"Corrosion\nDiffusion\nChemical and Water Transport","category":"page"},{"location":"lecture/seminar_7/","page":"Seminar 7","title":"Seminar 7","text":"","category":"page"},{"location":"man/dev/parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"man/dev/parameters/","page":"Parameters","title":"Parameters","text":"All the parameter are stored in a dictionary called params.","category":"page"},{"location":"man/dev/parameters/","page":"Parameters","title":"Parameters","text":"The essential parameter are checked in parameter_handling.jl with the variable global expectedstructure_. If parameter are not defined there, a warning is given in the log file.","category":"page"},{"location":"man/dev/parameters/","page":"Parameters","title":"Parameters","text":"Parameter are included via the YAML input deck. The parameter can be found in the program in a dictionary. Therefore, the parameter naming is used there as well. For some variables, e.g. boundary condition, equations can be specified. These equations are interpreted and can be used to include time or spatial depended variables.","category":"page"},{"location":"man/dev/parameters/","page":"Parameters","title":"Parameters","text":"note: Good start\nPlease check some of the full scale tests. There are several yaml files with parameter definitions.","category":"page"},{"location":"man/dev/parameters/","page":"Parameters","title":"Parameters","text":"","category":"page"},{"location":"lecture/seminar_2/#Seminar-2:-Material-point-method-and-solver","page":"Seminar 2","title":"Seminar 2: Material point method and solver","text":"","category":"section"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"particle method\npoints are grid fix (no pure mesh free method)","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"Advantage","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"no topology\ndisconnection of points is easy","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"Disadvantage","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"convergence is low\ngradients purely described by points","category":"page"},{"location":"lecture/seminar_2/#Equations-in-the-Quasi-Static-Material-Point-Method-Algorithm","page":"Seminar 2","title":"Equations in the Quasi-Static Material Point Method Algorithm","text":"","category":"section"},{"location":"lecture/seminar_2/#**1.-Mapping-Material-Point-Quantities-to-Grid-Nodes**","page":"Seminar 2","title":"1. Mapping Material Point Quantities to Grid Nodes","text":"","category":"section"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"Nodal Mass","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"M_textnode = sum_mp m_mp  N_mp-nd","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"Nodal Velocity","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"mathbfV_textnode = frac1M_textnode sum_mp mathbfP_mp  N_mp-nd","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"Internal Force Vector","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"mathbfF_textnode^textinternal = sum_mp boldsymbolsigma_mp  nabla N_mp-nd","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"External Force Vector","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"mathbfF_textnode^textexternal = sum_mp mathbfb  N_mp-nd","category":"page"},{"location":"lecture/seminar_2/#**2.-Solving-Equations-of-Motion-on-the-Grid**","page":"Seminar 2","title":"2. Solving Equations of Motion on the Grid","text":"","category":"section"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"Nodal Acceleration","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"mathbfA_textnode = fracmathbfF_textnode^textexternal + mathbfF_textnode^textinternalM_textnode","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"Updated Nodal Velocity","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"tildemathbfV_textnode = mathbfV_textnode + mathbfA_textnode  mathrmdt","category":"page"},{"location":"lecture/seminar_2/#**3.-Mapping-Back-to-Material-Points**","page":"Seminar 2","title":"3. Mapping Back to Material Points","text":"","category":"section"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"Material Point Acceleration","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"mathbfa_mp = sum_nd mathbfA_textnode  N_nd-mp","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"Strain Rate (Infinitesimal Strain Theory)","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"dotboldsymbolvarepsilon_mp = sum_nd frac12 left mathbfV_textnode nabla N_nd-mp + (mathbfV_textnode nabla N_nd-mp)^T right","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"(Image: )","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"(Image: ) Figure taken from [2].","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"rho ddotu_i = frac12sum_j (f_jiV_i-f_ijV_j)+b_i","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"F_i + b_i=rhoddotu_i","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"Static case","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"(Image: ) Figure taken from [2].","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"mathbfF(mathbfu_i+1) + mathbfb_i+1 rightarrow 0","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"Verlet time integration","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"mathbfu_i+1 = mathbfu_i + Delta tdotmathbfu_i + frac12 Delta t^2ddotmathbfu_i","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"with","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"ddotmathbfu_i = fracmathbfF_irho","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"where rho is the mass density of the point and mathbfF_i=mathbfF_external-mathbfF_internal for the current time step.","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"For parabolic  time integration as in temperature models the following schema is used","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"boldsymboltau_i+1 =  boldsymboltau_i - Delta t fracmathbfHrho C_v","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"where rho is the mass density, C_v is the specific heat capacity and mathbfH is the heat flux of each point [10].","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"For the time intergration a stable increment has to be determined.","category":"page"},{"location":"lecture/seminar_2/#Volume-correction","page":"Seminar 2","title":"Volume correction","text":"","category":"section"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"(Image: )","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"lambda_corr=frac2V_0V(mathbfx)+V(mathbfx)","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"The reference volumen V_0 is depended on the dimension (3D or 2D)","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"V_0-3D=frac4pidelta^33","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"V_0-2D=fracpidelta^2h4","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"this factor is than multiplied to the bond force mathbft_corr =lambda_corrmathbft","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"warn: Only mechanical\nSurface correction is right now only applied for mechanical properties.","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"You can apply the surface correction initialy for all outer surfaces and continuous, for cracks or additive manufacturing.","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"using Plots\nusing Polynomials\n\n# Definition des Intervalls\nx = range(0, Ï€, length=200)\ny = sin.(x)\n\n# Plot vorbereiten\nplot(x, y,\n    label=\"sin(x)\",\n    lw=2,\n    legend=:bottomleft,\n    xlabel=\"x\",\n    ylabel=\"y\",\n    size=(1200, 800))\n\n# Anzahl der StÃ¼tzstellen\nn_nodes = 8\nx_nodes = range(0, Ï€, length=n_nodes)\ny_nodes = sin.(x_nodes)\n\n# Approximation mit Polynomen 2. bis 7. Ordnung\nfor deg in 1:3\n    # Polynomanpassung\n    p = fit(x_nodes, y_nodes, deg)\n    y_approx = p.(x)\n    plot!(x, y_approx, label=\"Grad $deg\")\nend\n\n# Punkte anzeigen\nscatter!(x_nodes, y_nodes, label=\"Exact solution\", color=:black)","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"","category":"page"},{"location":"lecture/seminar_2/#Set-up-your-own-model","page":"Seminar 2","title":"Set up your own model","text":"","category":"section"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"header: x y block_id volume\n0 0 1 1\n1 0 1 1\n2 0 1 1\n3 0 1 1\n4 0 1 1","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"function generate_grid_fixed_spacing(filename, x_from, x_to, y_from, y_to, dx; block_id=1)\n\n    num_points_x = Int(floor((x_to - x_from) / dx)) + 1\n    num_points_y = Int(floor((y_to - y_from) / dx)) + 1\n    volume = dx * dx\n\n    open(filename, \"w\") do io\n        println(io, \"header: x y block_id volume\")\n        for j in 0:num_points_y-1\n            y = y_from + j * dx\n            for i in 0:num_points_x-1\n                x = x_from + i * dx\n                println(io, \"$(x) $(y) $(block_id) $(volume)\")\n            end\n        end\n    end\nend","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"PeriLab:\n  Discretization:\n    Node Sets:\n      Node Set 1: 1\n      Node Set 2: 5\n    Type: \"Text File\"\n    Input Mesh File: \"truss.txt\"\n  Models:\n    Material Models:\n      Test:\n        Material Model: \"Bond-based Elastic\"\n        Symmetry: \"isotropic plane stress\"\n        Young's Modulus: 7000\n        Poisson's Ratio: 0.3\n  Blocks:\n    block_1:\n      Block ID: 1\n      Material Model: \"Test\"\n      Density: 2e-9\n      Horizon: 2\n  Boundary Conditions:\n    BC_1:\n      Variable: \"Displacements\"\n      Node Set: \"Node Set 1\"\n      Coordinate: \"x\"\n      Value: \"100*t\"\n      Type: Dirichlet\n    BC_2:\n      Variable: \"Displacements\"\n      Coordinate: \"x\"\n      Node Set: \"Node Set 2\"\n      Value: \"0.1*t\"\n      Type: Dirichlet\n  Solver:\n    Material Models: True\n    Initial Time: 0.0\n    Final Time: 1.0\n    Number of Steps: 20\n    Static:\n      Show solver iteration: true\n      Residual tolerance: 1e-7\n      Solution tolerance: 1e-8\n      Residual scaling: 7000\n      m: 550\n      Maximum number of iterations: 100\n  Outputs:\n    Output1:\n      Output Filename: \"truss\"\n      Output File Type: Exodus\n      Number of Output Steps: 20\n      Output Variables:\n        Displacements: True\n        Number of Neighbors: True\n        Forces: True","category":"page"},{"location":"lecture/seminar_2/","page":"Seminar 2","title":"Seminar 2","text":"","category":"page"}]
}
