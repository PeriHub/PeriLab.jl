var documenterSearchIndex = {"docs":
[{"location":"lecture/seminar_3/#Seminar-3:-Convergence-and-fracture","page":"Seminar 3","title":"Seminar 3: Convergence and fracture","text":"Convergence\n\nFor FEM an error estimation is given bei [25]\n\ne=Ch^p\n\nParameter Definition\ne Error\nh Mesh size (h  1)\nC Constant\np Polynomial order\n\nhrightarrow 0\n\nleads to erightarrow 0; if analytical solutions exist\n\ninfo: Limitions\nIf the fundamental assumptions of classical continuum mechanics are violated, e.g. second derivative of u exists.\n\nPeridynamics\n\n(Image: )\n\nFigure taken from [1]\n\n(Image: )\n\nFigure taken from [33]","category":"section"},{"location":"lecture/seminar_3/#Damage-models","page":"Seminar 3","title":"Damage models","text":"rho ddotu_i = frac12sum_j mu_ij(f_jiV_i-f_ijV_j)+b_i\n\nmu_ij=begincases\n  1  textif undamaged  \n  0  textif damaged\nendcases\n\n(Image: )","category":"section"},{"location":"lecture/seminar_3/#Critical-stretch","page":"Seminar 3","title":"Critical stretch","text":"The critical stretch model is widely used in literature [1], [34]. It defines the critical length change, or stretch s as a criterion for a damage.\n\nHerleitung Bednarek\n\ns_critleq s frac underlinemathbfY  underlinemathbfX \n\ns_crit = sqrtfracG_0C3G+(frac34)^4(K-frac5G3)delta","category":"section"},{"location":"lecture/seminar_3/#Critical-energy","page":"Seminar 3","title":"Critical energy","text":"The critical energy model introduced by [35] is valid for state-based peridynamic and bond-based analysis. The bond energy is defined as:\n\nw_bond = int_boldsymboleta_final (mathbfunderlineTxtlangle x-xrangle - mathbfunderlineTxtlangle x-xrangle)dboldsymboleta\n\nwith the relative displacement vector as:\n\nboldsymboleta=mathbfunderlineuxt-mathbfunderlineuxt\n\nIf the bond energy is bigger than or equal to the critical energy value, then the bond is considered to be broken:\n\nw_crit leq w_bond\n\nThe critical bond energy can be defined as:\n\nw_crit = frac4G_0Cpidelta^4\n\n(Image: )\n\nw_crit=2int_0^deltaint_mathcalHw_cdV=int_0^deltaint_0^2piint_z^deltaint_0^cos^-1zxiw_cxi^2sinphi dphi dxi domega dz\n\nEquations are taken from [4].\n\n","category":"section"},{"location":"lecture/seminar_3/#Differences","page":"Seminar 3","title":"Differences","text":"discussion in the seminar\ndirection\nexperimental\n\n","category":"section"},{"location":"lecture/seminar_3/#Numerical-integration","page":"Seminar 3","title":"Numerical integration","text":"Integration of damage model\n\n## Code concept\n\n#Run material\n#Evaluate Damage\n#Run Material\n\nomega = ones(length(nodes), nneighbor)\n\n\nfor idt in time\n\n    K = create_K(omega)\n\n    u = inv(K)*F_V # or from time integration\n\n    for iID in nodes\n        for jID in nlist[iID]\n            s = (u[iID]+x[iID]-(u[jID]+x[jID]))/(x[jID]-x[iID])\n            if  s>s_crit\n                omega[i,j]=0\n            end\n        end\n    end\n\n    K = create_K(omega)\n\n    u = inv(K)*F_V # or from time integration\n\n    ...\nend\n\nusing LinearAlgebra\n\n\nfunction K_stiff(np, c, omega, V)\n    K=zeros(np,np)\n    for iID in 1:np\n        for jID in -nn:nn\n            if jID != 0 && iID + jID > 0 && iID + jID < np + 1\n                xi = L*abs(jID)\n                K[iID, iID + jID] -= 0.5 * c[iID] / xi * V * omega[iID, iID + jID]\n                K[iID, iID]      +=  0.5 *c[iID] / xi * V * omega[iID, iID + jID]\n            end\n        end\n    end\n    K[np, :] .= 0\n    K[:, np] .= 0\n    K[np, np] = 1\n    return K\nend\n\nE = 1\nV = 1\nL = 1\nnp = 8\nnn = 2\ndelta = 1\nu = zeros(np)\nu[1]=0.125\nomega=ones(np, np)\n\n\n##\nc=zeros(np)\nc .= 2*E/delta^2\nc[4]=1.5 .*c[4]\n\nK_undam = K_stiff(np, c, omega, V)\nomega[1,2] = 0\nK_d = K_stiff(np, c, omega, V)\nomega[2,1] = 0\nK_dsym = K_stiff(np, c, omega, V)\nomega[1,3] = 0\nomega[3,1] = 0\nK_full_dam = K_stiff(np, c, omega, V)\n\n## Damage\n\n\nM = [\"no damage\" \"damage\" \"damage sym\" \"damage full\";K_undam*u K_d*u K_dsym*u K_full_dam*u]\ndisplay(M)\n#--------------------------\nprintln(\"Rank\")\nM = [\"no damage\" \"damage\" \"damage sym\" \"damage full\";\nrank(K_undam) rank(K_d) rank(K_dsym) rank(K_full_dam)]\ndisplay(M)\n\n\nDiscussion\n\nHow many bonds are allowed to break per time step?\nSize of the horizon?\n\n","category":"section"},{"location":"man/models/contact/#Contact","page":"Contact Models","title":"Contact","text":"","category":"section"},{"location":"man/models/contact/#Contact-Search","page":"Contact Models","title":"Contact Search","text":"Parameter Unit Description\nContact Radius m Radius to get a list of potential contact pairs.\nMaster - Block ID of the master nodes.\nSlave - Block ID of the slave nodes.\n\nInitialization\n\nStep 1 - Identification of all surface nodes of contact blocks.\nStep 2 - All surface nodes are stored in a list. This list exists at all cores with the current position of the surface nodes.\nStep 3 - Connect each surface node to a geometrical surface.\n\nThe standard way for points in the parallelization is given here.\n\nbeginbmatrix1  2  3  4  5  6  7 endbmatrix_allrightarrowbeginmatrix beginbmatrix 4  6  endbmatrix_C1-global\nbeginbmatrix1  2   7 endbmatrix_C2-global\nbeginbmatrix35endbmatrix_C3-globalendmatrixleftarrow rightarrowbeginmatrix beginbmatrix 1  2  endbmatrix_C1-local\nbeginbmatrix1  2   3 endbmatrix_C2-local\nbeginbmatrix12endbmatrix_C3-localendmatrix\n\nA new mapping is needed to the contact surface exchange list. The local numbering (right above) has to be mapped to the sublist and vice, versa.\n\nbeginbmatrix1  2    6  7 endbmatrix_surfaceleftarrowrightarrow beginbmatrix1  2   3  4  endbmatrix_surfacerightarrow beginmatrix beginbmatrix  6  endbmatrix_C1\nbeginbmatrix1  2   7 endbmatrix_C2\nbeginbmatrixendbmatrix_C3endmatrixleftarrow rightarrowbeginmatrix beginbmatrix 2   endbmatrix_C1-local\nbeginbmatrix1  2   3 endbmatrix_C2-local\nbeginbmatrixendbmatrix_C3-localendmatrix\n\nList mapping To fill the postion vector with the needed values mappings are needed.\n\nlocal point ids -> global point id -> reduced contact block point id The mapping has to be done in both directions, because the contact forces have to be applied to the local core point id.\n\n\n\nComputation\n\nStep 1 - Perform a nearest neighbor search with a user defined Contact Radius. The result is a list of potential contact pairs.\nStep 2 - A sub list nearest neighbor search is performed.\nStep 3 - All points found are than in contact.\n\nThe quasi code is given here\n\n# synchronize all contact nodes\nsynchronize_contact_points(\"Deformed Coordinates\", \"NP1\",\n                                               all_positions)\n\n## loop over all contact pairs\nfor (cm, block_contact_params) in pairs(contact_params)\n    contact_search(...)\nend\n\nfunction contact_search(...)\n    if n < search_frequency\n        potential_contact_list = global_search(...) # finds all points within the search radius\n        local_search(...)\n        return\n    else\n        synchronize_contact_points(\"Deformed Coordinates\", \"NP1\",\n                                               all_positions[potential_contact_list])\n        local_search(...)   # finds all points within the contact radius\n        return\n    end\nend\n\n\nThe structure tries to minimize the search and the communication between cores.\n\nSynchronization All cores (except core 1) send it's displacement values to core 1. Core 1 sends them back.\n\nnote: Efficiency\nSmaller contact areas are more efficient in numerical analysis, because less synchronisation have to occur.","category":"section"},{"location":"man/models/contact/#Contact-Models","page":"Contact Models","title":"Contact Models","text":"Contact Model Penalty Contact\nContact Stiffness âœ”ï¸","category":"section"},{"location":"man/models/contact/#Penalty-Contact","page":"Contact Models","title":"Penalty Contact","text":"A bond-based contact formulation is computed. The contact stiffness c_contact is defined in YAML input file. Based on that utilzing the horizon delta the penalty stiffness shown in the table is computed. These parameter are comparable to the bond-based formulation. The algorithm was taken from Peridigm\n\nDimension Penalty Stiffness\nplane strain: c_Penalty = frac48 c_contactpi 5 delta_slave^3\nplane stress: c_Penalty = frac9 c_contactpi delta_slave^3\n3D: c_Penalty = frac12 c_contactpi  delta_slave^4","category":"section"},{"location":"man/models/contact/#Normal-Contact","page":"Contact Models","title":"Normal Contact","text":"The distance is computed as\n\nd = underlinemathbfY_master-underlinemathbfY_slave\n\nThe normal is\n\nmathbfn = fracunderlinemathbfY_master-underlinemathbfY_slaved\n\nBoth can be adopted if needed. Utilizing the contact radius r_contact the contact force densities are\n\nmathbff_master=c_Penaltyfrac(r_contact-d)delta_slavemathbfnV_slave\n\nmathbff_slave = -c_Penaltyfrac(r_contact-d)delta_slavemathbfnV_master\n\nWithin PeriLab the functions computemasterforce__density and compute__slave__force__density are used to apply the force to the correct postions. This is needed, because if a parallel process is run, master and slave nodes not necessarily are on the same core.","category":"section"},{"location":"man/models/contact/#Friction-Contact","page":"Contact Models","title":"Friction Contact","text":"Contact Model Penalty Contact\nFriction Coeffient âœ”ï¸\n\nThe model is computed if the \"\"Friction Coeffient\"\" is greater than zero. For friction the normal forces\n\nmathbff_n=c_Penaltyfrac(r_contact-d)delta_slavemathbfn\n\nare used. The tangential direction must be computed. Following the Peridigm algorithm, the normal velocity of the master node m and the slave node s are\n\nbeginmatrixv_m = mathbfv_mmathbfnv_s = mathbfv_smathbfnendmatrix\n\nTo obtain the tangential part tan this value hmust be substrated from the velocity.\n\nbeginmatrixmathbfv_tan-m = mathbfv_m - v_mmathbfnmathbfv_tan-s = mathbfv_s - v_smathbfnendmatrix\n\nTanking the average\n\nmathbfv_avg = 05(mathbfv_tan-m+mathbfv_tan-s)\n\nthe relative velocity of each point can be determined.\n\nbeginmatrixmathbfv_tan-m=mathbfv_tan-m-mathbfv_avgmathbfv_tan-s=mathbfv_tan-s - mathbfv_avgendmatrix\n\nIf the length of mathbfv_tan-m and mathbfv_tan-s is greater than zero, respectively, friction occurs. The friction force is computed as using the friction coefficient mu.\n\nbeginmatrixmathbff_fric-m = -mu mathbff_nfracmathbfv_tan-mmathbfv_tan-mmathbff_fric-s = -mu mathbff_nfracmathbfv_tan-smathbfv_tan-sendmatrix\n\n","category":"section"},{"location":"man/bond_filter/#Bond-Filters","page":"Bond-Filter","title":"Bond-Filters","text":"","category":"section"},{"location":"man/bond_filter/#Rectangular-Plane","page":"Bond-Filter","title":"Rectangular Plane","text":"For a recangular plane following parameters needs to be defined:\n\nNormal X/Y/Z: Numeric values representing normal components. (Float64 or Int64)\nLower Left Corner X/Y/Z: Numeric values representing lower left corner components. (Float64 or Int64)\nBottom Unit Vector X/Y/Z: Numeric values representing bottom unit vector components. (Float64 or Int64)\nBottom Length: Numeric value representing the bottom length. (Float64 or Int64)\nSide Length: Numeric value representing the side length. (Float64 or Int64)\n\n(Image: Discretization_BondFilters_RectangularPlane)\n\nThe yaml definition looks like this\n\nBond Filters:\n  bf_1:\n    Bottom Length: 2.0\n    Bottom Unit Vector X: 1.0\n    Bottom Unit Vector Y: 0.0\n    Bottom Unit Vector Z: 0.0\n    Lower Left Corner X: -0.5\n    Lower Left Corner Y: 0.0\n    Lower Left Corner Z: -1.0\n    Normal X: 0.0\n    Normal Y: 1.0\n    Normal Z: 0.0\n    Side Length: 2.0\n    Type: Rectangular_Plane","category":"section"},{"location":"man/bond_filter/#Disk","page":"Bond-Filter","title":"Disk","text":"For a disk following parameters needs to be defined:\n\nNormal X/Y/Z: Numeric values representing normal components. (Float64 or Int64)\nCenter X/Y/Z: Numeric values representing center components. (Float64 or Int64)\nRadius: Numeric value representing the radius. (Float64 or Int64)\n\n","category":"section"},{"location":"man/solver/solver/#Solver","page":"Solver","title":"Solver","text":"Parameter Type Optional Description\nMaterial Models Bool Yes Activates the time integration for materials and material evaluation\nDamage Models Bool Yes Activates the damage evaluation\nThermal Models Bool Yes Activates the time integration for thermal models and thermal model evaluation\nAdditive Models Bool Yes Activates the additive model evaluation\nMaximum Damage Float Yes Defines the maximum damage in one point\nInitial Time Float No Defines the initial time\nFinal Time Float No Defines the final time\nFixed dt Float Yes Defines a fixed time step\nNumber of Steps Int Yes Defines a fixed number of steps\nVerlet Dict Yes Defines the Verlet solver\nStatic Dict Yes Defines the Static solver","category":"section"},{"location":"man/solver/solver/#Verlet","page":"Solver","title":"Verlet","text":"Parameter Type Optional Description\nSafety Factor Float Yes Defines a scaling factor for the time increment\nNumerical Damping Float Yes Defines a damping factor\n\nwarning: Fixed dt\n\n\nIf a fixed time step is defined, the time integration can become unstable.\n\nThe Verlet time integration is used as standard solver for dynamic hyperbolic differential equation of motion. It is also used in Peridigm [3]. The displacements for step i+1 are solved as follows\n\nmathbfu_i+1 = mathbfu_i + Delta tdotmathbfu_i + frac12 Delta t^2ddotmathbfu_i\n\nwith\n\nddotmathbfu_i = fracmathbfF_irho\n\nwhere rho is the mass density of the point and mathbfF_i=mathbfF_external-mathbfF_internal for the current time step.\n\nFor parabolic time integration as in temperature models the following schema is used\n\nboldsymboltau_i+1 =  boldsymboltau_i - Delta t fracmathbfHrho C_v\n\nwhere rho is the mass density, C_v is the specific heat capacity and mathbfH is the heat flux of each point [10].\n\nFor the time intergration a stable increment has to be determined.","category":"section"},{"location":"man/solver/solver/#Static","page":"Solver","title":"Static","text":"Parameter Type Optional Description\nNLsolve Bool Yes Place Holder\nSolution tolerance Float Yes Defines how much change between two iterations of the solution variable is allowed.\nResidual tolerance Float Yes Defines how much change between two iterations of the maximum residual variable is allowed.\nMaximum number of iterations Int Yes Maximum number of iteration of the solver.\nShow solver iteration Bool Yes Shows additional information\nResidual scaling Float Yes Scales the residual and the variable in same order. Should be in the range of the Young's modulus.\nSolver Type String Yes not implmented yet\nm Int Yes Only for Anderson solver; It does not use Jacobian information or linesearch, but has a history whose size is controlled by the m parameter: m=0 corresponds to the simple fixed-point iteration above, and higher values use a larger history size to accelerate the iterations. Higher values of m usually increase the speed of convergence, but increase the storage and computation requirements and might lead to instabilities. m=15 is set as standard value.\nLinear Start Value Vector{Float} Yes Defines start and end values of a linear function over the length of the model (detailed explanation in the text)\n\nThe static solver from NLsolve.jl has been included. Specifically the method = :anderson is used.\n\nThe solver computes the residual of the internal reaction force densities and the external applied force densities r =  leftunderlinemathbfT_external + underlinemathbfT_internalright  s_Residualscaling\n\nRight now the default value m of the Anderson acceleration method is chosen.\n\ns_Residualscaling\n\nshould be in the range of the Young's modulus and is than scaled by the volume.\n\ns_Residualscaling = minimum(volume)^2\n\nwarning: Multiphysics\n\n\nCurrently only the mechanical solver is included!\n\n\n\nStart Value\n\nThe start value defines the values taken for the first iteration. The default is zero. Two options are possible. The first option defines start values in the mesh file. The name is\n\nstart_values_x\nstart_values_y\nstart_values_z (optional)\n\nThese numbers are stored in the datamanager and are used for the iteration.\n\nThe alternative is to define a Linear Start Value as it is given as option in the list above. This list defines values for 3D as\n\nstart_val = A_x-minA_x-maxA_y-minA_y-maxA_z-minA_z-max\n\nand for 2D\n\nstart_val = A_x-minA_x-maxA_y-minA_y-max\n\nwhere A are amplitude values chosen by the user.\n\nWith these values the field ''start_values'' is computed as\n\nstart_value(xyz (optional))= fraca(xyz(optional))cdot coordinates+n(xyz(optional))nsteps\n\na(xyz (optional))=fractextmax(start_val)-textmin(start_val)textmax(coordinates)-textmin(coordinates)\n\nand\n\nn(xyz (optional))=textmax(start_val)-a(xyz (optional))textmax(coordinates)","category":"section"},{"location":"man/solver/solver/#Linear-Static-Matrix-Based","page":"Solver","title":"Linear Static Matrix Based","text":"Parameter Type Optional Description\nUpdate Matrix Bool Yes Activates the update of the stiffness matrix\n\nThe solver computes the stiffness matrix of the problem. It is solved by\n\n$\n\n\\mathbf{u} = \\mathbf{K}{PD}^{-1}\\mathbf{F}{external}$\n\nThe number of steps defines the virtual time step.","category":"section"},{"location":"man/solver/solver/#Update-Matrix","page":"Solver","title":"Update Matrix","text":"Uses the previous time step as original configuration. This allows the analysis of geometrically non-linear deformations. It must be updated if damages or additive models are used.\n\nwarning: Models\n\n\nNot all models are fully tested yet in this framework.\n\nwarning: Models\n\n\nStress computations are not inclueded yet. Please check the issues.","category":"section"},{"location":"man/solver/solver/#Verlet-Matrix-Based","page":"Solver","title":"Verlet Matrix Based","text":"It is the same solver as the Verlet based solver above. The main difference is, that the matrix style is used.\n\nwarning: Models\n\n\nIf update is active it is not very efficient, because the creation of new matrix is more costly than the material point approach.\n\nParameter Type Optional Description\nUpdate Matrix Bool Yes Activates the update of the stiffness matrix\nModel reduction Dict Yes Defines the model reduction options\n\nIf model reduction\n\nParameter Type Optional Description\nType String No Defines the type of model redction (Static Condensationn)\nRedcution Blocks String or Int No Defines the blocks to be condensed; defintion are (4 or 1 2 4 or 1, 2, 4)\n\n","category":"section"},{"location":"lib/faq/#PeriLab-Frequently-Asked-Questions-(FAQ)","page":"FAQ","title":"PeriLab - Frequently Asked Questions (FAQ)","text":"","category":"section"},{"location":"lib/faq/#General-Questions","page":"FAQ","title":"General Questions","text":"","category":"section"},{"location":"lib/faq/#What-is-PeriLab?","page":"FAQ","title":"What is PeriLab?","text":"PeriLab is a peridynamic simulation software designed for different kind of mechanical problems.","category":"section"},{"location":"lib/faq/#Installation-and-Setup","page":"FAQ","title":"Installation and Setup","text":"","category":"section"},{"location":"lib/faq/#What-are-the-system-requirements-for-installing-PeriLab?","page":"FAQ","title":"What are the system requirements for installing PeriLab?","text":"In order to install PeriLab, you will need to have a recent version of Julia or Docker installed on your system.","category":"section"},{"location":"lib/faq/#How-do-I-update-my-PeriLab-software?","page":"FAQ","title":"How do I update my PeriLab software?","text":"To update PeriLab you just need to run julia -e \"using Pkg; Pkg.update()\" or pull the latest version of the PeriLab Docker image.","category":"section"},{"location":"lib/faq/#Simulation-and-Analysis","page":"FAQ","title":"Simulation and Analysis","text":"","category":"section"},{"location":"lib/faq/#How-can-I-generate-my-own-input-mesh?","page":"FAQ","title":"How can I generate my own input mesh?","text":"There are multiple options to generate your own input mesh:\n\nUse the Perihub framework to generate your own input mesh.\nGenerate your own input mesh with julia, here is an example.\nCreate a .png image of your 2D model and translate it with this script.\nUse an existing Abaqus Inputfile (.inp).\nTransfer your mesh using meshio\nCreate a feature issue and let us know what you need.","category":"section"},{"location":"lib/faq/#What-to-do-with-my-results?","page":"FAQ","title":"What to do with my results?","text":"First of all congratulations ðŸŽ‰ on the success of your simulation. Now, you can take a look at your results. To do that, you can use ParaView it's free and very powerful.","category":"section"},{"location":"lib/faq/#Can-I-customize-parameters-for-my-simulations-in-PeriLab?","page":"FAQ","title":"Can I customize parameters for my simulations in PeriLab?","text":"Yes, PeriLab allows users to customize various parameters to tailor simulations based on their specific requirements.","category":"section"},{"location":"lib/faq/#Troubleshooting","page":"FAQ","title":"Troubleshooting","text":"","category":"section"},{"location":"lib/faq/#I'm-experiencing-technical-issues-with-PeriLab.-What-should-I-do?","page":"FAQ","title":"I'm experiencing technical issues with PeriLab. What should I do?","text":"If you encounter technical issues, please create an issue and describe it in detail.","category":"section"},{"location":"lib/faq/#Additional-Assistance","page":"FAQ","title":"Additional Assistance","text":"If your question is not addressed here, please feel free to contact us or create an issue for further assistance.","category":"section"},{"location":"lib/faq/#Contributions","page":"FAQ","title":"Contributions","text":"Contributions are always welcomed, take a look at the Contributing Guidelines\n\n","category":"section"},{"location":"lib/fem_functions/#FEM-Functions","page":"FEM","title":"FEM - Functions","text":"","category":"section"},{"location":"lib/fem_functions/#Index","page":"FEM","title":"Index","text":"Pages = [\"fem_functions.md\"]","category":"section"},{"location":"lib/fem_functions/#FEM","page":"FEM","title":"FEM","text":"","category":"section"},{"location":"lib/fem_functions/#PeriLab.Solver_Manager.FEM.force_densities-Tuple{AbstractVector{Int64}}","page":"FEM","title":"PeriLab.Solver_Manager.FEM.force_densities","text":"force_densities(nodes)\n\nComputes the force densities from the FEM nodes.\n\nArguments\n\nnodes::Vector{Int64}: FEM nodes.\n\nReturns\n\n\n\n\n\n","category":"method"},{"location":"man/dev/module_overview/#Module-overview","page":"Module Overview","title":"Module overview","text":"PeriLab\nHelpers\nGeometry\nData_Manager\nLogging_Module\nMPI_Communication\nParameter_Handling\nIO\nSolver_Manager\nMaterial_Basis\nFEM\nFEM_Basis\nCoupling\nArlequin_Coupling\nModel\nPre_Calculation\nAxissymmetric\nBond_Deformation\nDeformation_Gradient\nPreBondAssociated_Correspondence\nShape_Tensor\nâ€¦\nSurface_Correction\nContact\nContact_Search\nPenalty_Model\nâ€¦\nAdditive\nDamage_Based\nâ€¦\nDegradation\nThermal_Decomposition\nâ€¦\nDamage\nCritical_Stretch\nCritical_Energy\nCriticalEnergyAniso\n...\nMaterial\nOrdinary\nOneDBondBased_Elastic\nBondbased_Elastic\nUnifiedBondbasedElastic\nCorrespondence\nGlobalZeroEnergy_Control\nBondAssociatedCorrespondence\nCorrespondence_Elastic\nCorrespondence_Plastic\nCorrespondence_UMAT\nCorrespondence_VUMAT\nâ€¦\nPDSolidElastic\nPDSolidPlastic\nâ€¦\nThermal\nHeat_Transfer\nHETVAL\nThermal_Expansion\nThermal_Flow\n...\nBoundary_Conditions\nVerlet_Solver\nStatic_Solver\nInfluence_Function\n\n","category":"section"},{"location":"theory/theory_FEM/#Finite-Element-Method","page":"FEM","title":"Finite Element Method","text":"The elements in PeriLab are formulated using the matrix of shape functions mathbfN and the matrix of derivatives mathbfB [25], [26].\n\nmathbfM=mathbfN^TmathbfNrho\n\nTo run a point wise analysis and bring it into the same structure as the PD formulation the lumped mass matrix form is used\n\nm_i=sumlimits_j=1^n M_ij\n\nto get a diagonal mass matrix. To compute the stiffness matrix the following form is used.\n\nmathbfK=int_VmathbfB^Tboldsymbolsigma(boldsymbolvarepsilon)dV\n\nThe element strain is given as\n\nboldsymbolvarepsilon=mathbfB^Tmathbfu\n\nThis formulation allows the flexible integration of material laws. Using the linear elastic material with the elasticity matrix mathbfC\n\nmathbfK=int_V mathbfB^TmathbfCBdV\n\nModule Related Model in PeriLab\nLagrange_element Lagrange","category":"section"},{"location":"theory/theory_FEM/#Lagrange-functions","page":"FEM","title":"Lagrange functions","text":"Lagrange polynomials can be used to formulated finite elements [27]. These polynomials can be defined recursively for a polynomial p.\n\nL(x) =  prodlimits_beginsmallmatrix0le mle p mneq jendsmallmatrix fracx-x_mx_j-x_m\n\nThe values x are defined in local coordinated -11. These shape functions can be defined seperatly for each direction, also with different polynomial orders. In combination these functions are used in the matrix mathbfN.\n\nThe derivative can be computed recursively as well.\n\nL_j(x)=L_j(x)sumlimits_beginsmallmatrixi=0 ineq jendsmallmatrix^pfrac1x-x_i\n\nThe number of nodes per element is depended on the degrees of freedom (dof) (p+1)^dof.\n\n","category":"section"},{"location":"lib/references/","page":"References","title":"References","text":"F.Â Bobaru, J.Â T.Â Foster, P.Â H.Â Geubelle and S.Â A.Â Silling. Handbook of Peridynamic Modeling. Advances in Applied Mathematics (CRC Press, 2016).\n\n\n\nL.Â Beuth. Formulation and Application of a Quasi-Static Material Point Method. PhD thesis, Institut fÃ¼r Geotechnik, UniversitÃ¤t Stuttgart (Stuttgart, 2012).\n\n\n\nD.Â J.Â Littlewood, M.Â L.Â Parks, J.Â T.Â Foster, J.Â A.Â Mitchell and P.Â Diehl. The Peridigm Meshfree Peridynamics Code. JournalÂ ofÂ PeridynamicsÂ andÂ NonlocalÂ Modeling (2023).\n\n\n\nC.Â Willberg, L.Â Wiedemann and M.Â RÃ¤del. A mode-dependent energy-based damage model for peridynamics and its implementation. JournalÂ ofÂ MechanicsÂ ofÂ MaterialsÂ andÂ Structures 14, 193â€“217 (2019).\n\n\n\nC.Â Willberg, J.-T.Â Hesse, M.Â Garbade, M.Â RÃ¤del, F.Â Heinecke, A.Â Schuster and A.Â Pernatii. A user material interface for the Peridynamic Peridigm framework. SoftwareX 21, 101322 (2023).\n\n\n\nJ.-T.Â Hesse, C.Â Willberg, R.Â Hein and F.Â Winkelmann. Peridynamic framework to model additive manufacturing processes. PAMM n/a, e202300033 (2023).\n\n\n\nC.Â Willberg, J.-T.Â Hesse and A.Â Pernatii. PeriLab - Peridynamic Laboratory. SoftwareX 26 (2024).\n\n\n\nK.Â Partmann, M.Â Dienst and K.Â Weinberg. Peridynamic computations of wave propagation and reflection at material interfaces. ArchiveÂ ofÂ AppliedÂ Mechanics 94, 2405â€“2416 (2024).\n\n\n\nC.Â Willberg, J.-T.Â Hesse, F.Â Winkelmann and R.Â Hein. Peridynamic Framework to Model Additive Manufacturing Processes. AdvancedÂ TheoryÂ andÂ Simulations n/a, 2400818 (2024).\n\n\n\nS.Â Oterkus, E.Â Madenci and A.Â Agwai. Peridynamic thermal diffusion. JournalÂ ofÂ ComputationalÂ Models 265, 71â€“96 (2014).\n\n\n\nJ.Â Trageser and P.Â Seleson. Bond-Based Peridynamics: a Tale of Two Poisson's Ratios. JournalÂ ofÂ PeridynamicsÂ andÂ NonlocalÂ Modeling 2, 278â€“288 (2020).\n\n\n\nJ.Â Guan and L.Â Guo. A unified bond-based peridynamic model without limitation of Poisson's ratio. AppliedÂ MathematicalÂ Modelling 128, 609â€“629 (2024).\n\n\n\nJ.Â Guan, W.Â Li, X.Â Yan and L.Â Guo. An incremental bond-based peridynamic method for elastoplastic problems. InternationalÂ JournalÂ forÂ NumericalÂ MethodsÂ inÂ Engineering 124, 3875â€“3902 (2023).\n\n\n\nS.Â A.Â Silling, M.Â Epton, O.Â Weckner, J.Â Xu and E.Â Askari. Peridynamic States and Constitutive Modeling. JournalÂ ofÂ Elasticity 88, 151â€“184 (2007).\n\n\n\nM.Â R.Â Tupek. Extension of the peridynamic theory of solids for the simulation of materials under extreme loadings. Ph.D. Thesis, Massachusetts Intitute of Technology (2014).\n\n\n\nM.Â Breitenfeld, P.Â Geubelle, O.Â Weckner and S.Â A.Â Silling. Non-ordinary state-based peridynamic analysis of stationary crack problems. ComputerÂ MethodsÂ inÂ AppliedÂ MechanicsÂ andÂ Engineering 272, 233â€“250 (2014).\n\n\n\nH.Â Chen. Bond-associated deformation gradients for peridynamic correspondence model. MechanicsÂ ResearchÂ Communications 90, 34â€“41 (2018).\n\n\n\nP.Â Li, Z.Â Hao and W.Â Zhen. A stabilized non-ordinary state-based peridynamic model. ComputerÂ MethodsÂ inÂ AppliedÂ MechanicsÂ andÂ Engineering 339, 262â€“280 (2018).\n\n\n\nM.Â Tupek and R.Â Radovitzky. An extended constitutive correspondence formulation of peridynamics based on nonlinear bond-strain measures. JournalÂ ofÂ theÂ MechanicsÂ andÂ PhysicsÂ ofÂ Solids 65, 82â€“92 (2014).\n\n\n\nC.Â Wu. Kinematic constraints in the state-based peridynamics with mixed local/nonlocal gradient approximations. ComputationalÂ Mechanics 54, 1255â€“1267 (2014).\n\n\n\nC.Â Wu and B.Â Ren. A stabilized non-ordinary state-based peridynamics for the nonlocal ductile material failure analysis in metal machining process. ComputerÂ MethodsÂ inÂ AppliedÂ MechanicsÂ andÂ Engineering 291, 197â€“215 (2015).\n\n\n\nJ.Â Wan, Z.Â Chen, X.Â Chu and H.Â Liu. Improved method for zero-energy mode suppression in peridynamic correspondence model. ActaÂ MechanicaÂ Sinica 35, 1021â€“1035 (2019).\n\n\n\nS.Â A.Â Silling. Stability of peridynamic correspondence material models and their particle discretizations. ComputerÂ MethodsÂ inÂ AppliedÂ MechanicsÂ andÂ Engineering 332, 42â€“57 (2017).\n\n\n\nS.Â Oterkus, E.Â Madenci and A.Â Agwai. Fully coupled peridynamic thermomechanics. JournalÂ ofÂ theÂ MechanicsÂ andÂ ModelsÂ ofÂ Solids 64, 1â€“23 (2014).\n\n\n\nO.Â C.Â Zienkiewicz, R.Â L.Â Taylor and J.Â Z.Â Zhu. The Finite Element Method: Its Basis and Fundamentals. 7thÂ Edition (Butterworth-Heinemann, 2013).\n\n\n\nC.Â Willberg. Development of a new isogeometric finite element and its application for Lamb wave based structural health monitoring. Dissertation, Otto von Guericke University Magdeburg (2012). Open-Access-Publikation.\n\n\n\nM.Â Abramowitz and I.Â A.Â Stegun. Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables. Vol.Â 55 of Applied Mathematics Series (United States Department of Commerce, National Bureau of Standards; Dover Publications, Washington D.C.; New York, 1983); p.Â 878. [June 1964], Ninth reprint with additional corrections of tenth original printing with corrections (December 1972); first edition.\n\n\n\nA.Â Pernatii, U.Â Gabbert, K.Â Naumenko, J.-T.Â Hesse and C.Â Willberg. A Penalty Method for Coupling of Finite-Element and Peridynamic Models. PAMM 22, e202200151 (2023).\n\n\n\nC.Â Willberg, J.-T.Â Hesse and A.Â Pernatii. Version v1.3.6 - PeriLab - Peridynamic Laboratory. SoftwareX 31, 102168 (2025).\n\n\n\nQ.Â V.Â Le and F.Â Bobaru. Surface corrections for peridynamic models in elasticity and fracture. ComputationalÂ Mechanics 61, 499â€“518 (2018).\n\n\n\nC.Â J.Â Lammi and T.Â J.Â Vogler. A Nonlocal Peridynamic Plasticity Model for the Dynamic Flow and Fracture of Concrete. Technical ReportÂ SAND2014-18257 (Sandia National Laboratories, 2014).\n\n\n\nA.Â Masoumi, M.Â Salehi and M.Â Ravandi. A modified bond-based peridynamic model without limitations on elastic properties. EngineeringÂ AnalysisÂ withÂ BoundaryÂ Elements 149, 261â€“281 (2023).\n\n\n\nA.Â Pernatii, D.Â Filiurskyi, U.Â Gabbert, J.-T.Â Hesse and C.Â Willberg. Brittle fracture investigation in a coupled FEM-PD model. PAMM 24, e202400021 (2024).\n\n\n\nE.Â Madenci and E.Â Oterkus. Peridynamic Theory and Its Applications (Springer New York, 2014).\n\n\n\nJ.Â T.Â Foster, S.Â A.Â Silling and W.Â Chen. An Energy based Failure Criterion for use with Peridynamic States. InternationalÂ JournalÂ forÂ MultiscaleÂ ComputationalÂ Engineering 9, 675â€“688 (2011).\n\n\n\nM.Â RÃ¤del, A.-J.Â Bednarek and C.Â Willberg. Influence of probabilistic material distribution in peridynamics to the crack initiation. In: 6th ECCOMAS Thematic Conference on the Mechanical Response of Composites: COMPOSITES 2017 (2017).\n\n\n\nR.Â Brighenti, M.Â A.Â Zeleke and M.Â B.Â Ageze. A Review of Peridynamics (PD) Theory of Diffusion Based Problems. JournalÂ ofÂ Engineering, 20 (2021).\n\n\n\nD.Â J.Â Littlewood, J.Â D.Â Thomas and T.Â Shelton. Estimation of the Critical Time Step for Peridynamic Models. In: Proceedings of the 12th U.S. National Congress on Computational Mechanics (2013).\n\n\n\n\n\n","category":"section"},{"location":"man/mesh_input/#Mesh-Input-File-Structure","page":"Mesh and Nodesets","title":"Mesh Input File Structure","text":"The mesh input file is a text or exodus file used to define the geometry of the simulation domain. The file has a header and subsequent lines representing individual nodes with their corresponding coordinates, block IDs, volumes, and optional user-defined values. Below is an example of the structure:","category":"section"},{"location":"man/mesh_input/#Header","page":"Mesh and Nodesets","title":"Header","text":"The header of the mesh input file specifies the format of the subsequent data columns. In this example, the header consists of the following columns:\n\nVariable definition\n\nParameter Datamanager name Header name 2D Header name 3D Type\nx, y, z (optional) coordinate of the node Coordinates x, y x, y, z Float64, Int64\nDefinition to which block the node corresponds. Is needed in the Yaml file to define properties Block_Id block_id block_id Int64\nVolume the node represents. Volume volume volume Float64, Int64\n\nOptional\n\nParameter Datamanager name Header name 2D Header name 3D Type\nOrientation of a Node Angles Angles Anglesx, Anglesy, Anglesz Float64, Int64\nActivation time of a node, e.g. used for additive manufacturing to define when the node will be acativated Activation_Time Activation_Time Activation_Time Float64, Int64\nStatus of the node. If it is false the node is deactivated, but exists. This variable is automatically created if additive models are used and set everywhere to false, if it is not predefined Active Active Active Bool\n\nThe difference between 2D and 3D is found automatically. If no z occurs PeriLab identifies it as 2D problem and requests a plane stress or plane strain definition.\n\ntip: Additional parameter\nAdditional parameter can be applied in the header. They will be added in the datamanager and can be used in the programm. If you add x,y,z to the parameter a multidimensional field will be created, e.g. MyVarx, MyVary will be created as field MyVar with 2 degrees of freedom","category":"section"},{"location":"man/mesh_input/#Data-Lines","page":"Mesh and Nodesets","title":"Data Lines","text":"The data lines represent individual nodes in the mesh, with values corresponding to the columns specified in the header.\n\nExample Data Lines:\n\nheader: x y block_id volume\n0.0 0.0 1 1.0E-02\n0.1 0.0 1 1.0E-02\n0.1 0.1 1 1.0E-02\n...\n\nPeriLab:\n  Discretization:\n    Input Mesh File: example.txt","category":"section"},{"location":"man/mesh_input/#Abaqus-Input","page":"Mesh and Nodesets","title":"Abaqus Input","text":"You can use the Abaqus input file to define the geometry of the simulation domain. In order to do that, refer in the input deck to your .inp file:\n\nPeriLab:\n  Discretization:\n    Input Mesh File: ABAQUS_FILE.inp\n    Type: Abaqus\n\nAll elements that are defined in a element set in the Abaqus input file will be translated to PeriLab nodes. The center and volume of the elements will be calculated automatically. Have a look at the AbaqusReader.jl package to see what elements are supported.\n\nwarning: Supported elements\nCurrently only Quad4, Tet4, Wedge6 and Hex8 elements are tested!","category":"section"},{"location":"man/mesh_input/#How-to-define-blocks-and-nodesets-with-Abaqus?","page":"Mesh and Nodesets","title":"How to define blocks and nodesets with Abaqus?","text":"The element sets are defined in the Abaqus input file and can be used to define blocks and nodesets. The order of the blocks will be similar to the order in the .inp file. Nodesets can be referenced via the correspoinding element set in the Abaqus input file.\n\ntip: Block order\nIf you are not sure what order the blocks in the .inp file will be read in, you can use PeriLab to create an exodus file and check the order of the blocks in ParaView.","category":"section"},{"location":"man/mesh_input/#Nodeset-Input-File-Structure","page":"Mesh and Nodesets","title":"Nodeset Input File Structure","text":"The nodeset input file is a text file used to define sets of nodes in the simulation domain. The file has a header and subsequent lines representing individual node global IDs that belong to the nodeset. Below is an example of the structure:","category":"section"},{"location":"man/mesh_input/#Header-2","page":"Mesh and Nodesets","title":"Header","text":"The header of the nodeset input file specifies the format of the subsequent data columns. In this example, the header consists of the following column:\n\nglobal_id: Global ID of the node.","category":"section"},{"location":"man/mesh_input/#Data-Lines-2","page":"Mesh and Nodesets","title":"Data Lines","text":"The data lines represent individual nodes in the nodeset, with values corresponding to the columns specified in the header.\n\nExample Data Lines:\n\nheader: global_id\n1\n2\n11\n12\n\n","category":"section"},{"location":"man/models/thermal/#Thermal-Models","page":"Thermal Models","title":"Thermal Models","text":"The list shows the three main model, thermal expansion, thermal flow and heat transfer. All can use simular parameters to work.\n\nThermal Model Thermal Expansion Thermal Flow Heat Transfer\nType âœ”ï¸ âœ”ï¸ âœ”ï¸\nHeat Transfer Coefficient âœ”ï¸ âœ”ï¸ âœ”ï¸\nEnvironmental Temperature âœ”ï¸ âœ”ï¸ âœ”ï¸\nReference Temperature âœ”ï¸  \nThermal Conductivity   âœ”ï¸\nThermal Expansion Coefficient âœ”ï¸  \nThermal Conductivity Print Bed   âœ”ï¸\nPrint Bed Temperature   âœ”ï¸\n\nThere are block defined properties for needed for the thermal models.\n\nParameter Unit Description\nSpecific Heat Capacity leftfracJkgKright Specific heat capacity of the block\nDensity leftfrackgm^3right Specific heat capacity of the block\nHorizon m Radius of the neighborhood","category":"section"},{"location":"man/models/thermal/#Thermal-Expansion","page":"Thermal Models","title":"Thermal Expansion","text":"Calculates the thermal expansion of the material.\n\nParameter Unit Description\nThermal Expansion Coefficient left1Kright Thermal expansion can be a 3times3 matrix.\nReference Temperature K Reference temperature for the thermal expansion coefficient.\n\ninfo: Thermal expansion\nPeriLab supports currently only isotropic thermal expansion.","category":"section"},{"location":"man/models/thermal/#Thermal-Flow","page":"Thermal Models","title":"Thermal Flow","text":"Parameter Unit Description\nThermal Conductivity leftfracWmKright ","category":"section"},{"location":"man/models/thermal/#Heat-Transfer","page":"Thermal Models","title":"Heat Transfer","text":"Parameter Unit Description\nHeat Transfer Coefficient leftfracWm^2Kright Coefficient describing the heat transfer between a solid and a gas or liquid","category":"section"},{"location":"man/models/thermal/#Model-merging","page":"Thermal Models","title":"Model merging","text":"In PeriLab you are able to combine models with each other, by simply adding a +. Therefore, modules can be merged and double coding can be avoided. This is necessary if you want to model the heating of a model and its expansion.\n\ntip: Full Model\nIf you want to run a full thermal model Thermal Flow + Heat Transfer + Thermal Expansion.\n\ntip: Model order\nThe order is defined by the user. Therfore, in this example first the flow, than the transfer to the environment and than the expansion will be calculated.\n\n","category":"section"},{"location":"man/dev/testing/#Software-testing","page":"Software Testing","title":"Software testing","text":"The testing takes place manually or if commits are submitted to the repository. Make sure that all test are reasonably complex and won't take to much time. The testing coverage is checked as well.\n\nwarning: Code quality\nTests only handle expected results and helps that code stays as intended after further development. It does not guarantee that not error occur.\n\ninfo: New tests\nIf new unexpected errors occur, please add an test to check possible exception to avoid them next time.","category":"section"},{"location":"man/dev/testing/#Runtests.jl","page":"Software Testing","title":"Runtests.jl","text":"The tests to perform are defined in the runtests.jl within the test folder. The structure is as follows.\n\n@testset ExtendedTestSet \"PeriLab\" begin\n\n    @testset \"unit_tests\" begin\n        @testset \"Compute\" begin\n            @testset \"ut_compute_global_values\" begin\n                include(filepath + filename)\n            end\n            @testset \"ut_compute_field_values\" begin\n                include(filepath + filename)\n            end\n        end\n    end\n\n    @testset \"full_scale\" begin\n        ...\n    end\n\nAfter testing you will get an overview over failed or errored tests. The test set structure helps to identify the position of errors.\n\ninfo: Error & Fails\nError means that the code of the test has an error. Typically the function call is flawed. Fail means that the test is wrong, e.g. 2==3","category":"section"},{"location":"man/dev/testing/#Unit-tests","page":"Software Testing","title":"Unit tests","text":"Unit tests are tests to check functions. To do that you add a file the the unit_tests folder. The folder has the same structure as the src folder. Please add your test in place of the src code file where your function is located. It helps to find the tests. Add your tests (please take examples from already existing tests).\n\ninfo: Exceptions\nIn this tests the exeptions should be tested, because full scale tests are not capable of.","category":"section"},{"location":"man/dev/testing/#Full-scale-test","page":"Software Testing","title":"Full scale test","text":"Full scale models should be used to test features within a complete analyses. A complete model is run and tested against the result file. This can be done for single and multi core simulations.\n\nHow to set up? To create such test, you have to create a ''normal'' model and run it. Create a folder of your test and put all the information for the model inside. Create .jl file in the following structure\n\n    folder_name = basename(@__FILE__)[1:end-3]\n    cd(\"fullscale_tests/\" * folder_name) do\n        run_perilab(\"additive_2d\", 1, true, folder_name)\n        run_perilab(\"additive_2d_heat\", 1, true, folder_name)\n        run_perilab(\"additive_3d\", 1, true, folder_name)\n    end\n\nCode should be tested in parallel as shown below. The effect of core distribution is tested. The reference is the single core solution.\n\n    folder_name = basename(@__FILE__)[1:end-3]\n    cd(\"fullscale_tests/\" * folder_name) do\n        run_perilab(\"additive_3d\", 1, true, folder_name)\n        run_perilab(\"additive_3d\", 2, true, folder_name)\n        run_perilab(\"additive_3d\", 3, true, folder_name)\n        run_perilab(\"additive_3d\", 4, true, folder_name)\n    end\n\nThis file has to be called in the runtests.jl. You are able to define  .cmd with the following input if specific tolerances are needed.\n\nDEFAULT TOLERANCE absolute 1.0E-9\nCOORDINATES absolute 1.0E-12\nTIME STEPS absolute 1.0E-14\nNODAL VARIABLES absolute 1.0E-12\n    Temperature   absolute 1.0E-8\n    Heat Flow     absolute 1.0E-8\n    Active        absolute 1.0E-8\n\nwarning: Naming convention\nNames of the .yaml input and the output must be the same.\n\ninfo: License\nUse licensing files for files which are not ascii.","category":"section"},{"location":"man/dev/testing/#Examples","page":"Software Testing","title":"Examples","text":"Examples should be given for more complex models used in papers. Here it should be refered to the commit hash (when it worked) and the paper where the model was used. These models won't run automatically. But they help to reproduce the results and make them more transparent.\n\n","category":"section"},{"location":"man/models/materials/#Material-Models","page":"Material Models","title":"Material Models","text":"","category":"section"},{"location":"man/models/materials/#Existing-Models","page":"Material Models","title":"Existing Models","text":"The models related functions can be found here.\n\nMethod Related Model in PeriLab\nBond-based Bond-based Elastic\nOrdinary state-based PD Solid Elastic, PD Solid Plastic\nNon-ordinary state-based Correspondence Elastic, Correspondence Plastic, Correspondence UMAT\n\nMaterial Model Bond-based Elastic PD Solid Elastic PD Solid Plastic Correspondence Elastic Correspondence Plastic\nSymmetry âœ”ï¸ âœ”ï¸ âœ”ï¸ âœ”ï¸ âœ”ï¸\nPoisson's/Young's/Bulk/Shear âœ”ï¸ âœ”ï¸ âœ”ï¸ âœ”ï¸ âœ”ï¸\nYield Stress   âœ”ï¸  âœ”ï¸\nZero Energy Control    âœ”ï¸ âœ”ï¸\nC11/C12/.../C66 (âœ”ï¸) (âœ”ï¸) (âœ”ï¸) (âœ”ï¸) (âœ”ï¸)\n\nParameter Unit Description\nDensity leftfrackgm^3right Specific heat capacity of the block\nHorizon m Radius of the neighborhood","category":"section"},{"location":"man/models/materials/#Bond-based-Elastic","page":"Material Models","title":"Bond-based Elastic","text":"The Bond-based Elastic calculates the linear elastic behavior of a simple bond-based material. The theory of the bond-based elastic material can be found here.\n\nParameter Unit Description\nYoungs Modulus leftNm^2right Young's modulus or elasticity modulus\nShear Modulus leftNm^2right Shear modulus\nBulk Modulus leftNm^2right Bulk modulus or compression modulus\n\nOne of theses parameters have to be defined.\n\ninfo: Fixed Poisson's ratio\nIn the bond-based formulation the Poisson's ratio is fixed by 0.25 for 2D plane strain and 1/3 for 3D and 2D plane stress, respectively.","category":"section"},{"location":"man/models/materials/#PD-Solid-Elastic","page":"Material Models","title":"PD Solid Elastic","text":"The PD Solid Elastic module calculates the isotropic linear elastic material law for a peridynamic solid material. The underlying theory can be found here.\n\nParameter Unit Description\nYoungs Modulus leftNm^2right Young's modulus or elasticity modulus\nShear Modulus leftNm^2right Shear modulus\nBulk Modulus leftNm^2right Bulk modulus or compression modulus\nPoissons Ratio Modulus left-right Poisson's ratio\n\nTwo of these parameters have to be defined. The other two are determined automatically and can be used in the model if needed.","category":"section"},{"location":"man/models/materials/#PD-Solid-Plastic","page":"Material Models","title":"PD Solid Plastic","text":"The PD Solid Plastic material uses elastic stresses and calculate the plastic part for a peridynamic solid material. Has to be combined with a function, which provides elastic stresses.\n\nParameter Unit Description\nYield Stress leftNm^2right Yield stress","category":"section"},{"location":"man/models/materials/#Correspondence-Elastic","page":"Material Models","title":"Correspondence Elastic","text":"The Correspondence Elastic module calculates the fully anisotropic linear elastic material law. The underlying correspondence theory can be found here.\n\nParameter Unit Description\nYoungs Modulus leftNm^2right Young's modulus or elasticity modulus\nShear Modulus leftNm^2right Shear modulus or elasticity modulus\nBulk Modulus leftNm^2right Bulk modulus or compression modulus\nPoissons Ratio Modulus left-right Poisson's ratio\nC11, C12, ..., C66 (optional) leftNm^2right Parameter of the Hook matrix\n\nFor Correspondence Elastic you can provide all 27 elastic parameters if you like by adding C11,...,C66.\n\ntip: Isotropic elastic parameter\nFor the time step calculation two of the four isotropic elastic parameter have to be defined.\n\ntip: Material Rotation\nIf you define a field \"Angles\" for 2D or \"Anglesx\", \"Anglesy\" and \"Anglesz\" for 3D in the mesh file your material will be rotated. This helps to create an arbitrary material orientation.","category":"section"},{"location":"man/models/materials/#Correspondence-Plastic","page":"Material Models","title":"Correspondence Plastic","text":"The Correspondence Plastic material uses elastic stresses and calculate the plastic part. Has to be combined with a function, which provides elastic stresses.\n\nParameter Unit Description\nYield Stress leftNm^2right Yield stress","category":"section"},{"location":"man/models/materials/#Correspondence-UMAT","page":"Material Models","title":"Correspondence UMAT","text":"The Correspondence UMAT can be used to include Abaqus user materials.\n\nwarning: Replace ABAQUS Functions\nNo extra Abaqus functions should be called in the user subroutine. For example INCLUDE 'ABA_PARAM.INC' needs to be replaced by implicit real(8) (a-h,o-z)\n\nYou can call the user subroutine by defining path with a compiled Fotran library. [5] gives an overview about the interface for Peridigm. In PeriLab all fields in the UMAT interface are supported execpt these integer (NOEL, NPT, LAYER, KSPT, JSTEP, KINC) and float values (PNEWDT, CELENT). In the material module these values defined for the interfase and named as notsupportedint and notsupportedfloat, respectively.\n\nParameter Type and Range Description Optional\nFile String Path and filename of the UMAT, e.g. \"./src/Models/Material/UMATs/libusertest.so\" No\nNumber of State Variables Int geq 0 Number of state variables; Defines the size of state variable field DataManager.createconstantnodescalarfield(\"State Variables\", Float64, numstate_vars) yes\nNumber of Properties Int geq 1 Properties of the material; Needed for the propterty field DataManager.createconstantfreesizefield(\"Properties\", Float64, (numprops, 1)) \n No  \nProperty_iID Float iID is 1...Number of Properties. It has to be in order and can be utilized in the UMAT. No\nUMAT Material Name String (maximum are 80 characters) Defines material names defined in the UMAT to destinguash between different areas of the Fortran routine Yes\nUMAT name in development Should allow the definition of own subroutine name. The standard will be UMAT in development\nPredefined Field Names String separated by spaces geq0 Define all the fields in the mesh file which should be used as pre-defined values. An increment field is than defined as well. E.g. Predefined Field Names: \"Temperature\" \"Color\"; Temperature and Color must exist in the mesh file. They must be defined as Float or Int in that case. Yes","category":"section"},{"location":"man/models/materials/#Compilation-of-the-UMAT-subroutine","page":"Material Models","title":"Compilation of the UMAT subroutine","text":"In order to compile the UMAT subroutine you need to install gfortran. Have a look at this page. After installation you can compile the Fortran subroutine with the following command:\n\ngfortran -shared -fPIC -o libusermat.so base.f","category":"section"},{"location":"man/models/materials/#Model-merging","page":"Material Models","title":"Model merging","text":"In PeriLab you are able to combine models with each other, by simply adding a +. Therefore, modules can be merged and double coding can be avoided.\n\ntip: Elastic platic\nIf you want to run elastic platic please use Correspondence Elastic + Correspondence Plastic or PD Solid Elastic + PD Solid Plastic\n\nwarning: Model order\nThe order is defined by the user. Because the plastic routines need stresses to work, make sure the materials which provide these stresses are before the plastic models.\n\n","category":"section"},{"location":"man/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"The PeriLab package is available through the Julia package system and can be installed using the following commands:\n\nusing Pkg\nPkg.add(\"PeriLab\")\n\nThroughout the rest of this tutorial, we will assume that you have installed the PeriLab package and have already typed using PeriLab to bring all of the relevant variables into your current namespace.","category":"section"},{"location":"man/getting_started/#Using-PeriLab","page":"Getting Started","title":"Using PeriLab","text":"The simplest way to run the PeriLab simulation core is to use a provided example import the module and go. \n\nusing PeriLab\n\nPeriLab.get_examples()\nPeriLab.main(\"examples/DCB/DCBmodel.yaml\")\n\nThe output should look like this:\n\n<script src=\"https://asciinema.org/a/649032.js\" id=\"asciicast-649032\" async=\"true\"></script>\n\nThe main functionalities for the yaml input deck is given in\n\n\"examples/functionalities.yaml\"","category":"section"},{"location":"man/getting_started/#Using-PeriLab-with-multiple-processors-(MPI)","page":"Getting Started","title":"Using PeriLab with multiple processors (MPI)","text":"In order to run PeriLab for large scale problems MPI needs to be installed:\n\n$ julia\njulia> using MPI\njulia> MPI.install_mpiexecjl()\n\nRun PeriLab with two processors:\n\n$ mpiexecjl -n 2 julia -e \"using PeriLab; PeriLab.main()\" Dogbone.yaml -v","category":"section"},{"location":"man/getting_started/#Training","page":"Getting Started","title":"Training","text":"The training input is given under the examples folder. The documentation and a video will follow.","category":"section"},{"location":"man/getting_started/#Index","page":"Getting Started","title":"Index","text":"Pages = [\"gettin_started.md\"]","category":"section"},{"location":"man/getting_started/#Functions","page":"Getting Started","title":"Functions","text":"","category":"section"},{"location":"man/getting_started/#PeriLab.main","page":"Getting Started","title":"PeriLab.main","text":"main()\n\nEntry point for the PeriLab application.\n\nThis function serves as the entry point for the PeriLab application. It calls the core main function with the provided arguments.\n\n\n\n\n\nmain(filename::String, output_dir::String=\"\", dry_run::Bool=false, verbose::Bool=false, debug::Bool=false, silent::Bool=false, reload::Bool=false)\n\nEntry point for the PeriLab application.\n\nThis function serves as the entry point for the PeriLab application. It calls the core main function with the provided arguments.\n\nArguments\n\nfilename::String: The filename of the input file.\noutput_dir::String: The output directory.\ndry_run::Bool=false: Whether to run in dry-run mode.\nverbose::Bool=false: Whether to run in verbose mode.\ndebug::Bool=false: Whether to run in debug mode.\nsilent::Bool=false: Whether to run in silent mode.\nreload::Bool=false: Whether to reload the input file.\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#PeriLab.get_examples","page":"Getting Started","title":"PeriLab.get_examples","text":"get_examples()\n\nCopy the examples folder to the current directory.\n\n\n\n\n\n","category":"function"},{"location":"devLog/","page":"-","title":"-","text":"<!â€“ SPDX-FileCopyrightText: 2023 Christian Willberg <christian.willberg@dlr.de>, Jan-Timo Hesse <jan-timo.hesse@dlr.de>\n\nSPDX-License-Identifier: BSD-3-Clause â€“>","category":"section"},{"location":"devLog/#Dev-Steps","page":"-","title":"Dev Steps","text":"Developement plan\n\nBond associated neighborhood is the overlap between nlist[iID] and nlist[nlist[iID][jID]]\nFilter equal nodes and create a new neighborhoodlist for bond -> bond_nlist\ncalculate K, Kinv and defGrad -> already there if the neighborhood loop is in a function\nweighted volume (sum(volume(bond_nlist))/sum(volume[nlist[iID]]))\n\nIf this works for one core the following will be introduced\n\nall neighbors search for neighbors at each core\nnumbers are correct and it allows a change in size -> local ID is correct","category":"section"},{"location":"devLog/#Design-decisions","page":"-","title":"Design decisions","text":"Each vector entry for a value exists for all nodes, also if the node does not have this property in a block. However, the synchronisation is very ugly, because all responder nodes of block with value I need the entry at the other core to. If not it will lead nowhere if MPI communication occurs\n\nIO\nnodesets are not defined yet in Exodus.jl\n\nsnake_case for variables and functions\nPascalCase for modules and type names\nFULL_UPPERCASE for constants\nStiffness matrix is stored as sparse to reduce memory requirments","category":"section"},{"location":"devLog/#Issues","page":"-","title":"Issues","text":"for n=4 -> errors\nMPI_Neighbor_alltoall -> might be easier","category":"section"},{"location":"devLog/#planned-feature","page":"-","title":"planned feature","text":"test if blocks are defined in yaml, but missing in mesh\nhttps://github.com/StephenVavasis/Unroll.jl\nintegration of FEM Julia package -> coupling might be better, because of more functionality\ntime step minimum for all cores -> parallel computing! -> done\nsearch for jl files in material\ncheck the header for the material name\ninclude the file in the code via a makro\nmaterial inclusion is very simple\nbonds as elements in exodus -> filter small to large writing ?! -> elements can be x,y to be represented both\nmultiple materials in one block -> evaluation order\n\n","category":"section"},{"location":"lecture/seminar_8/#Seminar-8:-Additive-manufacturing","page":"Seminar 8","title":"Seminar 8: Additive manufacturing","text":"underlineomegalangleboldsymbolxirangle in mathcalH_textbfx =    leftbeginarrayl\n0 qquadtextfor tt_activate\n1  qquadtextfor t geq t_activate\nendarrayright\n\n(Image: Virtual printing process)\n\nfigure (taken from [9]).\n\n    Additive Models:\n      Test:\n        Additive Model: \"Simple\"\n        Print Temperature: 100\n\nAdditve Result\n\nboldsymbolvarepsilon=boldsymbolvarepsilon_mechanical + boldsymbolvarepsilon_thermal\n\nboldsymbolvarepsilon_thermal =- boldsymbolalphatau\n\nboldsymbolsigma=mathbfCcdotcdotleft(boldsymbolvarepsilon_mechanical - boldsymbolalphatau right)\n\nFor bond 1 the stresses are zero, if varepsilon_mechanical = boldsymbolalphatau\n\nduring a printing process this holds true for each step t. Assumed that tau_it_printtau_it_print + Delta t, leads to following effect. t_jprint = t_iprint + Delta t varepsilon_imechanical = boldsymbolalphatau_it_print + Delta t varepsilon_jmechanical = boldsymbolalphatau_jt_print\n\nvarepsilon_imechanicalneqvarepsilon_jmechanical\n\nThis leads to internal stresses or forces.\n\n\nusing LinearAlgebra\n\n\nfunction K_stiff(np, c, omega, V)\n    K=zeros(np,np)\n    for iID in 1:np\n        for jID in -nn:nn\n            if jID != 0 && iID + jID > 0 && iID + jID < np + 1\n                xi = L*abs(jID)\n                K[iID, iID + jID] -= 0.5 * c[iID] / xi * V * omega[iID, iID + jID]\n                K[iID, iID]      +=  0.5 *c[iID] / xi * V * omega[iID, iID + jID]\n            end\n        end\n    end\n    K[np, :] .= 0\n    K[:, np] .= 0\n    K[np, np] = 1\n    return K\nend\n\nE = 1\nV = 1\nL = 1\nnp = 8\nnn = 2\ndelta = 1\nu = collect(1:np)\n\nomega=ones(np, np)\n\n\n##\nc=zeros(np)\nc .= 2*E/delta^2\n\nK_f = K_stiff(np, c, omega, V)\nK_f[1,:] .= 0; K_f[:,1] .= 0; K_f[1,1] = 1\nF=K_f*u\n\nc[6]=2.0 .*c[6]\n\nK_s = K_stiff(np, c, omega, V)\n\nK_s[1,:] .= 0; K_s[:,1] .= 0; K_s[1,1] = 1\n\nu_error=inv(K_s)*F\ndisplay(u-u_error)\n\ninteral_force = K_s*(u-u_error)\ndisplay(internal_force)\n\n","category":"section"},{"location":"lib/links/#Useful-Tools-and-Links","page":"Useful Links","title":"Useful Tools and Links","text":"Below you can find a summary of some useful tools and links, that can help you get started with PeriLab and Peridynamics.\n\nLink Description\nPeriLab The source code for PeriLab\nDocker Image Ready to use Docker Image\nPeriLab-Results Web-service for PeriLab Results\nPeriHub Web-Framework and API for PeriLab\nParaView Open source visualization software\nYouTube Our YouTube channel\nJuliaHub Platform for scientific computing\n\nIf you want to contribute to the development of PeriLab, here are some recommended tools to get started:\n\nLink Description\nVisual Studio Code Open source code editing\nJulia Open source programming language for scientific computing\nJulia Extension VS Code extension for Julia programming\n\n","category":"section"},{"location":"theory/theory_surface_correction/#Surface-correction","page":"Surface Correction","title":"Surface correction","text":"There are several ways to deal with the surface correction in Peridynamics. The issue is caused, because parts of the intergral domain mathcalH near a surface lies outside of the material or is mixed between materials (shown in the figure). This leads to errors in the computation of the force densities. For smaller horizons, obviously this effect can be reduced. However, there are several methods to mitigate the issue described in this study [30].\n\n(Image: )","category":"section"},{"location":"theory/theory_surface_correction/#Volume-correction","page":"Surface Correction","title":"Volume correction","text":"Following the study of Le and Bobaru\n\ninfo: Quote [LeQV2018](@cite)\nthe simplest correction methods to implement, the volume correction method, also appear to be one of the most effective. Correction methods reduce the PD surface effect faster (more efficiently) than simply using a smaller horizon (problem shown in the figure).\n\na volume corrections factor lambda_corr is introduced deviding the domain volume V_0 by the avarage of the domain volumes of point  mathbfx and mathbfx.\n\nlambda_corr=frac2V_0V(mathbfx)+V(mathbfx)\n\n(Image: ) The reference volumen V_0 is depended on the dimension (3D or 2D)\n\nV_0-3D=frac4pidelta^33\n\nV_0-2D=fracpidelta^2h4\n\nthis factor is than multiplied to the bond force mathbft_corr =lambda_corrmathbft\n\nwarn: Only mechanical\nSurface correction is right now only applied for mechanical properties.\n\nYou can apply the surface correction initialy for all outer surfaces and continuous, for cracks or additive manufacturing.\n\n","category":"section"},{"location":"lecture/seminar_9/#Seminar-9:-PeriLab-Implement-your-own-model","page":"Seminar 9","title":"Seminar 9: PeriLab - Implement your own model","text":"Plain Model","category":"section"},{"location":"lecture/seminar_9/#Steps","page":"Seminar 9","title":"Steps","text":"choose your model category\ntake the template file, rename it and copy it in the model folder\ngive you model a name, this name defines how you call your model\n\nfunction damage_name()\n    return \"My Model\"\nend\n\n\n Models:\n    Damage Models:\n      Damage:\n        Damage Model: My Model\n\nSpecify your model parameter\n\n Models:\n    Damage Models:\n      Damage:\n        Damage Model: My Model\n        Important value: 200\n\nget this value in the code\n\nfunction init_model(nodes::AbstractVector{Int64},\n                    damage_parameter::Dict,\n                    block::Int64)\n\n    println(damage_parameter[\"Important value\"])\nend\n\ninit_model is used to create model specific fields and to check if values, especially optional values exist\n\nfunction init_model(nodes::AbstractVector{Int64},\n                    damage_parameter::Dict,\n                    block::Int64)\n    if !inothing(get(damage_parameter, \"Important value\", nothing))\n        println(damage_parameter[\"Important value\"])\n    else\n        damage_parameter[\"Important value\"] = 0\n    end\n    my_constant_node_field = Data_Manager.create_constant_node_vector_field(\"my constant node field\", Float64, 10)\n    my_node_field_N, my_node_field_NP1 = Data_Manager.create_node_tensor_field(\"my node field\", Float64, 2)\n    my_constant_bond_field = Data_Manager.create_constant_bond_vector_state(\"my constant bond field\", Float64, 10)\n    my_bobd_field_N,  my_bobd_field_NP1 = Data_Manager.create_bond_vector_state(\"my bond field\", Float64, 10)\n\n   field = Data_Manager.create_constant_free_size_field(Fieldname::String, Type_of_variable::Type, size::NTuple)\n    fieldN, fieldNP1 = Data_Manager.create_free_size_field(Fieldname::String, Type_of_variable::Type, size::NTuple)\n\n   my_free_size_field = Data_Manager.create_constant_free_size_field(\"my free size field\", Bool, (200,1,3,4,1))\nend\n\nIf fields already exist, the field is returned\nGet fields and use them; if you want to now, what fields are already defined and usable\n\nData_Manager.get_all_field_keys()\n\nAll node fields can be exported to the result file\n\nfunction compute_model(nodes::AbstractVector{Int64},\n                       damage_parameter::Dict,\n                       block::Int64,\n                       time::Float64,\n                       dt::Float64,\n                       to::TimerOutput)\n    my_constant_field = Data_Manager.get_field(\"my constant node field\")\n    my_field_N = Data_Manager.get_field(\"my node field\",\"N\")\n    my_field_NP1 = Data_Manager.get_field(\"my node field\",\"NP1\")\n\n    my_field_NP1 .= damage_parameter[\"Important value\"]\nend\n\nIf N and NP1 exist only NP1 will be exported\n\n    Output1:\n      Number of Output Steps: 100\n      Output File Type: Exodus\n      Output Filename: Output_file_name\n      Output Variables:\n        my node field: true\n        my constant node field: true\n\nActivate the model class. Material is set to true by default. The rest is set to zero.\n\n    Solver:\n        Damage Models: true","category":"section"},{"location":"lecture/seminar_9/#Run-your-model","page":"Seminar 9","title":"Run your model","text":"create your yaml with all your parameters\ncreate a mesh file\nrun the model\n\nusing PeriLab\nPeriLab.main(\"Folder where to find your yaml\")","category":"section"},{"location":"lecture/seminar_9/#Remarks","page":"Seminar 9","title":"Remarks","text":"If you define parameter in your mesh, you can call them in PeriLab as well.\n\nheader: x y block_id volume my_values my_datax my_datay\n\nData_Manager.get_field(\"my_values\")\nData_Manager.get_field(\"my_data\")\n\nmydatax and mydatay are a 2D array.\n\ninfo: Mesh defined field properties\nThe variable type is given by the input (Int64, Float64 or Bool) and its a constant field.\n\n","category":"section"},{"location":"theory/theory_bondbased/#Bond-based-Peridynamics","page":"Bond-based","title":"Bond-based Peridynamics","text":"Bond-based Peridynamics is a nonlocal extension of classical continuum mechanics, designed to address discontinuities like cracks within materials. Unlike traditional methods, which use partial differential equations (PDEs) and are based on local interactions, Peridynamics operates on integral equations and accounts for long-range forces.","category":"section"},{"location":"theory/theory_bondbased/#Fundamental-Concepts","page":"Bond-based","title":"Fundamental Concepts","text":"In bond-based Peridynamics, the material is considered as a continuum of particles that interact with each other through bonds. These interactions are not limited to immediate neighbors, allowing the framework to naturally handle the initiation and propagation of cracks.","category":"section"},{"location":"theory/theory_bondbased/#Equation-of-Motion","page":"Bond-based","title":"Equation of Motion","text":"The equation of motion in Peridynamics is an integral equation, differing from the local PDEs in classical mechanics. For a particle at position mathbfx, the equation is:\n\nrho(mathbfx) ddotmathbfu(mathbfx t) = int_mathcalH mathbff(mathbfx mathbfx t)  dV + mathbfb(mathbfx t)\n\nwhere: rho(mathbfx) is the mass density at mathbfx. ddotmathbfu(mathbfx t) is the acceleration at point mathbfx. mathcalH represents the horizon around mathbfx, within which interactions occur. mathbfb(mathbfx t) is the body force term.","category":"section"},{"location":"theory/theory_bondbased/#Interaction","page":"Bond-based","title":"Interaction","text":"The fundamental interaction in bond-based Peridynamics is between pairs of points or particles within a certain horizon distance. The force vector between two points, x and x, is given by:\n\nmathbff(mathbfx mathbfx) = underlineomegalangle boldsymbolxi rangle c  (mathbfu(mathbfx) - mathbfu(mathbfx))\n\nwhere: mathbff(mathbfx mathbfx) is the force vector exerted by the particle at mathbfx on the particle at mathbfx. c is a bond modulus representing the stiffness of the bond. underlineomegalangle boldsymbolxi rangle is a bond-associated influence function. mathbfu(mathbfx) is the displacement of the particle at mathbfx.","category":"section"},{"location":"theory/theory_bondbased/#Bond-Moduli","page":"Bond-based","title":"Bond Moduli","text":"From [11] we get\n\nDimension Bond Stiffness Poisson's ratio\nplane strain: c = frac48 Epi 5 delta^3 fixed nu=025\nplane stress: c = frac9 Epi delta^3 fixed nu=13\n3D: c = frac12 Epi  delta^4 fixed nu=025","category":"section"},{"location":"theory/theory_bondbased/#Unified-Bond-based-Peridynamics","page":"Bond-based","title":"Unified Bond-based Peridynamics","text":"This model was developed by Guan et al. [12] and utilizes the strain identification technique (SIT) [13]. It extends the original bond-based theory and extends it. Poisson's ratios which differs from the proposed ones are allowed. For 3D they defined\n\nmathbff=cleftfrac3  (4nu-1) 2 (1 + nu)varepsilon_m- frac5  (1 - 2nu) 2 (1 + nu) s  rightfracboldsymbolxiboldsymbolxi\n\nvarepsilon_m=fracvarepsilon3\n\nwhere varepsilon is the bond strain, s is the bond stretch and c is the bond stiffness from the bond based formulation.\n\nFor 2D plane stress and plane stress the equations are more complex\n\nmathbff_2D=c_2leftR_as_ij+R_bvarepsilon_mrightfracxi_ijxi_ij\n\nSeveral parameter have to be computed\n\nc_2=leftbeginaligned frac6pi  delta  (1 - 2  nu)(1 + nu)   textplane strain\nfrac6Epidelta^3(1-nu)  textplane stress\nendalignedright\n\nR_a=leftbeginaligned 2(1 + nu) beta I_1   textplane strain\n frac2  (1 - nu)(1 - 2nu) beta  I_1  textplane stress\nendalignedright\n\nR_b=leftbeginaligned 2 (1 + nu)  (1 - beta) I_2   textplane strain\n frac6nu (1 - nu)(1 - 2 nu)^2beta I_1 +\n         2  frac1 - nu1 - 2 nuleft(1 - frac1 + nu1 - 2 nu betaright) I_2  textplane stress\nendalignedright\n\nwith beginalignedbeta = frac5(1-2nu)2(1+nu) I_1 = n  sqrt1 - n^2textand I_2 = n  a  sinh(sqrt1  n^2 - 1)endaligned where n, xi_ik and s_ij are given as\n\nn = fracxidelta\n\nxi_ik=(x_iky_ikz_ik)qquad textand\n\ns_ij=varepsilon_xfracx_ij^2xi_ik^2 + varepsilon_zfracz_ij^2xi_ik^2\n\nThe meaning of a is not specified by Guan et al. [12] and set to one. As can be seen in the equations E and nu can be specified independently.\n\n","category":"section"},{"location":"lib/mpi_functions/#MPI-Functions","page":"MPI","title":"MPI - Functions","text":"","category":"section"},{"location":"lib/mpi_functions/#Index","page":"MPI","title":"Index","text":"Pages = [\"mpi_functions.md\"]","category":"section"},{"location":"lib/mpi_functions/#MPI","page":"MPI","title":"MPI","text":"","category":"section"},{"location":"lib/mpi_functions/#PeriLab.MPI_Communication.send_single_value_from_vector","page":"MPI","title":"PeriLab.MPI_Communication.send_single_value_from_vector","text":"send_single_value_from_vector(comm::MPI.Comm, controller::Int64, values::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}, type::Type)\n\nSends a single value from a vector to a controller\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\ncontroller::Int64: The controller\nvalues::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The values\ntype::Type: The type\n\nReturns\n\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.MPI_Communication.synch_responder_to_controller","page":"MPI","title":"PeriLab.MPI_Communication.synch_responder_to_controller","text":"synch_responder_to_controller(comm::MPI.Comm, overlapnodes, vector, dof)\n\nSynch the responder to the controller\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\noverlapnodes::Dict: The overlap nodes\nvector::Vector: The vector\ndof::Int: The degree of freedom\n\nReturns\n\nvector::Vector: The vector\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.MPI_Communication.synch_controller_to_responder","page":"MPI","title":"PeriLab.MPI_Communication.synch_controller_to_responder","text":"synch_controller_to_responder(comm::MPI.Comm, overlapnodes, vector, dof)\n\nSynch the controller to the responder\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\noverlapnodes::Dict: The overlap nodes\nvector::Vector: The vector\ndof::Int: The degree of freedom\n\nReturns\n\nvector::Vector: The vector\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.MPI_Communication.synch_controller_bonds_to_responder","page":"MPI","title":"PeriLab.MPI_Communication.synch_controller_bonds_to_responder","text":"synch_controller_bonds_to_responder(comm::MPI.Comm, overlapnodes, array, dof)\n\nSynch the controller bonds to the responder\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\noverlapnodes::Dict: The overlap nodes\narray::Array: The array\ndof::Int: The degree of freedom\n\nReturns\n\narray::Array: The array\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.MPI_Communication.split_vector","page":"MPI","title":"PeriLab.MPI_Communication.split_vector","text":"split_vector(input, row_nums, dof)\n\nSplit a vector into a vector of matrices\n\nArguments\n\ninput::Vector: The input vector\nrow_nums::Vector: The row numbers\ndof::Int: The degree of freedom\n\nReturns\n\nresult::Vector: The result vector\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.MPI_Communication.synch_controller_bonds_to_responder_flattened","page":"MPI","title":"PeriLab.MPI_Communication.synch_controller_bonds_to_responder_flattened","text":"synch_controller_bonds_to_responder_flattened(comm::MPI.Comm, overlapnodes, array, dof)\n\nSynch the controller bonds to the responder\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\noverlapnodes::Dict: The overlap nodes\narray::Array: The array\ndof::Int: The degree of freedom\n\nReturns\n\narray::Array: The array\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.MPI_Communication.send_vector_from_root_to_core_i","page":"MPI","title":"PeriLab.MPI_Communication.send_vector_from_root_to_core_i","text":"send_vector_from_root_to_core_i(comm::MPI.Comm, send_msg, recv_msg, distribution)\n\nSends a vector from the root to the core i\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\nsend_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The send message\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The receive message\ndistribution::Vector{Int64}: The distribution\n\nReturns\n\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.MPI_Communication.broadcast_value","page":"MPI","title":"PeriLab.MPI_Communication.broadcast_value","text":"broadcast_value(comm::MPI.Comm, send_msg)\n\nBroadcast a value to all ranks\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\nsend_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The send message\n\nReturns\n\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.MPI_Communication.find_and_set_core_value_min","page":"MPI","title":"PeriLab.MPI_Communication.find_and_set_core_value_min","text":"find_and_set_core_value_min(comm::MPI.Comm, value::Union{Float64,Int64})\n\nFind and set core value sum\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\nvalue::Union{Float64,Int64}: The value\n\nReturns\n\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.MPI_Communication.find_and_set_core_value_max","page":"MPI","title":"PeriLab.MPI_Communication.find_and_set_core_value_max","text":"find_and_set_core_value_max(comm::MPI.Comm, value::Union{Float64,Int64})\n\nFind and set core value max\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\nvalue::Union{Float64,Int64}: The value\n\nReturns\n\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.MPI_Communication.find_and_set_core_value_sum","page":"MPI","title":"PeriLab.MPI_Communication.find_and_set_core_value_sum","text":"find_and_set_core_value_sum(comm::MPI.Comm, value::Union{Float64,Int64})\n\nFind and set core value sum\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\nvalue::Union{Float64,Int64}: The value\n\nReturns\n\nrecv_msg::Union{Int64,Vector{Float64},Vector{Int64},Vector{Bool}}: The received message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.MPI_Communication.find_and_set_core_value_avg","page":"MPI","title":"PeriLab.MPI_Communication.find_and_set_core_value_avg","text":"find_and_set_core_value_avg(comm::MPI.Comm,\n                                 value::T,\n                                 nnodes::Int64) where {T<:Union{Float64,Int64}}\n\nFind and set core value avg\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\nvalue::Union{Float64,Int64}: The value\n\nReturns\n\nrecv_msg::Float64: The received a Float64 message\n\n\n\n\n\n","category":"function"},{"location":"lib/mpi_functions/#PeriLab.MPI_Communication.gather_values","page":"MPI","title":"PeriLab.MPI_Communication.gather_values","text":"gather_values(comm::MPI.Comm, value::Any)\n\nGather values\n\nArguments\n\ncomm::MPI.Comm: The MPI communicator\nvalue::Any: The value\n\nReturns\n\nrecv_msg::Any: The received message\n\n\n\n\n\n","category":"function"},{"location":"theory/theory_plastic/#Plastic-models","page":"Elastic Plastic","title":"Plastic models","text":"In PeriLab J2 plasticity model (von Mises plasticity) is implemented for correspondence-based and ordinary state-based Peridynamics. The plastic model was taken from Peridigm and translated into julia. The theoretical basis can be found here [31].\n\ninfo: Isotropic model\n\n\nThis model works only for isotropic yield stresses.","category":"section"},{"location":"theory/theory_plastic/#Fundamental-Theory","page":"Elastic Plastic","title":"Fundamental Theory","text":"","category":"section"},{"location":"theory/theory_plastic/#J2-Plasticity-(von-Mises-Plasticity)","page":"Elastic Plastic","title":"J2 Plasticity (von Mises Plasticity)","text":"The J2 plasticity theory is based on the von Mises yield criterion, which states that yielding occurs when the von Mises stress reaches a critical value (yield stress). This theory is particularly suitable for ductile materials like metals.","category":"section"},{"location":"theory/theory_plastic/#Stress-Decomposition","page":"Elastic Plastic","title":"Stress Decomposition","text":"The total stress tensor Ïƒ is decomposed into:\n\nboldsymbolsigma = boldsymbols + pmathbfI\n\nwhere:\n\ns is the deviatoric stress tensor\np is the spherical (hydrostatic) stress\nI is the identity tensor\n\nThe spherical stress is calculated as:\n\np = frac13texttr(boldsymbolsigma) = frac13(sigma_11 + sigma_22 + sigma_33)\n\nThe deviatoric stress tensor is:\n\nboldsymbols = boldsymbolsigma - pmathbfI","category":"section"},{"location":"theory/theory_plastic/#von-Mises-Stress","page":"Elastic Plastic","title":"von Mises Stress","text":"The von Mises equivalent stress is defined as:\n\nsigma_vM = sqrtfrac32boldsymbolsboldsymbols = sqrtfrac32s_ijs_ij\n\nThis can also be written as:\n\nsigma_vM = sqrt3J_2\n\nwhere Jâ‚‚ is the second invariant of the deviatoric stress tensor.","category":"section"},{"location":"theory/theory_plastic/#Yield-Criterion","page":"Elastic Plastic","title":"Yield Criterion","text":"The yield condition is:\n\nf = sigma_vM - sigma_y leq 0\n\nwhere:\n\nf is the yield function\nÏƒáµ§ is the yield stress (possibly reduced by flaw functions)\n\nElastic regime: If f < 0, the material remains elastic and stresses are unchanged.\n\nPlastic regime: If f â‰¥ 0, plastic deformation occurs and stresses must be returned to the yield surface.","category":"section"},{"location":"theory/theory_plastic/#Return-Mapping-Algorithm","page":"Elastic Plastic","title":"Return Mapping Algorithm","text":"When the trial stress exceeds the yield surface, a radial return mapping is applied to the deviatoric stress:","category":"section"},{"location":"theory/theory_plastic/#Step-1:-Calculate-Trial-Deviatoric-Stress-Magnitude","page":"Elastic Plastic","title":"Step 1: Calculate Trial Deviatoric Stress Magnitude","text":"boldsymbols^trial = fracsigma_vM^trialsqrtfrac23","category":"section"},{"location":"theory/theory_plastic/#Step-2:-Scale-Deviatoric-Stress-to-Yield-Surface","page":"Elastic Plastic","title":"Step 2: Scale Deviatoric Stress to Yield Surface","text":"boldsymbols^t+Delta t = boldsymbols^trial cdot fracsqrtfrac23 cdot sigma_yboldsymbols^trial","category":"section"},{"location":"theory/theory_plastic/#Step-3:-Reconstruct-Total-Stress","page":"Elastic Plastic","title":"Step 3: Reconstruct Total Stress","text":"boldsymbolsigma^t+Delta t = boldsymbols^t+Delta t + p^t+Delta tmathbfI\n\nNote: The spherical stress remains unchanged during plastic return, as J2 plasticity assumes plastic incompressibility (volume preservation).","category":"section"},{"location":"theory/theory_plastic/#Equivalent-Plastic-Strain-Update","page":"Elastic Plastic","title":"Equivalent Plastic Strain Update","text":"The equivalent plastic strain is updated using an incremental approach that is independent of the specific return mapping algorithm:","category":"section"},{"location":"theory/theory_plastic/#Deviatoric-Strain-Increment","page":"Elastic Plastic","title":"Deviatoric Strain Increment","text":"The deviatoric part of the strain increment is:\n\nboldsymbole^dev = boldsymbolvarepsilon^inc - frac13texttr(boldsymbolvarepsilon^inc)mathbfI","category":"section"},{"location":"theory/theory_plastic/#Plastic-Strain-Increment-Calculation","page":"Elastic Plastic","title":"Plastic Strain Increment Calculation","text":"The plastic strain increment is computed by projecting onto the flow direction:\n\nmathbfA = boldsymbole^dev - fracboldsymbols^t+Delta t - boldsymbols^t2G\n\nmathbfB = frac12left(fracboldsymbols^t+Delta tboldsymbols^t+Delta t + fracboldsymbols^tboldsymbols^tright)\n\nDelta varepsilon_p^eq = maxleft(0 sqrtfrac23  mathbfAmathbfBright)\n\nwhere:\n\nG is the shear modulus\nThe contraction A:B represents the tensor inner product","category":"section"},{"location":"theory/theory_plastic/#Total-Equivalent-Plastic-Strain","page":"Elastic Plastic","title":"Total Equivalent Plastic Strain","text":"varepsilon_p^eqt+Delta t = varepsilon_p^eqt + Delta varepsilon_p^eq","category":"section"},{"location":"theory/theory_plastic/#Material-Parameters","page":"Elastic Plastic","title":"Material Parameters","text":"The model requires the following material parameters:\n\nShear Modulus (G): Controls elastic shear response and plastic strain increment calculation\nYield Stress (Ïƒáµ§): Critical stress at which plastic deformation begins","category":"section"},{"location":"theory/theory_plastic/#Flaw-Function","page":"Elastic Plastic","title":"Flaw Function","text":"The yield stress can be spatially reduced using a flaw function:\n\nsigma_y^reduced = f_flaw(mathbfx) cdot sigma_y\n\nThis allows modeling of material defects, damage, or heterogeneity in a simple way.\n\n","category":"section"},{"location":"lib/solver_functions/#Solver-Functions","page":"Solver","title":"Solver - Functions","text":"","category":"section"},{"location":"lib/solver_functions/#Index","page":"Solver","title":"Index","text":"Pages = [\"solver_functions.md\"]","category":"section"},{"location":"lib/solver_functions/#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"lib/solver_functions/#Verlet_Solver","page":"Solver","title":"Verlet_Solver","text":"","category":"section"},{"location":"lib/solver_functions/#Static_Solver","page":"Solver","title":"Static_Solver","text":"","category":"section"},{"location":"lib/solver_functions/#Boundary_Conditions","page":"Solver","title":"Boundary_Conditions","text":"","category":"section"},{"location":"lib/solver_functions/#Influence_Function","page":"Solver","title":"Influence_Function","text":"","category":"section"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.create_module_specifics-Tuple{Union{String, SubString}, Vector{Any}, Module, Dict{String, String}, Tuple}","page":"Solver","title":"PeriLab.Solver_Manager.create_module_specifics","text":"create_module_specifics(name::String, module_list::Dict{String,AbstractString}(),specifics::Dict{String,String}(), values::Tuple)\n\nSearches for a specific function within a list of modules and calls that function if found.\n\nThis function iterates over a list of modules specified in module_list and looks for a module-specific function specified in the specifics dictionary. If the module and function are found, it calls that function with the provided values tuple.\n\nArguments\n\nname::String: The name to match against the module names.\nmodule_list::Dict{String, AbstractString}: A dictionary of module names mapped to abstract strings.\nspecifics::Dict{String, String}: A dictionary specifying the module-specific function to call for each module.\nvalues::Tuple: A tuple of values to be passed as arguments to the module-specific function.\n\nExample\n\nmodule_list = Dict(\"Module1\" => \"Module1Name\", \"Module2\" => \"Module2Name\")\nspecifics = Dict(\"Module1Name\" => \"module1_function\", \"Module2Name\" => \"module2_function\")\nvalues = (arg1, arg2)\ncreate_module_specifics(\"Module1Name\", module_list, specifics, values)\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.create_module_specifics-Tuple{Union{String, SubString}, Vector{Any}, Module, Dict{String, String}}","page":"Solver","title":"PeriLab.Solver_Manager.create_module_specifics","text":"create_module_specifics(name::String, module_list::Dict{String,AbstractString}(),specifics::Dict{String,String}())\n# Returns: the function itself\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.find_jl_files-Tuple{AbstractString}","page":"Solver","title":"PeriLab.Solver_Manager.find_jl_files","text":"find_jl_files(directory::AbstractString)\n\nRecursively find Julia files (.jl) in a directory.\n\nThis function recursively searches for Julia source files with the \".jl\" extension in the specified directory and its subdirectories. It returns a vector of file paths for all the found .jl files.\n\nArguments\n\ndirectory::AbstractString: The directory in which to search for .jl files.\n\nReturns\n\nA vector of strings, where each string is a file path to a .jl file found in the specified directory and its subdirectories.\n\nExample\n\njl_files = find_jl_files(\"/path/to/modules\")\nfor jl_file in jl_files\n\tprintln(\"Found Julia file: \", jl_file)\nend\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.find_module_files-Tuple{AbstractString, String}","page":"Solver","title":"PeriLab.Solver_Manager.find_module_files","text":"find_module_files(directory::AbstractString, specific::String)\n\nSearch for Julia modules containing a specific function in a given directory.\n\nThis function searches for Julia modules (files with .jl extension) in the specified directory and checks if they contain a specific function. It returns a list of dictionaries where each dictionary contains the file path and the name of the module where the specific function is found.\n\nArguments\n\ndirectory::AbstractString: The directory to search for Julia modules.\nspecific::String: The name of the specific function to search for.\n\nReturns\n\nAn array of dictionaries, where each dictionary has the following keys:\n\n\"File\": The file path to the module where the specific function is found.\n\"Module Name\": The name of the module where the specific function is found.\n\nExample\n\nresult = find_module_files(\"/path/to/modules\", \"my_function\")\nfor module_info in result\n\tprintln(\"Function found in module: \", module_info[\"Module Name\"])\n\tprintln(\"Module file path: \", module_info[\"File\"])\nend\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.init","page":"Solver","title":"PeriLab.Solver_Manager.init","text":"init(params::Dict)\n\nInitialize the solver\n\nArguments\n\nparams::Dict: The parameters\n\nReturns\n\nblock_nodes::Dict{Int64,Vector{Int64}}: A dictionary mapping block IDs to collections of nodes.\nbcs::Dict{Any,Any}: A dictionary containing boundary conditions.\nsolver_options::Dict{String,Any}: A dictionary containing solver options.\n\n\n\n\n\n","category":"function"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.remove_models-Tuple{Vector{String}}","page":"Solver","title":"PeriLab.Solver_Manager.remove_models","text":"remove_models(solver_options::Vector{String})\n\nSets the active models to false if they are deactivated in the solver. They can be active, because they are defined as model and in the blocks.\n\nArguments\n\nsolver_options::Vector{String}: A dictionary of fields\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.set_angles-Tuple{Dict, Dict}","page":"Solver","title":"PeriLab.Solver_Manager.set_angles","text":"set_angles(params::Dict, block_nodes::Dict)\n\nSets the density of the nodes in the dictionary.\n\nArguments\n\nparams::Dict: The parameters\nblock_nodes::Dict: A dictionary mapping block IDs to collections of nodes\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.set_density-Tuple{Dict, Dict, Vector{Float64}}","page":"Solver","title":"PeriLab.Solver_Manager.set_density","text":"set_density(params::Dict, block_nodes::Dict, density::NodeScalarField{Float64})\n\nSets the density of the nodes in the dictionary.\n\nArguments\n\nparams::Dict: The parameters\nblock_nodes::Dict: A dictionary mapping block IDs to collections of nodes\ndensity::NodeScalarField{Float64}: The density\n\nReturns\n\ndensity::NodeScalarField{Float64}: The density\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.set_fem_block-Tuple{Dict, Dict, Vector{Bool}}","page":"Solver","title":"PeriLab.Solver_Manager.set_fem_block","text":"set_fem_block(params::Dict, block_nodes::Dict, fem_block::Vector{Bool})\n\nSets the fem_block of the nodes in the dictionary.\n\nArguments\n\nparams::Dict: The parameters\nblock_nodes::Dict: A dictionary mapping block IDs to collections of nodes\nfem_block::Vector{Bool}: The fem_block\n\nReturns\n\nfem_block::Vector{Bool}: The fem_block\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.set_horizon-Tuple{Dict, Dict, Vector{Float64}}","page":"Solver","title":"PeriLab.Solver_Manager.set_horizon","text":"set_horizon(params::Dict, block_nodes::Dict, horizon::NodeScalarField{Float64})\n\nSets the horizon of the nodes in the dictionary.\n\nArguments\n\nparams::Dict: The parameters\nblock_nodes::Dict: A dictionary mapping block IDs to collections of nodes\nhorizon::NodeScalarField{Float64}: The horizon\n\nReturns\n\nhorizon::NodeScalarField{Float64}: The horizon\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.solver-Tuple{Dict{Any, Any}, Dict{Int64, Vector{Int64}}, Dict{Any, Any}, Dict{Int64, Dict}, Vector{Dict}, Any, Bool}","page":"Solver","title":"PeriLab.Solver_Manager.solver","text":"solver(solver_options::Dict{String,Any}, block_nodes::Dict{Int64,Vector{Int64}}, bcs::Dict{Any,Any}, outputs::Dict{Int64,Dict{}}, result_files::Vector{Any}, write_results, silent::Bool)\n\nRuns the solver.\n\nArguments\n\nsolver_options::Dict{String,Any}: The solver options\nblock_nodes::Dict{Int64,Vector{Int64}}: A dictionary mapping block IDs to collections of nodes\nbcs::Dict{Any,Any}: The boundary conditions\noutputs::Dict{Int64,Dict{}}: A dictionary for output settings\nresult_files::Vector{Any}: A vector of result files\nwrite_results: A function to write simulation results\nsilent::Bool: A boolean flag to suppress progress bars\n\nReturns\n\nresult_files: A vector of updated result files\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.synchronise_field-Tuple{Any, Dict, Any, Any, String, String}","page":"Solver","title":"PeriLab.Solver_Manager.synchronise_field","text":"synchronise_field(comm, synch_fields::Dict, overlap_map, get_field, synch_field::String, direction::String)\n\nSynchronises field.\n\nArguments\n\ncomm: The MPI communicator\nsynch_fields::Dict: A dictionary of fields\noverlap_map: The overlap map\nget_field: The function to get the field\nsynch_field::String: The field\ndirection::String: The direction\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Verlet_Solver.calculate_strain-Tuple{AbstractVector{Int64}, Union{Matrix{Float64}, StaticArraysCore.SMatrix, StaticArraysCore.MMatrix}}","page":"Solver","title":"PeriLab.Solver_Manager.Verlet_Solver.calculate_strain","text":"calculate_strain(nodes::AbstractVector{Int64}, hooke_matrix::Matrix{Float64})\n\nCalculate the von Mises stress.\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes.\nhooke_matrix::Matrix{Float64}: The hooke matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Verlet_Solver.calculate_stresses-Tuple{Dict{Int64, Vector{Int64}}, Dict{String, Any}}","page":"Solver","title":"PeriLab.Solver_Manager.Verlet_Solver.calculate_stresses","text":"calculate_stresses(block_nodes::Dict{Int64,Vector{Int64}}, options::Dict{String, Any})\n\nComputes the stresses.\n\nArguments\n\nblock_nodes::Dict{Int64,Vector{Int64}}: List of block nodes.\noptions::Dict{String, Any}: List of options.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Verlet_Solver.calculate_von_mises_stress-Tuple{AbstractVector{Int64}}","page":"Solver","title":"PeriLab.Solver_Manager.Verlet_Solver.calculate_von_mises_stress","text":"calculate_von_mises_stress(nodes::AbstractVector{Int64})\n\nCalculate the von Mises stress.\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Verlet_Solver.get_forces_from_force_density-Tuple{}","page":"Solver","title":"PeriLab.Solver_Manager.Verlet_Solver.get_forces_from_force_density","text":"get_forces_from_force_density()\n\nComputes the forces from the force densities.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Verlet_Solver.get_integration_steps-Tuple{Float64, Float64, Float64}","page":"Solver","title":"PeriLab.Solver_Manager.Verlet_Solver.get_integration_steps","text":"get_integration_steps(initial_time::Float64, end_time::Float64, dt::Float64)\n\nCalculate the number of integration steps and the adjusted time step for a numerical integration process.\n\nArguments\n\ninitial_time::Float64: The initial time for the integration.\nend_time::Float64: The final time for the integration.\ndt::Float64: The time step size.\n\nReturns\n\nA tuple (nsteps, dt) where:\n\nnsteps::Int64: The number of integration steps required to cover the specified time range.\ndt::Float64: The adjusted time step size to evenly divide the time range.\n\nErrors\n\nThrows an error if the dt is less than or equal to zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Verlet_Solver.get_partial_stresses-Tuple{AbstractVector{Int64}}","page":"Solver","title":"PeriLab.Solver_Manager.Verlet_Solver.get_partial_stresses","text":"get_partial_stresses(nodes::Vector{Int64})\n\nComputes the partial stresses.\n\nArguments\n\nnodes::Vector{Int64}: List of block nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Verlet_Solver.init_solver-Tuple{Dict{Any, Any}, Dict, Dict{Any, Any}, Dict{Int64, Vector{Int64}}}","page":"Solver","title":"PeriLab.Solver_Manager.Verlet_Solver.init_solver","text":"init_solver(params::Dict, bcs::Dict{Any,Any}, block_nodes::Dict{Int64,Vector{Int64}}, mechanical::Bool, thermo::Bool)\n\nInitialize the Verlet solver for a simulation.\n\nThis function sets up the Verlet solver for a simulation by initializing various parameters and calculating the time step based on provided parameters or critical time step calculations.\n\nArguments\n\nparams::Dict: A dictionary containing simulation parameters.\nbcs::Dict{Any,Any}: Boundary conditions\nblock_nodes::Dict{Int64,Vector{Int64}}: A dictionary mapping block IDs to collections of nodes.\nmechanical::Bool: If true, mechanical properties are considered in the calculation.\nthermo::Bool: If true, thermodynamic properties are considered in the calculation.\n\nReturns\n\nA tuple (initial_time, dt, nsteps, numerical_damping) where:\n\ninitial_time::Float64: The initial time for the simulation.\ndt::Float64: The time step for the simulation.\nnsteps::Int64: The number of time integration steps.\nnumerical_damping::Float64: The numerical damping factor.\nmax_damage::Float64: The maximum damage in the simulation.\n\nDependencies\n\nThis function may depend on the following functions:\n\nget_initial_time, get_final_time, get_safety_factor, get_fixed_dt: Used to retrieve simulation parameters.\ncompute_crititical_time_step: Used to calculate the critical time step if dt is not fixed.\nget_integration_steps: Used to determine the number of integration steps and adjust the time step.\nfind_and_set_core_value_min and find_and_set_core_value_max: Used to set core values in a distributed computing environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Verlet_Solver.run_solver-Tuple{Dict{Any, Any}, Dict{Int64, Vector{Int64}}, Dict{Any, Any}, Dict{Int64, Dict}, Vector{Dict}, Function, Function, Function, Function, Bool}","page":"Solver","title":"PeriLab.Solver_Manager.Verlet_Solver.run_solver","text":"run_solver(\n\tsolver_options::Dict{Any,Any},\n\tblock_nodes::Dict{Int64,Vector{Int64}},\n\tbcs::Dict{Any,Any},\n\toutputs::Dict{Int64,Dict{}},\n\tresult_files::Vector{Any},\n\tsynchronise_field,\n\twrite_results,\n\tsilent::Bool\n)\n\nRun the Verlet solver for a simulation based on the strategy provided in [1] and  [3].\n\nThis function performs the Verlet solver simulation, updating various data fields and properties over a specified number of time steps.\n\nArguments\n\nsolver_options::Dict{String,Any}: A dictionary containing solver options and parameters.\nblock_nodes::Dict{Int64,Vector{Int64}}: A dictionary mapping block IDs to collections of nodes.\nbcs::Dict{Any,Any}: A dictionary containing boundary conditions.\noutputs::Dict{Int64,Dict{}}: A dictionary for output settings.\nresult_files::Vector{Any}: A vector of result files.\nsynchronise_field: A function for synchronization.\nwrite_results: A function to write simulation results.\nsilent::Bool: A boolean flag to suppress progress bars.\n\nReturns\n\nresult_files: A vector of updated result files.\n\nDependencies\n\nThis function depends on various data fields and properties from the Data_Manager module, as well as several helper functions. It also relies on solver options and boundary conditions provided in the input parameters.\n\nFunction Workflow\n\nInitialize simulation parameters and data fields.\nPerform Verlet integration over a specified number of time steps.\nUpdate data fields and properties based on the solver options.\nWrite simulation results using the write_results function.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Static_Solver.init_solver-Tuple{Dict{Any, Any}, Dict, Dict{Any, Any}, Dict{Int64, Vector{Int64}}}","page":"Solver","title":"PeriLab.Solver_Manager.Static_Solver.init_solver","text":"init_solver(params::Dict, bcs::Dict{Any,Any}, block_nodes::Dict{Int64,Vector{Int64}}, mechanical::Bool, thermo::Bool)\n\nInitialize the Static solver for a simulation.\n\nThis function sets up the Static solver for a simulation by initializing various parameters.\n\nArguments\n\nparams::Dict: A dictionary containing simulation parameters.\nbcs::Dict{Any,Any}: Boundary conditions\nblock_nodes::Dict{Int64,Vector{Int64}}: A dictionary mapping block IDs to collections of nodes.\nmechanical::Bool: If true, mechanical properties are considered in the calculation.\nthermo::Bool: If true, thermodynamic properties are considered in the calculation.\n\nReturns\n\nA tuple (initial_time, dt, nsteps, numerical_damping) where:\n\ninitial_time::Float64: The initial time for the simulation.\ndt::Float64: The time step for the simulation.\nnsteps::Int64: The number of time integration steps.\nnumerical_damping::Float64: The numerical damping factor.\nmax_damage::Float64: The maximum damage in the simulation.\nxtol::Float64: solution tolerance; mininum step size value between two iterations\nftol::Float64: residual tolerance; mininum residual value of the function\niterations::Int64: maximum number of iterations per time step\nshow_trace::Bool: show the iteration steps of the solver\n\nDependencies\n\nThis function may depend on the following functions:\n\nget_initial_time, get_final_time, get_safety_factor, get_fixed_dt: Used to retrieve simulation parameters.\nget_integration_steps: Used to determine the number of integration steps and adjust the time step.\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Boundary_Conditions.apply_bc_dirichlet-Tuple{Vector{String}, Dict, Float64, Float64}","page":"Solver","title":"PeriLab.Solver_Manager.Boundary_Conditions.apply_bc_dirichlet","text":"apply_bc_dirichlet(bcs::Dict, time::Float64)\n\nApply the boundary conditions\n\nArguments\n\nbcs::Dict{Any,Any}: The boundary conditions\ntime::Float64: The current time\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Boundary_Conditions.apply_bc_neumann-Tuple{Dict, Float64, Float64}","page":"Solver","title":"PeriLab.Solver_Manager.Boundary_Conditions.apply_bc_neumann","text":"apply_bc_neumann(bcs::Dict, time::Float64)\n\nApply the boundary conditions\n\nArguments\n\nbcs::Dict{Any,Any}: The boundary conditions\ntime::Float64: The current time\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Boundary_Conditions.boundary_condition-Tuple{Dict}","page":"Solver","title":"PeriLab.Solver_Manager.Boundary_Conditions.boundary_condition","text":"boundary_condition(params::Dict)\n\nInitialize the boundary condition\n\nArguments\n\nparams::Dict: The parameters\n\nReturns\n\nbcs_out::Dict{Any,Any}: The boundary conditions\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Boundary_Conditions.check_valid_bcs-Tuple{Dict{String, Any}}","page":"Solver","title":"PeriLab.Solver_Manager.Boundary_Conditions.check_valid_bcs","text":"check_valid_bcs(bcs::Dict{String,Any})\n\nCheck if the boundary conditions are valid\n\nArguments\n\nbcs::Dict{String,Any}: The boundary conditions\n\nReturns\n\nworking_bcs::Dict{String,Any}: The valid boundary conditions\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Boundary_Conditions.clean_up-Tuple{String}","page":"Solver","title":"PeriLab.Solver_Manager.Boundary_Conditions.clean_up","text":"clean_up(bc::String)\n\nClean up the boundary condition\n\nArguments\n\nbc::String: The boundary condition\n\nReturns\n\nbc::String: The cleaned up boundary condition\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Boundary_Conditions.eval_bc!","page":"Solver","title":"PeriLab.Solver_Manager.Boundary_Conditions.eval_bc!","text":"eval_bc!(field_values::Union{NodeScalarField{Float64},NodeScalarField{Int64}}, bc::Union{Float64,Float64,Int64,String}, coordinates::Matrix{Float64}, time::Float64, dof::Int64)\n\nWorking with if-statements \"if t>2 0 else 20 end\" works for scalars. If you want to evaluate a vector, please use the Julia notation as input \"ifelse.(x .> y, 10, 20)\"\n\n\n\n\n\n","category":"function"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Boundary_Conditions.eval_bc!-2","page":"Solver","title":"PeriLab.Solver_Manager.Boundary_Conditions.eval_bc!","text":"eval_bc!(field_values::Union{NodeScalarField{Float64},NodeScalarField{Int64}}, bc::Function, coordinates::Matrix{Float64}, time::Float64, dof::Int64)\n\nuses the already created bc function\"\n\n\n\n\n\n","category":"function"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Boundary_Conditions.find_bc_free_dof-Tuple{Dict{Any, Any}}","page":"Solver","title":"PeriLab.Solver_Manager.Boundary_Conditions.find_bc_free_dof","text":"find_bc_free_dof(bcs::Dict{String,Any})\n\nFinds all dof without a displacement boundary condition. This tuple vector is stored in the Data_Manager.\n\nArguments\n\nbcs::Dict{String,Any}: The boundary conditions\n\nReturns\n\n\n\n\n\n","category":"method"},{"location":"lib/solver_functions/#PeriLab.Solver_Manager.Boundary_Conditions.init_BCs-Tuple{Dict}","page":"Solver","title":"PeriLab.Solver_Manager.Boundary_Conditions.init_BCs","text":"init_BCs(params::Dict)\n\nInitialize the boundary conditions\n\nArguments\n\nparams::Dict: The parameters\n\nReturns\n\nbcs::Dict{Any,Any}: The boundary conditions\n\n\n\n\n\n","category":"method"},{"location":"theory/theory_ordinary/#Ordinary-state-based-Peridynamics","page":"Ordinary state-based","title":"Ordinary state-based Peridynamics","text":"info: Info\nMore details can be found here [4]\n\nFor an isotropic Peridynamic solid and small deformations we can define underlinex=underlinemathbfX and  underliney=underlinemathbfY and underlinee=underliney-underlinex\n\nIn general underlinemathbfY-underlinemathbfXnequnderlinee. The force density scalar state can be defined as underlinet=underlinemathbfT\n\nThe weighted volume is\n\nm_V = int_mathcalH underlineomegalangle boldsymbolxirangle underlinex underlinex dV\n\nThe dilatation is given as\n\ntheta = frac3m_V = int_mathcalHunderlineomegalangle boldsymbolxirangle underlinex underlineelangle boldsymbolxirangle dV\n\nunderlinet = fracomegalangle boldsymbolxirangle m_Vleft3K theta underlinex + 15G underlinee^d  right\n\nwith the decomposition in the devatoring and isotropic part of the strain\n\nunderlinee^dlangle boldsymbolxirangle = epsilon_ij^dxi_ifracx_jboldsymbolxi\n\nand\n\nunderlinee^ilangle boldsymbolxirangle = epsilon_ij^ixi_ifracx_jboldsymbolxi\n\nThe force density can be determined as\n\nunderlinemathbfT=underlinetfracunderlinemathbfYunderlinemathbfY\n\nFor plane stress and plane strain the equations are taken form [1].\n\n","category":"section"},{"location":"lib/helper_functions/#Helper-Functions","page":"Helpers","title":"Helper - Functions","text":"","category":"section"},{"location":"lib/helper_functions/#Index","page":"Helpers","title":"Index","text":"Pages = [\"helper_functions.md\"]","category":"section"},{"location":"lib/helper_functions/#Helpers","page":"Helpers","title":"Helpers","text":"","category":"section"},{"location":"lib/helper_functions/#PeriLab.Helpers.check_inf_or_nan-Union{Tuple{T}, Tuple{AbstractArray{T}, String}} where T<:Union{Float64, Int64}","page":"Helpers","title":"PeriLab.Helpers.check_inf_or_nan","text":"check_inf_or_nan(array, msg)\n\nChecks if the sum of an array is finite and has only numbers. If not, an error is raised.\n\nArguments\n\narray: The array to check.\nmsg: The error message to raise.\n\nReturns\n\nBool: true if the scalar is finite and has only numbers, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.check_inf_or_nan-Union{Tuple{T}, Tuple{T, String}} where T<:Union{Float64, Int64}","page":"Helpers","title":"PeriLab.Helpers.check_inf_or_nan","text":"check_inf_or_nan(scalar, msg)\n\nChecks if a scalar is finite and a number. If not, an error is raised.\n\nArguments\n\nscalar: The scalar to check.\nmsg: The error message to raise.\n\nReturns\n\nBool: true if the scalar is finite, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.compute_free_surface_nodes-Tuple{Union{Matrix{Float64}, Matrix{Int64}}, Vector{Int64}, Vector{Int64}}","page":"Helpers","title":"PeriLab.Helpers.compute_free_surface_nodes","text":"compute_surface_nodes_and_connections(points::Union{Matrix{Float64},Matrix{Int64}},\n\t\t\t\t\t\t\t\t\t\t   poly, free_surfaces::Vector{Int64})\n\nComputes the points which are connected free surfaces (()). This function is used for contact search purposes. The free surface nodes are used to compute the nearest neighbors. The connections and underlying points are needed for the contact algorithm. They are a subset of the surface points to create the polyhedron and the only ones which can be in contact.\n\nArguments\n\npoints::Union{Matrix{Float64},Matrix{Int64}}: Points which form the polyhedron.\npoly: Polyhedron object.\nfree_surfaces::Vector{Int64}: List of the free surfaces of the polyhedron.\n\nReturns\n\nconnections: Tthe connections to the free surfaces. There can be more surface points than connections.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.create_centroid_and_search_radius-Tuple{Union{Matrix{Float64}, Matrix{Int64}}, Matrix{Int64}, Int64, Any}","page":"Helpers","title":"PeriLab.Helpers.create_centroid_and_search_radius","text":"create_centroid_and_search_radius(coor::Union{Matrix{Float64},Matrix{Int64}},\n\t\t\t\t\t\t\t\t  el_topology::Matrix{Int64},\n\t\t\t\t\t\t\t\t  dof::Int64,\n\t\t\t\t\t\t\t\t  fu)\n\nComputes the centroid and Contact Radius for each element in a given mesh.\n\nArguments\n\ncoor::Union{Matrix{Float64}, Matrix{Int64}}:   A matrix of size (N x dof), where each row represents the coordinates of a point in the space.\nel_topology::Matrix{Int64}:   A matrix of size (M x num_nodes), where each row contains the indices of points that define an element.\ndof::Int64:   The number of spatial dimensions (degrees of freedom), e.g., 2 for 2D and 3 for 3D.\nfu:   A function of four point 2D surface or eight point 3D volume.\n\nReturns\n\nel_centroid::Matrix{Float64}: A matrix of size (M Ã— dof), where each row represents the centroid of an element.\nsearch_radius::Vector{Float64}: A vector of size M, where each entry is the maximum distance from the element centroid to any of its nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.find_files_with_ending-Tuple{AbstractString, AbstractString}","page":"Helpers","title":"PeriLab.Helpers.find_files_with_ending","text":"find_files_with_ending(folder_path::AbstractString, file_ending::AbstractString)\n\nReturns a list of files in folder_path that end with file_ending.\n\nArguments\n\nfolder_path::AbstractString: The path to the folder.\nfile_ending::AbstractString: The ending of the files.\n\nReturns\n\nfile_list::Vector{String}: The list of files that end with file_ending.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.find_indices-Union{Tuple{T}, Tuple{Vector{T}, T}} where T<:Union{Bool, Float64, Int64}","page":"Helpers","title":"PeriLab.Helpers.find_indices","text":"find_indices(vector, what)\n\nReturns the indices of vector that are equal to what.\n\nArguments\n\nvector::Vector: The vector to search in.\nwhat: The value to search for.\n\nReturns\n\nindices::Vector: The indices of vector that are equal to what.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.find_inverse_bond_id-Tuple{Vector{Vector{Int64}}}","page":"Helpers","title":"PeriLab.Helpers.find_inverse_bond_id","text":"find_inverse_bond_id(nlist::BondScalarState{Int64})\n\nFinds the inverse of the bond id in the nlist.\n\nArguments\n\nnlist::BondScalarState{Int64}: The nlist to find the inverse of.\n\nReturns\n\ninverse_nlist::Vector{Dict{Int64,Int64}}: The inverse nlist.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.get_active_update_nodes-NTuple{4, Any}","page":"Helpers","title":"PeriLab.Helpers.get_active_update_nodes","text":"get_active_update_nodes(active::Vector{Bool}, update_list::Vector{Bool}, nodes::Vector{Int64}, index::Vector{Int64})\n\nReturns the active nodes and the update nodes.\n\nArguments\n\nactive::Vector{Bool}: The active vector.\nupdate_list::Vector{Bool}: The update vector.\nnodes::Vector{Int64}: The vector of nodes.\nindex::Vector{Int64}: Pre allocated Vector.\n\nReturns\n\nupdate_nodes::Vector{Int64}: The nodes of update that are true.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.get_block_nodes-Tuple{Any, Any}","page":"Helpers","title":"PeriLab.Helpers.get_block_nodes","text":"get_block_nodes(block_ids, nnodes)\n\nReturns a dictionary mapping block IDs to collections of nodes.\n\nArguments\n\nblock_ids::Vector{Int64}: A vector of block IDs\nnnodes::Int64: The number of nodes\n\nReturns\n\nblock_nodes::Dict{Int64,Vector{Int64}}: A dictionary mapping block IDs to collections of nodes\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.get_hexagon-Tuple{Union{Matrix{Float64}, Matrix{Int64}}, Vector{Int64}}","page":"Helpers","title":"PeriLab.Helpers.get_hexagon","text":"get_hexagon(coor::Union{Matrix{Float64},Matrix{Int64}}, topo::Vector{Int64})\n\nDescription\n\nThis function gives the hexahedron model back to compute centroids of this surface and check if a point lies inside. The el_topology has to be transformed from PeriLab notation, to avoid overlapping.\n\nArguments\n\ncoor::Union{Matrix{Float64},Matrix{Int64}}: Coordinates.\ntopo::Vector{Int64}: el_topology of an element.\n\nReturns\n\nHexahedron: eight point hexahedron.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.get_ring-Tuple{Union{Matrix{Float64}, Matrix{Int64}}, Vector{Int64}}","page":"Helpers","title":"PeriLab.Helpers.get_ring","text":"get_ring(coor::Union{Matrix{Float64},Matrix{Int64}}, topo::Vector{Int64})\n\nDescription\n\nThis function gives the ring model back to compute centroids of this surface and check if a point lies inside. The el_topology has to be transformed from PeriLab notation, to avoid overlapping.\n\nArguments\n\ncoor::Union{Matrix{Float64},Matrix{Int64}}: Coordinates.\ntopo::Vector{Int64}: el_topology of an element.\n\nReturns\n\nRing: four point closed surface.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.invert","page":"Helpers","title":"PeriLab.Helpers.invert","text":"invert(A::Union{Matrix{Float64},Matrix{Int64}}, error_message::String=\"Matrix is singular\")\n\nInvert a n x n matrix. Throws an error if A is singular.\n\nArguments\n\nA::Union{Matrix{Float64},Matrix{Int64}}: A n x n matrix.\nerror_message::String=\"Matrix is singular\": The error message returned if A is singular.\n\nReturns\n\ninverted matrix or nothing if not inverable.\n\n\n\n\n\n","category":"function"},{"location":"lib/helper_functions/#PeriLab.Helpers.matrix_style-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Union{Float64, Int64}","page":"Helpers","title":"PeriLab.Helpers.matrix_style","text":"matrix_style(A)\n\nInclude a scalar or an array and reshape it to style needed for LinearAlgebra package\n\nArguments\n\nA: The array or scalar to reshape\n\nReturns\n\nArray: The reshaped array\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.matrix_to_vector-Tuple{AbstractMatrix{Float64}}","page":"Helpers","title":"PeriLab.Helpers.matrix_to_vector","text":"matrix_to_vector(matrix::AbstractMatrix{Float64})\n\nConvert a 3x3 matrix to a 6x1 vector\n\nArguments\n\nmatrix::Matrix{Float64}: The matrix.\n\nReturns\n\nvector::SVector{Float64}: The Vorigt vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.matrix_to_vector-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Union{Float64, Int64}","page":"Helpers","title":"PeriLab.Helpers.matrix_to_vector","text":" matrix_to_vector(mat::Matrix{T}) where {T<:Union{Float64,Int64}}\n\nTransforming a matrix representation in a Vector{Vector} representation.\n\nArguments\n\nmat::Union{Matrix{Float64},Matrix{Int64}}: Points which form the polyhedron.\n\nReturns\n\n``: transformed data\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.progress_bar_stable_type-Tuple{Val{true}, Int64}","page":"Helpers","title":"PeriLab.Helpers.progress_bar_stable_type","text":"progress_bar(rank::Int64, nsteps::Int64, silent::Bool)\n\nCreate a progress bar if the rank is 0. The progress bar ranges from 1 to nsteps + 1.\n\nArguments\n\nrank::Int64: An integer to determine if the progress bar should be created.\nnsteps::Int64: The total number of steps in the progress bar.\nsilent::Bool: de/activates the progress bar\n\nReturns\n\nProgressBar or UnitRange: If rank is 0, a ProgressBar object is returned. Otherwise, a range from 1 to nsteps + 1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.qdim-Tuple{Int64, Int64}","page":"Helpers","title":"PeriLab.Helpers.qdim","text":"qdim(order::Int64, dof::Int64)\n\nCalculate the number of terms in a polynomial expansion up to a specified accuracy order. Simplied first complex loop in Peridigm correspondence::computeLagrangianGradientWeights. In the unit test this values where tested.\n\nArguments\n\norder::Int64: The accuracy order of the polynomial expansion.\n\nReturns\n\nInt64: The total number of terms in the polynomial expansion.\n\nDescription\n\nThis function calculates the number of terms in a polynomial expansion up to the specified accuracy order using an analytical formula derived from combinatorial considerations. The function iterates over each order from 1 to the specified order and calculates the sum of binomial coefficients according to the formula: qdim(order) = Î£(i=1 to order) [(i+2)! / (2! * i!)]\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.rotate-Tuple{AbstractVector{Int64}, AbstractArray{Float64}, AbstractArray{Float64}, Bool}","page":"Helpers","title":"PeriLab.Helpers.rotate","text":"rotate(nodes::AbstractVector{Int64}, dof::Int64, matrix::AbstractArray{Float64,3}, angles::SubArray, back::Bool)\n\nRotates the matrix.\n\nArguments\n\nnodes::AbstractVector{Int64}: List of block nodes.\nmatrix::AbstractArray{Float64,3}: Matrix.\nrot::SubArray: Rotation tensor.\nback::Bool: Back.\n\nReturns\n\nmatrix::SubArray: Matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.rotate_second_order_tensor-Tuple{Matrix{Float64}, Matrix{Float64}, Bool}","page":"Helpers","title":"PeriLab.Helpers.rotate_second_order_tensor","text":"rotate_second_order_tensor(angles::Union{Vector{Float64},Vector{Int64}}, tensor::Matrix{Float64}, dof::Int64, back::Bool)\n\nRotates the second order tensor.\n\nArguments\n\nangles::Union{Vector{Float64},Vector{Int64}}: Angles.\ntensor::Matrix{Float64}: Second order tensor.\ndof::Int64: Degree of freedom.\nback::Bool: Back.\n\nReturns\n\ntensor::Matrix{Float64}: Second order tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.vector_to_matrix-Tuple{Any}","page":"Helpers","title":"PeriLab.Helpers.vector_to_matrix","text":"vector_to_matrix(matrix)\n\nConvert a 6x1 vector to a 3x3 matrix\n\nArguments\n\nvector::Vector{Float64}: The vector.\n\nReturns\n\nmatrix::Matrix{Float64}: The matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/helper_functions/#PeriLab.Helpers.voigt_to_matrix-Tuple{Union{Vector, StaticArraysCore.SVector, StaticArraysCore.MVector}}","page":"Helpers","title":"PeriLab.Helpers.voigt_to_matrix","text":"voigt_to_matrix(voigt::Union{Vector{Float64},Vector{Int64}})\n\nConvert a Voigt notation (6x1 or 3x1 vector) to a 2x2 or 3x3 matrix\n\nArguments\n\nvoigt::Vector{Float64}: The Voigt notation.\n\nReturns\n\nmatrix::Matrix{Float64}: The matrix.\n\n\n\n\n\n","category":"method"},{"location":"theory/theory_thermal/#Thermal-models","page":"Thermal Models","title":"Thermal models","text":"The theory is taken from [9]","category":"section"},{"location":"theory/theory_thermal/#Thermo-mechanics","page":"Thermal Models","title":"Thermo-mechanics","text":"To introduce a thermo-mechanical coupling the mechanical strains in have to be expanded with the thermal strains:\n\nboldsymbolvarepsilon=boldsymbolvarepsilon_mechanical + boldsymbolvarepsilon_thermal\n\nThe thermal strains are defined as boldsymbolvarepsilon_thermal =- boldsymbolalphatau with tau as the temperature increment and boldsymbolalpha as matrix of the coefficients of thermal expansion. Typically, this matrix is diagonal. The coupled stresses for linear elastic material utilizing Hook's law is given as boldsymbolsigma=mathbfCcdotcdotleft(boldsymbolvarepsilon_mechanical - boldsymbolalphatau right)","category":"section"},{"location":"theory/theory_thermal/#Thermal-flux","page":"Thermal Models","title":"Thermal flux","text":"The mechanical response due to temperature changes is included in the Peridynamics model. However, the heat flux must be included as well.  Under the assumption that mechanical deformations do not change the temperature, the thermodynamic equilibrium equation can be studied separately.\n\nrho C_vdottau = int_mathcalH(underlineh(textbfxt)langleboldsymbolxirangle-underlineh(textbfxt)langleboldsymbolxirangle)dV_textbfx+ S_i\n\nThe parameters are rho the mass density, C_v the specific heat capacity, dottau the temperature gradient in time, dV_textbfx the volume and S_i the heat sink or heat source. The heat flux of a bond is defined as\n\nunderlineh(textbfxt)langleboldsymbolxirangle = mathbfq^TmathbfK^-1(textbfx)boldsymbolxi\n\nwith mathbfq as classical heat flux and mathbfK as the shape tensor. It follows\n\nnablacdotmathbfq = int_mathcalHleftmathbfq(textbfx)^TmathbfK^-1(textbfx)+mathbfq(textbfx)^TmathbfK^-1(textbfx)rightboldsymbolxidV_textbfx\n\nwhich can be derived utilizing the spatial gradient of the temperature nablatau as\n\nmathbfq = -boldsymbollambdanablatau\n\nboldsymbollambda\n\nis the 3times3 matrix of thermal conductivity. Typically it is a diagonal matrix. Following \\cite{BrighentiR2021} the spatial temperature gradient nablatau can be derived as\n\nnablatau = mathbfK^-1int_mathcalHlefttau(mathbfx)-tau(mathbfx)rightboldsymbolxiunderlineomegalangleboldsymbolxirangle dV_mathbfx\n\nThe numerical solving process is then\n\nrho C_v fractau^t+dt-tau^tdt=nablamathbfq + S_i\n\ntau^t+dt = dtfracnablamathbfq + S_irho C_v + tau^t","category":"section"},{"location":"theory/theory_thermal/#Heat-transfer-to-environment","page":"Thermal Models","title":"Heat transfer to environment","text":"Following \\cite{GuX2019c,OterkusS2014b} the heat volumetric density at the surface for a assigned heat flux normal to the surface q_bc is: S_i = fracq_bcDelta\n\nwhere Delta can be set to dx. Thereby, q_bc is\n\nq_bc = kappa (tau-tau_env)\n\nwhere kappa is the heat convection coefficient between solid and environment and tau_env the environmental temperature. For a mesh free model the question arises how the outer surface and the corresponded surface can be identified. For the outer surface the Peridynamics neighborhood mathcalH is utilized. It is assumed that is circle for 2D and a sphere for 3D. Therefore, the following criteria has to be fulfilled for 2D\n\nV_2D=2pidelta^2 h geq int_mathcalHdV\n\nand 3D V_3D=frac43pidelta^3 geq int_mathcalHdV\n\nEach point which is next to the surface will have less volume represented be the discrete material points. Defining a limit value f_limit leq V_specific =  fracint_mathcalHdVV_2Dor3D allows an easy identification of surface nodes i during the printing process. Combining the heat flow and the convection model allows the computation of the change in temperature for these nodes i as tau_i^t+dt = dtfracnablamathbfq_i + frackappa (tau_i^t-tau_env)dx(rho C_v)_i + tau^t_i","category":"section"},{"location":"theory/theory_thermal/#Time-step","page":"Thermal Models","title":"Time step","text":"The minimum time step for the explicit time integration of the temperature field to obtain a stable solution is given by Delta t  textminleft(fracleft(rho C_vright)_isum_j=1^Nfractextmax(texteig(boldsymbollambda))mathbfxi_ijV_jright) with N the number of neighbors of point i [24].\n\n","category":"section"},{"location":"man/dev/module_integration/#Module-integration","page":"Module integration","title":"Module integration","text":"If you want to integrate your own model check if it suits in one of the predefined classes material, damage, additive, thermal or degradation. If so check the template folder.\n\ninfo: Material Template\nMaterials have multiple templates, because the correspondence formulation allows additional options.\n\nEach template has a init function, a name function, a compute function.\n\nCopy the template and put it in the folder. Change all the functions and give the module a name.\n\ninfo: Automatic Integration\nIn PeriLab makros are used to automatically integrate your model.","category":"section"},{"location":"man/dev/module_integration/#Parameter","page":"Module integration","title":"Parameter","text":"In PeriLab a field called params exists. This field provides all the material information. The structure is given here","category":"section"},{"location":"man/dev/module_integration/#Init-function","page":"Module integration","title":"Init function","text":"The init function is used to read and check the  properties provided by the yaml. It should be done there, because if the compute function is used, this check is done in every time step. Also specific fields can be defined here as well.","category":"section"},{"location":"man/dev/module_integration/#Name-function","page":"Module integration","title":"Name function","text":"This function defines the name of the module. This name is used to call this model from the yaml.\n\ninfo: Correspondence\nIf you want to integrate a correspondence model, make sure ''Correspodence'' occur in the material name","category":"section"},{"location":"man/dev/module_integration/#Compute-function","page":"Module integration","title":"Compute function","text":"This function is called from the solver. You can call whatever function you like from here. However, this function should evaluate the result needed for the solving process, e.g. heat flux or force densities.","category":"section"},{"location":"man/dev/module_integration/#Module-name","page":"Module integration","title":"Module name","text":"You can setup the module name as you like as long as it does not exist a second time in PeriLab.\n\ninfo: Coding Style\nPlease name the module file and the module equaly.","category":"section"},{"location":"man/dev/module_integration/#Creating-your-own-model-category","page":"Module integration","title":"Creating your own model category","text":"warn: Creating your own model category\nThis is advanced programming. Feel free to contact the developers for help.\n\nTo integrate a model category somewhere you have to do the following things. You need a main function of your modeling category. The existing ones are the factory files. These modules have a init function and a compute function. The init function find the modules of the category and the compute function calls these modules during the solving process.\n\nHere, the call for the init function is shown for the material factory.\n\nmod = create_module_specifics(material_model, module_list, \"material_name\")\nData_Manager.set_model_module(material_model, mod)\n\nThe module_list is optained, by applying\n\nusing ...Solver_Manager: find_module_files, create_module_specifics\nglobal module_list = find_module_files(@__DIR__, \"material_name\")\nfor mod in module_list\n    include(mod[\"File\"])\nend\n\nYou can integrate these functions than in the compute function of the factory module.\n\nmod = Data_Manager.get_model_module(material_model)\nmod.compute_model(nodes, model_param, time, dt, to)\n\n","category":"section"},{"location":"man/output/#Output","page":"Output","title":"Output","text":"","category":"section"},{"location":"man/output/#Output-File-Type","page":"Output","title":"Output File Type","text":"Currently Exodus and CSV are supported as output types.\n\nwarning: CSV File\nOnly variables that are defined as global variables are supported, see Compute Class Parameters for more information.\n\ntip: Flush File\nBy default the output files will be flushed after each write-step, meaning you can look at the results while the simulation is still running.","category":"section"},{"location":"man/output/#Output-Frequency-/-Number-of-Output-Steps","page":"Output","title":"Output Frequency / Number of Output Steps","text":"As the number of solver steps can be quite large and you don't want to buy new drives for every simulation we want to specify the number of output steps written.\n\nYou can either specify the total number of output steps via Number of Output Steps or the frequency of output via Output Frequency.\n\ntip: First time users\nFor first time users we will recommend to use Number of Output Steps in the range of 100 to 1000. Depending on your discretization this is enough to get a good idea of the simulation results.\n\ntip: Only damage\nIf you want to take a closer look at damage initiation and propagation and are worried about the result file size, you can write another output file with Write After Damage set to true.","category":"section"},{"location":"man/output/#Output-Variables","page":"Output","title":"Output Variables","text":"Below you can find a list of all current Output Variables and the necessary Prerequisites.\n\nVariable Prerequisite\nDensity -\nHorizon -\nNumber of Neighbors -\nNumber of Filtered Neighbors Bond-Filter\nUpdate List -\nActive -\nDisplacements -\nVelocity -\nAcceleration -\nForces -\nForce Densities -\nCauchy Stress -\nvon Mises Stress -\nOrientations Rotated Nodes\nDamage Damage Model\nWeighted Volume PD Solid Elastic\nDilatation PD Solid Elastic\nYield Value PD Solid Plastic\nLambda Plastic PD Solid Plastic\nStrain Correspondence\nZero Energy Stiffness Correspondence\nPlastic Strain Correspondence Plastic\nTemperature Thermal Models\nDelta Temperature Thermal Models\nHeat Flow Thermal Models\nSpecific Heat Capacity Thermal Models\nSpecific Volume Thermal Models\nSurface_Nodes Thermal Models\nConcentration Degradation Models\nDelta Concentration Degradation Models\nConcentration Flux Degradation Models\nLumbed Mass Matrix FEA\nFE Nodes FEA\n\ninfo: Own Variables\nAll variables that are defined as global variables are supported as well as those defined in the mesh input f.e.: Angles","category":"section"},{"location":"man/output/#Compute-Class-Parameters","page":"Output","title":"Compute Class Parameters","text":"In order to compute output values for a defined nodesets or blocks, especially for the CSV output format, you can use the following parameters:\n\nCompute Class Parameters:\n    Block_Forces:\n        Compute Class: Block_Data\n        Calculation Type: Sum\n        Block: block_name\n        Variable: Forces\n    NodeSet_Forces:\n        Compute Class: Node_Set_Data\n        Calculation Type: Average\n        Node Set: nodeset_name\n        Variable: Forces\n\nAvailable compute classes are \"BlockData\" or \"NodeSet_Data\".\n\nSupported calculation types are \"Sum\", \"Average\", \"Maximum\", and \"Minimum\".\n\ntip: Referencing the compute class\nThe created variable can be used for CSV as well as Exodus Outputs by referencing it's name in the Output Variable list.\n\n","category":"section"},{"location":"#PeriLab","page":"Introduction","title":"PeriLab","text":"Welcome to the PeriLab documentation!\n\nThis resource aims to teach you everything you need to know to get up and running with tabular data manipulation using the PeriLab.jl package.","category":"section"},{"location":"#What-is-PeriLab.jl?","page":"Introduction","title":"What is PeriLab.jl?","text":"PeriLab.jl provides a Peridynamics [1] simulation core based on the material point method (MPM) [2].\n\nIt's design and functionality are similar to those of Peridigm  [3] and several extenions [4], [5], [6].\n\ntip: PeriLab Project\nThe PeriLab project is built on collaboration and aims to make the world a better place. There is no space here for bullies, racists, or fascists. Groups like MAGA, AfD, and others that actively oppose progress and a better future are not welcome. If spreading hate is your goal, do it elsewhere.","category":"section"},{"location":"#PeriLab.jl-and-the-Peridynamics-Ecosystem","page":"Introduction","title":"PeriLab.jl and the Peridynamics Ecosystem","text":"Mesh-free particle-based methods are mostly used for the numerical approximation of peridynamics equations. [7] provides an overview of current Peridynamics software developments. In addition to this, many local research groups are also developing their software. Most of the listed tools are problem-specific or developed by a single person. The most sophisticated software tools are EMU and Peridigm. EMU is not open source, but researchers can request the code. However, due to the code developments at the Sandia National labs and the rules of development, the code is officially not usable because the rules violate the \"Treaty on the Non-Proliferation of Nuclear Weapons\".\n\nPeridigm is an open-source tool that can be used for large-scale problems. It includes multiple material laws, simple damage models. Peridigm is usable under a BSD license. Currently, there is some irregular development ongoing. It provides multiple ways of model input and provides Paraview readable output. The whole code allows the analysis of large-scale problems. A lot of research has been performed utilizing the software.\n\nsankey-beta\n    Installation,Run time,20\n    Build time, Run time, 10\n    Implementation / Debugging, Run time, 60\n    Calculation, Run time,10\n    Run time, Installation productive, 0\n    Run time, Build time productive, 10\n    Run time, Implementation / Debugging productive, 10\n    Run time, Calculation productive, 80\n\nOne challenge, however, remains. How can Peridynamics be widely adopted? Classical continuum mechanics is extensively utilized in the engineering field through the finite element method. There is a multitude of commercial and non-commercial software tools available for this purpose. In the case of Peridynamics, this is not the case. Peridigm as the most advanced one provides an open-source code with many functionalities. However, the implementation effort is substantial, and the installation process is difficult and time-consuming. To implement the simplest material law you have to edit at least five files. If you add new files and folders in the project you have to deal with cmake scripts and all challenges related to it.\n\nMoreover, the program is only partially maintained. This results in valuable research findings being underutilized, and Peridynamics, as a result, finds limited application outside of specific niche problems. There is a significant need for software that combines functionality, easy installation, and seamless integration.\n\nquadrantChart\n    x-axis Low Functionalty --> High Functionalty\n    y-axis Hard to use --> Simple to use\n    Peridigm: [0.85, 0.2]\n    PeriLab: [0.75, 0.8]\n    EMU: [0.95, 0.1]\n    PeriPy: [0.2, 0.7]\n    Peridynamics.jl: [0.7, 0.6]\n    PeriPyDIC: [0.2, 0.6]\n    LAMMPS: [0.3, 0.3]\n    PeriFlakes: [0.35, 0.4]\n    Relation-Based Software: [0.4, 0.25]\n    BB_PD: [0.2, 0.50]\n    PeriDEM: [0.13, 0.3]","category":"section"},{"location":"#Questions?","page":"Introduction","title":"Questions?","text":"If there is something you expect PeriLab to be capable of, but cannot figure out how to do, please reach out with questions in Domains/Data on Discourse.\n\nPlease report bugs by opening an issue.\n\nYou can follow the source links throughout the documentation to jump right to the source files on GitHub to make pull requests for improving the documentation and function capabilities.\n\nPlease review PeriLab contributing guidelines before submitting your first PR!\n\nInformation on specific versions can be found on the Release page.","category":"section"},{"location":"#Package-Manual","page":"Introduction","title":"Package Manual","text":"Pages = [\"man/basics.md\",\n         \"man/getting_started.md\"]\nDepth = 2","category":"section"},{"location":"#API","page":"Introduction","title":"API","text":"Only exported (i.e. available for use without PeriLab. qualifier after loading the PeriLab.jl package with using PeriLab) types and functions are considered a part of the public API of the PeriLab.jl package. In general all such objects are documented in this manual (in case some documentation is missing please kindly report an issue here).\n\n","category":"section"},{"location":"theory/theory_damage/#Damage-Models-Theory","page":"Damage Models Theory","title":"Damage Models Theory","text":"","category":"section"},{"location":"theory/theory_damage/#Critical-stretch","page":"Damage Models Theory","title":"Critical stretch","text":"The critical stretch model is widely used in literature [1], [34]. It defines the critical length change, or stretch s as a criterion for a damage.\n\ns_critleq s frac underlinemathbfY  underlinemathbfX \n\nThe advantage of this criterion is, that the implementation is rather simple. Also the result is purely geometrical and therefore not influenced by the origin of the bond, because it is neighborhood independent. However, for complex load cases it is to simple and won't work well.\n\nSome literature describes the possibility to compute the critical stretch based on the energy release rate.\n\ns_crit = sqrtfracG_0C3G+(frac34)^4(K-frac5G3)delta","category":"section"},{"location":"theory/theory_damage/#Critical-energy","page":"Damage Models Theory","title":"Critical energy","text":"The critical energy model introduced by [35] is valid for state-based peridynamic analysis. The bond energy is defined as:\n\nw_bond = int_boldsymboleta_final (mathbfunderlineTxtlangle x-xrangle - mathbfunderlineTxtlangle x-xrangle)dboldsymboleta\n\nwith the relative displacement vector as:\n\nboldsymboleta=mathbfunderlineuxt-mathbfunderlineuxt\n\nIf the bond energy is greater than or equal to the critical energy value, then the bond is considered to be broken:\n\nw_crit leq w_bond\n\nFollowing [35] the critical bond energy can be defined as:\n\nw_crit = frac4G_0Cpidelta^4\n\ninfo: Direction\nBecause the bond energy potential can be different in ij compared to ji, the stiffness matrix can become unsymmetric. This is a difference to the critical stretch model. However, the critical stretch varies this might occur as well.\n\n","category":"section"},{"location":"man/basics/#First-Steps-with-PeriLab","page":"First Steps with PeriLab","title":"First Steps with PeriLab","text":"","category":"section"},{"location":"man/basics/#Setting-up-the-Environment","page":"First Steps with PeriLab","title":"Setting up the Environment","text":"If want to use the PeriLab package you need to install it first. You can do it using the following commands:\n\nusing Pkg\n\nPkg.add(\"PeriLab\")\n\nor\n\njulia> ] # ']' should be pressed\n\n(@v1.9) pkg> add PeriLab\n\nAdditionally, it is recommended to check the version of PeriLab that you have installed with the status command.\n\njulia> ]\n\n(@v1.9) pkg> status PeriLab\n      Status `~\\v1.6\\Project.toml`\n  [a93c6f00] PeriLab v1.0.0\n\nThroughout the rest of the tutorial we will assume that you have installed the PeriLab package and have already typed using PeriLab which loads the package:\n\nusing PeriLab\n\nIf you want to make sure everything works as expected you can run the tests bundled with PeriLab:\n\nusing Pkg\n\nPkg.test(\"PeriLab\") # This will take a few minutes.\n\n","category":"section"},{"location":"lib/material_basis_functions/#FEM-Functions","page":"Material Basis","title":"FEM - Functions","text":"","category":"section"},{"location":"lib/material_basis_functions/#Index","page":"Material Basis","title":"Index","text":"Pages = [\"material_basis_functions.md\"]","category":"section"},{"location":"lib/material_basis_functions/#Material_Basis","page":"Material Basis","title":"Material_Basis","text":"","category":"section"},{"location":"lib/material_basis_functions/#PeriLab.Solver_Manager.Material_Basis.check_symmetry-Tuple{Dict, Int64}","page":"Material Basis","title":"PeriLab.Solver_Manager.Material_Basis.check_symmetry","text":"check_symmetry(prop::Dict, dof::Int64)\n\nCheck if the symmetry information is present in the material dictionary.\n\nArguments\n\nprop::Dict: A dictionary containing material information.\ndof::Int64: The number of degrees of freedom.\n\nReturns\n\ntrue: If the symmetry information is present.\n\n\n\n\n\n","category":"method"},{"location":"lib/material_basis_functions/#PeriLab.Solver_Manager.Material_Basis.distribute_forces!-Tuple{Matrix{Float64}, AbstractVector{Int64}, Vector{Vector{Int64}}, Vector{Vector{Int64}}, Vector{Vector{Vector{Float64}}}, Vector{Float64}, Vector{Vector{Float64}}, Matrix{Float64}, Vector{Vector{Vector{Float64}}}}","page":"Material Basis","title":"PeriLab.Solver_Manager.Material_Basis.distribute_forces!","text":"distribute_forces!(nodes::AbstractVector{Int64}, nlist::BondScalarState{Int64}, nlist_filtered_ids::BondScalarState{Int64}, bond_force::Vector{Matrix{Float64}}, volume::NodeScalarField{Float64}, bond_damage::BondScalarState{Float64}, displacements::Matrix{Float64}, bond_norm::Vector{Matrix{Float64}}, force_densities::Matrix{Float64})\n\nDistribute the forces on the nodes\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes.\nnlist::BondScalarState{Int64}: The neighbor list.\nnlist_filtered_ids::BondScalarState{Int64},:  The filtered neighbor list.\nbond_force::Vector{Matrix{Float64}}: The bond forces.\nvolume::NodeScalarField{Float64}: The volumes.\nbond_damage::BondScalarState{Float64}: The bond damage.\ndisplacements::Matrix{Float64}: The displacements.\nbond_norm::Vector{Matrix{Float64}}: The pre defined bond normal.\nforce_densities::Matrix{Float64}: The force densities.\n\nReturns\n\nforce_densities::Matrix{Float64}: The force densities.\n\n\n\n\n\n","category":"method"},{"location":"lib/material_basis_functions/#PeriLab.Solver_Manager.Material_Basis.distribute_forces!-Tuple{Matrix{Float64}, AbstractVector{Int64}, Vector{Vector{Int64}}, Vector{Vector{Vector{Float64}}}, Vector{Float64}, Vector{Vector{Float64}}}","page":"Material Basis","title":"PeriLab.Solver_Manager.Material_Basis.distribute_forces!","text":"distribute_forces!(nodes::AbstractVector{Int64}, nlist::BondScalarState{Int64}, bond_force::Vector{Matrix{Float64}}, volume::NodeScalarField{Float64}, bond_damage::BondScalarState{Float64}, force_densities::Matrix{Float64})\n\nDistribute the forces on the nodes\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes.\nnlist::BondScalarState{Int64}: The neighbor list.\nbond_force::Vector{Matrix{Float64}}: The bond forces.\nvolume::NodeScalarField{Float64}: The volumes.\nbond_damage::BondScalarState{Float64}: The bond damage.\nforce_densities::Matrix{Float64}: The force densities.\n\nReturns\n\nforce_densities::Matrix{Float64}: The force densities.\n\n\n\n\n\n","category":"method"},{"location":"lib/material_basis_functions/#PeriLab.Solver_Manager.Material_Basis.flaw_function-Tuple{Dict, Union{Vector{Float64}, Vector{Int64}, SubArray{Float64}}, Float64}","page":"Material Basis","title":"PeriLab.Solver_Manager.Material_Basis.flaw_function","text":"flaw_function(params::Dict, coor::Union{Vector{Int64},Vector{Float64}}, stress::Float64)\n\nAllows the modification of the yield stress at a specific position. This is typically used as starting point for plastic deformation.\n\nArguments\n\nparams::Dict: A dictionary containing material information.\ncoor::Union{Vector{Int64},Vector{Float64}, SubArray}: Coordinate of the current point.\nstress::Float64: stresses to be modified.\n\nReturns\n\nstress::Float64: the modified stresses.\n\n\n\n\n\n","category":"method"},{"location":"lib/material_basis_functions/#PeriLab.Solver_Manager.Material_Basis.get_Hooke_matrix","page":"Material Basis","title":"PeriLab.Solver_Manager.Material_Basis.get_Hooke_matrix","text":"get_Hooke_matrix(parameter::Dict, symmetry::String, dof::Int64, ID::Int64=1)\n\nReturns the Hooke matrix of the material.\n\nArguments\n\nparameter::Union{Dict{Any,Any},Dict{String,Any}}: The material parameter.\nsymmetry::String: The symmetry of the material.\ndof::Int64: The degree of freedom.\nID::Int64=1: ID of the point. Needed for point wise defined material properties.\n\nReturns\n\nmatrix::Matrix{Float64}: The Hooke matrix.\n\n\n\n\n\n","category":"function"},{"location":"lib/material_basis_functions/#PeriLab.Solver_Manager.Material_Basis.get_all_elastic_moduli-Tuple{Union{Dict{Any, Any}, Dict{String, Any}}}","page":"Material Basis","title":"PeriLab.Solver_Manager.Material_Basis.get_all_elastic_moduli","text":"get_all_elastic_moduli(parameter::Union{Dict{Any,Any},Dict{String,Any}})\n\nReturns the elastic moduli of the material.\n\nArguments\n\nparameter::Union{Dict{Any,Any},Dict{String,Any}}: The material parameter.\n\n\n\n\n\n","category":"method"},{"location":"lib/material_basis_functions/#PeriLab.Solver_Manager.Material_Basis.get_strain-Tuple{Matrix{Float64}, AbstractMatrix{Float64}}","page":"Material Basis","title":"PeriLab.Solver_Manager.Material_Basis.get_strain","text":"get_strain(stress_NP1::Matrix{Float64}, hooke_matrix::Matrix{Float64})\n\nArguments\n\nstress_NP1::Matrix{Float64}: Stress.\nhooke_matrix::Matrix{Float64}: Hooke matrix\n\nreturns\n\nstrain::Matrix{Float64}: Strain\n\n\n\n\n\n","category":"method"},{"location":"lib/material_basis_functions/#PeriLab.Solver_Manager.Material_Basis.get_symmetry-Tuple{Dict}","page":"Material Basis","title":"PeriLab.Solver_Manager.Material_Basis.get_symmetry","text":"get_symmetry(material::Dict)\n\nReturn the symmetry information from the given material dictionary.\n\nArguments\n\nmaterial::Dict: A dictionary containing material information.\n\nReturns\n\nIf the key \"Symmetry\" is present in the dictionary, the corresponding value is returned.\nIf the key is not present, the default value \"3D\" is returned.\n\nExample\n\nmaterial_dict = Dict(\"Symmetry\" => \"Cubic\", \"Color\" => \"Red\")\nsymmetry = get_sym(material_dict)\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#Data-Manager-Functions","page":"Data Manager","title":"Data Manager - Functions","text":"","category":"section"},{"location":"lib/data_manager_functions/#Index","page":"Data Manager","title":"Index","text":"Pages = [\"data_manager_functions.md\"]","category":"section"},{"location":"lib/data_manager_functions/#Data_Manager","page":"Data Manager","title":"Data_Manager","text":"","category":"section"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager._get_field-Tuple{String}","page":"Data Manager","title":"PeriLab.Data_Manager._get_field","text":"_get_field(name::String)\n\nReturns the field with the given name.\n\nArguments\n\nname::String: The name of the field.\n\nReturns\n\nfield::Field: The field with the given name.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.add_active_model","page":"Data Manager","title":"PeriLab.Data_Manager.add_active_model","text":"add_active_model(key::String, module_name::Module)\n\nAdd the main modules to an OrderedDict which are active.\n\nArguments\n\nkey::String: Name of the model.\nactive_module::Module: Module of the active models.\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.check_property-Tuple{Int64, String}","page":"Data Manager","title":"PeriLab.Data_Manager.check_property","text":"check_property(block_id::Int64, property::String)\n\nChecks if the specified property exists for the given block_id.\n\nArguments\n\nblock_id::Int64: The ID of the block.\nproperty::String: The name of the property to check.\n\nReturns\n\nBool: true if the property exists, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.fem_active-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.fem_active","text":"fem_active()\n\nReturns if FEM is active (true) or not (false).\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_accuracy_order-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_accuracy_order","text":"get_accuracy_order()\n\nReturns the accuracy order for the \"bond associated correspondence\" implementation.\n\nArguments\n\nvalue::Int64: The value of the accuracy_order.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_active_models","page":"Data Manager","title":"PeriLab.Data_Manager.get_active_models","text":"get_active_models()\n\nReturns a list active model modules.\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_all_blocks-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_all_blocks","text":"get_all_blocks()\n\nGives back a global list of all block, initially. Is reduced to the outer (not free) surfaces of the contact blocks.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_all_field_keys-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_all_field_keys","text":"get_all_field_keys()\n\nReturns a list of all field keys.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_all_positions-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_all_positions","text":"get_all_positions()\n\nGives back a global list of current positions, initially. Is reduced to the outer (not free) surfaces of the contact blocks.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_aniso_crit_values-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_aniso_crit_values","text":"get_aniso_crit_values()\n\nRetrieves the critical values matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_bc_free_dof-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_bc_free_dof","text":"get_bc_free_dof()\n\nGet all dof without displacment boundary conditions.\n\nReturns\n\nVector{Tuple{Int64, Int64}}: The point and dof without boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_block_id_list-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_block_id_list","text":"get_block_id_list()\n\nReturns a list of all block IDs.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_block_name_list-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_block_name_list","text":"get_block_name_list()\n\nReturns a list of all block IDs.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_bond_damage-Tuple{String}","page":"Data Manager","title":"PeriLab.Data_Manager.get_bond_damage","text":"get_bond_damage(time::String)\n\nGet the bond damage\n\nArguments\n\ntime::String: The time of the field.\n\nReturns\n\ndamage::Field: The bond damage field.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_cancel-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_cancel","text":"get_cancel()\n\nThis function returns the cancel flag.\n\nReturns\n\ncancel::Bool: The value of the cancel variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_comm-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_comm","text":"get_comm()\n\nGet the MPI communicator\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_contact_overlap_map-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_contact_overlap_map","text":"get_contact_overlap_map()\n\nGet the contact overlap map\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_coupling_dict-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_coupling_dict","text":"get_coupling_dict()\n\nGet the PD - FE coupling dict\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_coupling_fe_nodes-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_coupling_fe_nodes","text":"get_coupling_fe_nodes()\n\nGet the FE nodes involved in the coupling\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_crit_values_matrix-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_crit_values_matrix","text":"get_crit_values_matrix()\n\nRetrieves the critical values matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_current_time-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_current_time","text":"get_current_time()\n\nGet the current time of the simulation.\n\nReturns\n\nFloat64: The current time of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_damage-Tuple{String}","page":"Data Manager","title":"PeriLab.Data_Manager.get_damage","text":"get_damage(time::String) -> NodeScalarField{Float64}\n\nGet the damage values for a specific time.\n\nArguments\n\ntime::String: The time identifier for the damage field.\n\nReturns\n\nNodeScalarField{Float64}: The damage values as a vector of floating-point numbers.\n\nExamples\n\ndamage_values = get_damage(\"NP1\")\nprintln(damage_values)  # [1.5, 2.3, 0.8, ...]\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_dof-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_dof","text":"get_dof()\n\nRetrieves the degree of freedom (dof) value.\n\nReturns\n\ndof (integer): The current degree of freedom value.\n\nExample:\n\nget_dof()  # returns the current degree of freedom\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_element_rotation-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_element_rotation","text":"get_element_rotation()\n\nThis function returns the element_rotation flag.\n\nReturns\n\nelement_rotation::Bool: The value of the element_rotation variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_field","page":"Data Manager","title":"PeriLab.Data_Manager.get_field","text":"get_field(name::String, time::String)\n\nReturns the field with the given name and time.\n\nArguments\n\nname::String: The name of the field.\ntime::String: The time of the field.\n\nReturns\n\nfield::Field: The field with the given name and time.\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_field_if_exists","page":"Data Manager","title":"PeriLab.Data_Manager.get_field_if_exists","text":"get_field_if_exists(name::String, time::String)\n\nReturns the field with the given name if it exists.\n\nArguments\n\nname::String: The name of the field.\ntime::String: The time of the field.\n\nReturns\n\nfield::Field: The field with the given name and time.\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_field_type","page":"Data Manager","title":"PeriLab.Data_Manager.get_field_type","text":"get_field_type()\n\nGet the type of a field\n\nReturns\n\nget_field_type (string): returns the type of a field\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_filtered_nlist-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_filtered_nlist","text":"get_filtered_nlist()\n\nGet the neighborhood list.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_inverse_nlist-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_inverse_nlist","text":"get_inverse_nlist()\n\nGet the inverse of the neighborhood list.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_iteration-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_iteration","text":"get_step()\n\nGet the iteration of the simulation.\n\nReturns\n\nInt64: The iteration of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_local_nodes-Tuple{Any}","page":"Data Manager","title":"PeriLab.Data_Manager.get_local_nodes","text":"get_local_nodes()\n\nDetermines the local node numbering.\n\nReturns\n\nget_local_nodes (array): returns local nodes.\n\nExample:\n\nget_local_nodes()  # returns local nodes or if they do not exist at the core an empty array\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_local_synch_fields-Tuple{String}","page":"Data Manager","title":"PeriLab.Data_Manager.get_local_synch_fields","text":"get_local_synch_fields(model::String)\n\nmodel - class of models; before computation of these models the synchronisation occurs\nGet the fields to synchronize\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_max_rank-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_max_rank","text":"get_max_rank()\n\nThis function returns the maximal rank of MPI the max_rank.\n\nReturns\n\nmax_rank::Number: The value of the max_rank variable.\n\nExample\n\nrank = get_max_rank()\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_max_step-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_max_step","text":"get_max_step()\n\nGet the max_step of the simulation.\n\nReturns\n\nInt64: The max_step of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_mpi_active-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_mpi_active","text":"get_mpi_active()\n\nThis function returns if MPI is active.\n\nReturns\n\nmpi_active::Bool\n\nExample\n\nrank = get_mpi_active()\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_nlist-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_nlist","text":"get_nlist()\n\nGet the neighborhood list.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_nnodes-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_nnodes","text":"get_nnodes()\n\nRetrieves the number of nodes.\n\nReturns\n\nnum_controller::Int64 : The current number of nodes.\n\nExample:\n\nget_nnodes()  # returns the current number of controler nodes. The neighbors are not included\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_nnsets-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_nnsets","text":"get_nnsets()\n\nGet the number of node sets.\n\nReturns\n\nnnsets::Int: The number of node sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_nsets-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_nsets","text":"get_nsets()\n\nGet the node sets\n\nReturns\n\nnsets::Dict{String,Vector{Int64}}: The node sets dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_num_elements-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_num_elements","text":"get_num_elements()\n\nGet the the number of finite elements\n\nReturns\n\nget_num_elements::Int64: The number of finite elements\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_num_responder-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_num_responder","text":"get_num_responder()\n\nGet the the number of responder nodes\n\nReturns\n\nnum_responder::Int64: The number of responder nodes\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_output_frequency-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_output_frequency","text":"get_output_frequency()\n\nThis function returns the output_frequency variable.\n\nReturns\n\noutput_frequency::Any: The value of the output_frequency variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_overlap_map-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_overlap_map","text":"get_overlap_map()\n\nGet the overlap map\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_pre_calculation_order-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_pre_calculation_order","text":"get_pre_calculation_order()\n\nreturn the order of the pre calculation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_properties-Tuple{Int64, String}","page":"Data Manager","title":"PeriLab.Data_Manager.get_properties","text":"get_properties(block_id::Int64, property::String)\n\nThis function retrieves the value of a specified property for a given block_id if it exists in the properties dictionary.\n\nArguments\n\nblock_id::Int64: The identifier of the block for which to retrieve the property.\nproperty::String: The dictionary entrycontaining the properties for the blocks.\n\nReturns\n\nproperty_value::Any: The value associated with the specified property for the given block_id.\nDict(): An empty dictionary if the specified property does not exist for the given block_id.\n\nExample\n\nblock_properties = Dict(\n\t1 => Dict(\"color\" => \"red\", \"size\" => 10),\n\t2 => Dict(\"color\" => \"blue\", \"height\" => 20)\n)\n\n# Retrieve the 'color' property for block 1\ncolor_value = get_properties(1, \"color\")  # Returns \"red\"\n\n# Try to retrieve a non-existent property for block 2\nnon_existent_value = get_properties(2, \"width\")  # Returns an empty dictionary\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_property-Tuple{Int64, String, String}","page":"Data Manager","title":"PeriLab.Data_Manager.get_property","text":"get_property(block_id::Int64, property::String, value_name::String)\n\nThis function retrieves a specific value_name associated with a specified property for a given block_id if it exists in the properties dictionary.\n\nArguments\n\nblock_id::Int64: The identifier of the block for which to retrieve the property.\nproperty::String: The String property type (e.g. Material model) for the blocks.\nvalue_name::String: The name of the value within the specified property.\n\nReturns\n\nvalue::Any: The value associated with the specified value_name within the property for the given block_id.\nnothing: If the specified block_id, property, or value_name does not exist in the dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_rank-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_rank","text":"get_rank()\n\nThis function returns the rank of the core.\n\nReturns\n\nrank::Any: The value of the rank variable.\n\nExample\n\ncurrent_rank = get_rank()\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_rotation-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_rotation","text":"get_rotation()\n\nThis function returns the rotation flag.\n\nReturns\n\nrotation::Bool: The value of the rotation variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_silent-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_silent","text":"get_silent()\n\nThis function returns the silent flag.\n\nReturns\n\nsilent::Bool: The value of the silent variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_step-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_step","text":"get_step()\n\nGet the step of the simulation.\n\nReturns\n\nInt64: The step of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_synch_fields-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_synch_fields","text":"get_synch_fields()\n\nGet the fields to synchronize\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.get_verbose-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.get_verbose","text":"get_verbose()\n\nThis function returns the verbose flag.\n\nReturns\n\nverbose::Bool: The value of the verbose variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.has_key-Tuple{String}","page":"Data Manager","title":"PeriLab.Data_Manager.has_key","text":"has_key(field_name::String)::Bool\n\nControl if a key exists.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.init_properties-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.init_properties","text":"init_properties()\n\nThis function initializes the properties dictionary. Order of dictionary defines, in which order the models are called later on.\n\nReturns\n\nkeys(properties[1]): The keys of the properties dictionary in defined order for the Model_Factory.jl.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.initialize_data-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.initialize_data","text":"initialize_data()\n\nInitialize all parameter in the Data_Manager and sets them to the default values.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.loc_to_glob-Tuple{Vector{Int64}}","page":"Data Manager","title":"PeriLab.Data_Manager.loc_to_glob","text":"loc_to_glob(range::UnitRange{Int64})\n\nConverts the local index to the global index.\n\nArguments\n\nrange::Union{UnitRange{Int64}, Vector{Int64}}: The range of the local index.\n\nExample:\n\nloc_to_glob(1:10)  # converts the local index to the global index\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.remove_active_model-Tuple{String}","page":"Data Manager","title":"PeriLab.Data_Manager.remove_active_model","text":"remove_active_model(module_name::Module)\n\nRemoves main modules from OrderedDict.\n\nArguments\n\nkey::String: Key of the entry.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_NP1_to_N-Union{Tuple{T}, Tuple{String, Type{T}}} where T","page":"Data Manager","title":"PeriLab.Data_Manager.set_NP1_to_N","text":"set_NP1_to_N(name::String, type::Type)\n\nSets the NP1toN dataset\n\nArguments\n\nname::String: The name of the field.\ntype::Type The field type\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_accuracy_order-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_Manager.set_accuracy_order","text":"set_accuracy_order(value::Int64)\n\nSets the accuracy order for the \"bond associated correspondence\" implementation.\n\nArguments\n\nvalue::Int64: The value of the accuracy_order.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_aniso_crit_values-Tuple{Dict{Int64, Any}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_aniso_crit_values","text":"setanisocritvalues(critvalues::Dict{Int64,Any})\n\nSets the anisotropic critical values globally.\n\nArguments\n\ncrit_values::Dict{Int64,Any}: The critical values.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_bc_free_dof-Tuple{Vector{Int64}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_bc_free_dof","text":"set_bc_free_dof(values::Vector{Tuple{Int64, Int64}})\n\nSet all dof without displacment boundary conditions.\n\nReturns\n\n\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_block_id_list-Tuple{Vector{Int64}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_block_id_list","text":"set_block_id_list(blocks_id_list::Vector{Int64})\n\nSets the block list globally.\n\nArguments\n\nblocks_id_list::Vector{Int64}: The block list.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_block_name_list-Tuple{Vector{String}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_block_name_list","text":"set_block_name_list(blocks_name_list::Vector{String})\n\nSets the block list globally.\n\nArguments\n\nblocks_name_list::Vector{String}: The block list.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_cancel-Tuple{Bool}","page":"Data Manager","title":"PeriLab.Data_Manager.set_cancel","text":"set_cancel(value::Int64)\n\nSets the cancel flag.\n\nArguments\n\nvalue::Bool: The cancel flag.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_comm-Tuple{MPI.Comm}","page":"Data Manager","title":"PeriLab.Data_Manager.set_comm","text":"set_comm(comm::MPI.Comm)\n\nSet the MPI communicator\n\nArguments\n\ncomm::MPI.Comm: MPI communicator\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_contact_overlap_map-Tuple{Any}","page":"Data Manager","title":"PeriLab.Data_Manager.set_contact_overlap_map","text":"set_contact_overlap_map(topo)\n\nSets the contact overlap map globally.\n\nArguments\n\ntopo: The overlap map.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_coupling_dict-Tuple{Dict{Int64, Int64}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_coupling_dict","text":"set_coupling_dict(coupling_dict::Dict{Int64,Int64})\n\nSets the FE - PD couplings. PD nodes -> FE Elements.\n\nArguments\n\ncoupling_dict::Dict{Int64,Int64}: The coupling dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_coupling_fe_nodes-Tuple{Vector{Int64}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_coupling_fe_nodes","text":"set_coupling_fe_nodes()\n\nGet the FE nodes involved in the coupling\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_crit_values_matrix-Tuple{Array{Float64, 3}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_crit_values_matrix","text":"set_crit_values_matrix(crit_values::Array{Float64,3})\n\nSets the critical values matrix globally.\n\nArguments\n\ncrit_values::Array{Float64,3}: The critical values matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_current_time-Tuple{Float64}","page":"Data Manager","title":"PeriLab.Data_Manager.set_current_time","text":"set_current_time(time::Float64)\n\nSet the current time of the simulation.\n\nArguments\n\ntime::Float64: The current time of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_distribution-Tuple{Vector{Int64}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_distribution","text":"set_distribution(values::Vector{Int64})\n\nSets the distribution globally.\n\nArguments\n\nvalues::Vector{Int64}: The distribution.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_dof-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_Manager.set_dof","text":"set_dof(n::Int64)\n\nSets the degree of freedom (dof) value globally.\n\nArguments\n\nn::Int64: The value to set as the degree of freedom.\n\nExample:\n\nset_dof(3)  # sets the degree of freedom to 3\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_element_rotation-Tuple{Bool}","page":"Data Manager","title":"PeriLab.Data_Manager.set_element_rotation","text":"set_element_rotation(value::Int64)\n\nSets the element_rotation flag.\n\nArguments\n\nvalue::Bool: The element_rotation flag.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_fem-Tuple{Bool}","page":"Data Manager","title":"PeriLab.Data_Manager.set_fem","text":"set_fem(value::Bool)\n\nActivates and deactivates the FEM option in PeriLab\n\nArguments\n\nvalue::Bool: The value to set FEM active (true) or not (false).\n\nExample:\n\nset_fem(true)  # sets the fem_option to true\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_glob_to_loc-Tuple{Dict{Int64, Int64}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_glob_to_loc","text":"set_glob_to_loc(dict::Dict{Int64,Int64})\n\nSets the global-to-local mapping dict globally.\n\nArguments\n\ndict (array): The dict representing the global-to-local mapping.\n\nExample:\n\nset_glob_to_loc([1, 3, 5])  # sets the global-to-local mapping dict\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_inverse_nlist-Tuple{Vector{Dict{Int64, Int64}}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_inverse_nlist","text":"set_inverse_nlist(inv_nlist::Vector{Dict{Int64,Int64}})\n\nSets the inverse nlist globally.\n\nArguments\n\ninv_nlist::Vector{Dict{Int64,Int64}}: The inverse nlist.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_iteration-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_Manager.set_iteration","text":"set_iteration(iteration::Int64)\n\nSet the iteration of the simulation.\n\nArguments\n\niteration::Int64: The iteration of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_local_synch","page":"Data Manager","title":"PeriLab.Data_Manager.set_local_synch","text":"set_local_synch(model, name, download_from_cores, upload_to_cores, dof=0)\n\nSets the synchronization dictionary locally during the model update process. Should be used carefully, to avoid unessary communication.\n\nArguments\n\nname::String: The name of the field.\ndownload_from_cores::Bool: Whether to download the field from the cores.\nupload_to_cores::Bool: Whether to upload the field to the cores.\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_max_rank-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_Manager.set_max_rank","text":"set_max_rank(value::Int64)\n\nSets the maximum rank globally.\n\nArguments\n\nvalue::Int64: The value to set as the maximum rank.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_max_step-Tuple{Union{Nothing, Int64}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_max_step","text":"set_max_step(max_step::Int64)\n\nSet the max_step of the simulation.\n\nArguments\n\nmax_step::Int64: The max_step of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_nnodes-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.set_nnodes","text":"set_nnodes()\n\nSets the number all nodes of one core globally.\n\nArguments\n\nExample: ```\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_nnsets-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_Manager.set_nnsets","text":"set_nnsets(n::Int64)\n\nSet the number of node sets.\n\nArguments\n\nn::Int64: The number of node sets to be set.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_nset-Tuple{String, Vector{Int64}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_nset","text":"set_nset(name, nodes)\n\nSet the nodes associated with a named node set.\n\nArguments\n\nname::String: The name of the node set.\nnodes::Vector{Int}: The node indices associated with the node set.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_num_controller-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_Manager.set_num_controller","text":"set_num_controller(n::Int64)\n\nSets the number of controller nodes globally. For one core the number of nodes is equal to the number of controller nodes.\n\nArguments\n\nn::Int64: The value to set as the number of nodes.\n\nExample:\n\nset_num_controller(10)  # sets the number of nodes to 10\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_num_responder-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_Manager.set_num_responder","text":"set_num_responder(n::Int64)\n\nSets the number of responder nodes globally. For one core the number of responder is zero. responder hold the information of the neighbors, of one node, but are not evaluated.\n\nArguments\n\nn::Int64: The value to set as the number of nodes.\n\nExample:\n\nset_num_responder(10)  # sets the number of responder nodes to 10\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_output_frequency-Tuple{Any}","page":"Data Manager","title":"PeriLab.Data_Manager.set_output_frequency","text":"set_output_frequency(value)\n\nSets the output frequency globally.\n\nArguments\n\nvalue: The value to set as the output frequency.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_overlap_map-Tuple{Any}","page":"Data Manager","title":"PeriLab.Data_Manager.set_overlap_map","text":"set_overlap_map(topo)\n\nSets the overlap map globally.\n\nArguments\n\ntopo: The overlap map.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_pre_calculation_order-Tuple{Vector{String}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_pre_calculation_order","text":"set_pre_calculation_order(values::Vector{String})\n\nSets the order of the pre calculation options globally.\n\nArguments\n\nvalues::Vector{String}: The order of models.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_properties-Union{Tuple{T}, Tuple{Int64, String, T}} where T","page":"Data Manager","title":"PeriLab.Data_Manager.set_properties","text":"set_properties(block_id, property, values)\n\nSets the values of a specified property for a given block_id.\n\nArguments\n\nblock_id::Int64: The identifier of the block for which to set the property.\nproperty::String: The name of the property.\nvalues::Any: The values to set for the specified property.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_properties-Union{Tuple{T}, Tuple{String, T}} where T","page":"Data Manager","title":"PeriLab.Data_Manager.set_properties","text":"set_properties(property, values)\n\nSets the values of a specified property for a all blocks. E.g. for FEM, because it corresponds not to a block yet,\n\nArguments\n\nproperty::String: The name of the property.\nvalues::Any: The values to set for the specified property.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_property-Union{Tuple{T}, Tuple{Int64, String, String, T}} where T","page":"Data Manager","title":"PeriLab.Data_Manager.set_property","text":"set_property(block_id, property, value_name, value)\n\nSets the value of a specified property for a given block_id.\n\nArguments\n\nblock_id::Int64: The identifier of the block for which to set the property.\nproperty::String: The name of the property.\nvalue_name::String: The name of the value within the specified property.\nvalue::Any: The value to set for the specified value_name.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_rank-Tuple{Int64}","page":"Data Manager","title":"PeriLab.Data_Manager.set_rank","text":"set_rank(value::Int64)\n\nSets the rank globally.\n\nArguments\n\nvalue::Int64: The value to set as the rank.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_rotation-Tuple{Bool}","page":"Data Manager","title":"PeriLab.Data_Manager.set_rotation","text":"set_rotation(value::Int64)\n\nSets the rotation flag.\n\nArguments\n\nvalue::Bool: The rotation flag.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_silent-Tuple{Bool}","page":"Data Manager","title":"PeriLab.Data_Manager.set_silent","text":"set_silent(value::Bool)\n\nSets the silent flag.\n\nArguments\n\nvalue::Bool: The silent flag.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_step-Tuple{Union{Nothing, Int64}}","page":"Data Manager","title":"PeriLab.Data_Manager.set_step","text":"set_step(step::Int64)\n\nSet the step of the simulation.\n\nArguments\n\nstep::Int64: The step of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_synch","page":"Data Manager","title":"PeriLab.Data_Manager.set_synch","text":"set_synch(name, download_from_cores, upload_to_cores)\n\nSets the synchronization dictionary globally.\n\nArguments\n\nname::String: The name of the field.\ndownload_from_cores::Bool: Whether to download the field from the cores.\nupload_to_cores::Bool: Whether to upload the field to the cores.\n\n\n\n\n\n","category":"function"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.set_verbose-Tuple{Bool}","page":"Data Manager","title":"PeriLab.Data_Manager.set_verbose","text":"set_verbose(value::Bool)\n\nSets the verbose flag.\n\nArguments\n\nvalue::Bool: The verbose flag.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.switch_NP1_to_N-Tuple{}","page":"Data Manager","title":"PeriLab.Data_Manager.switch_NP1_to_N","text":"switch_NP1_to_N()\n\nSwitches the fields from NP1 to N. This is more efficient than copying the data from one field the other.\n\n\n\n\n\n","category":"method"},{"location":"lib/data_manager_functions/#PeriLab.Data_Manager.synch_manager-Tuple{Any, String}","page":"Data Manager","title":"PeriLab.Data_Manager.synch_manager","text":"synch_manager(synchronise_field, direction::String)\n\nSynchronises the fields.\n\nArguments\n\nsynchronise_field: The function to synchronise the field.\ndirection::String: The direction of the synchronisation.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#Model-Factory-Functions","page":"Model Factory","title":"Model Factory - Functions","text":"","category":"section"},{"location":"lib/model_factory_functions/#Index","page":"Model Factory","title":"Index","text":"Pages = [\"model_factory_functions.md\"]","category":"section"},{"location":"lib/model_factory_functions/#Models","page":"Model Factory","title":"Models","text":"","category":"section"},{"location":"lib/model_factory_functions/#Additive","page":"Model Factory","title":"Additive","text":"","category":"section"},{"location":"lib/model_factory_functions/#Damage","page":"Model Factory","title":"Damage","text":"","category":"section"},{"location":"lib/model_factory_functions/#Degradation","page":"Model Factory","title":"Degradation","text":"","category":"section"},{"location":"lib/model_factory_functions/#Material","page":"Model Factory","title":"Material","text":"","category":"section"},{"location":"lib/model_factory_functions/#Thermal","page":"Model Factory","title":"Thermal","text":"","category":"section"},{"location":"lib/model_factory_functions/#Pre_Calculation","page":"Model Factory","title":"Pre_Calculation","text":"","category":"section"},{"location":"lib/model_factory_functions/#Surface_Correction","page":"Model Factory","title":"Surface_Correction","text":"","category":"section"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.add_model","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.add_model","text":"add_model(model_name::String)\n\nIncludes the models in the Data_Manager and checks if the model definition is correct or not.\n\nArguments\n\nmodel_name::String: The block nodes\n\n\n\n\n\n","category":"function"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.compute_crititical_time_step-Tuple{Dict{Int64, Vector{Int64}}, Bool, Bool}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.compute_crititical_time_step","text":"compute_crititical_time_step(block_nodes::Dict{Int64,Vector{Int64}}, mechanical::Bool, thermo::Bool)\n\nCalculate the critical time step for a simulation considering both mechanical and thermodynamic aspects.\n\nThis function computes the critical time step by considering mechanical and thermodynamic properties of different blocks. The resulting critical time step is based on the smallest critical time step found among the blocks.\n\nArguments\n\nblock_nodes::Dict{Int64, Vector{Int64}}: A dictionary mapping block IDs to collections of nodes.\nmechanical::Bool: If true, mechanical properties are considered in the calculation.\nthermo::Bool: If true, thermodynamic properties are considered in the calculation.\n\nReturns\n\nFloat64: The calculated critical time step based on the smallest critical time step found among the blocks.\n\nDependencies\n\nThis function may depend on the following functions:\n\ncompute_thermodynamic_critical_time_step: Used if thermo is true to calculate thermodynamic critical time steps.\ncompute_mechanical_critical_time_step: Used if mechanical is true to calculate mechanical critical time steps.\nThe availability of specific properties from the data manager module.\n\nErrors\n\nIf required properties are not available in the data manager, it may raise an error message.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.compute_mechanical_critical_time_step-Tuple{AbstractVector{Int64}, Union{Float64, Int64, SubArray, Vector{Float64}}}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.compute_mechanical_critical_time_step","text":"compute_mechanical_critical_time_step(nodes::AbstractVector{Int64}, bulk_modulus::Float64)\n\nCalculate the critical time step for a mechanical simulation using a bond-based approximation [38].\n\nThis function iterates over a collection of nodes and computes the critical time step for each node based on the given input data and parameters.\n\nArguments\n\nnodes::AbstractVector{Int64}: The collection of nodes to calculate the critical time step for.\nbulk_modulus::Float64: The bulk modulus used in the calculations.\n\nReturns\n\nFloat64: The calculated critical time step for the mechanical simulation.\n\nDependencies\n\nThis function depends on the following data fields from the Data_Manager module:\n\nget_nlist(): Returns the neighbor list.\nget_field(\"Density\"): Returns the density field.\nget_field(\"Bond Length\"): Returns the bond distance field.\nget_field(\"Volume\"): Returns the volume field.\nget_field(\"Horizon\"): Returns the horizon field.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.compute_models-Tuple{Dict{Int64, Vector{Int64}}, Float64, Float64, Vector{String}, Any}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.compute_models","text":"compute_models(block_nodes::Dict{Int64,Vector{Int64}}, dt::Float64, time::Float64, options::Vector{String}, synchronise_field)\n\nComputes the material point models\n\nArguments\n\nblock_nodes::Dict{Int64,Vector{Int64}}: The block nodes\ndt::Float64: The time step\ntime::Float64: The current time of the solver\noptions::Vector{String}: The options\nsynchronise_field: The synchronise field\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.compute_stiff_matrix_compatible_models-Tuple{Dict{Int64, Vector{Int64}}, Float64, Float64, Vector{String}, Any}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.compute_stiff_matrix_compatible_models","text":"compute_stiff_matrix_compatible_models(block_nodes::Dict{Int64,Vector{Int64}}, dt::Float64, time::Float64, options::Vector{String}, synchronise_field)\n\nComputes the models models that are compatible with the stiffness matrix calculation.\n\nArguments\n\nblock_nodes::Dict{Int64,Vector{Int64}}: The block nodes\ndt::Float64: The time step\ntime::Float64: The current time of the solver\noptions::Vector{String}: The options\nsynchronise_field: The synchronise field\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.compute_thermodynamic_critical_time_step-Tuple{AbstractVector{Int64}, Union{Float64, Int64}}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.compute_thermodynamic_critical_time_step","text":"compute_thermodynamic_critical_time_step(nodes::AbstractVector{Int64}, lambda::Float64, Cv::Float64)\n\nCalculate the critical time step for a thermodynamic simulation based on  [24].\n\nThis function iterates over a collection of nodes and computes the critical time step for each node using provided input data and parameters.\n\nArguments\n\nnodes::AbstractVector{Int64}: The collection of nodes to calculate the critical time step for.\nlambda::Float64: The material parameter used in the calculations.\nCv::Float64: The heat capacity at constant volume used in the calculations.\n\nReturns\n\nFloat64: The calculated critical time step for the thermodynamic simulation.\n\nDependencies\n\nThis function depends on the following data fields from the Data_Manager module:\n\nget_nlist(): Returns the neighbor list.\nget_field(\"Density\"): Returns the density field.\nget_field(\"Bond Length\"): Returns the bond distance field.\nget_field(\"Volume\"): Returns the volume field.\nget_field(\"Number of Neighbors\"): Returns the number of neighbors field.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.get_block_model_definition","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.get_block_model_definition","text":"get_block_model_definition(params::Dict, block_id_list::Int64, prop_keys::Vector{String}, properties)\n\nGet block model definition.\n\nSpecial case for pre calculation. It is set to all blocks, if no block definition is defined, but pre calculation is.\n\nArguments\n\nparams::Dict: Parameters.\nblock_id_list::Vector{Int64}: List of block id's.\nprop_keys::Vector{String}: Property keys.\nproperties: Properties function.\n\nReturns\n\nproperties: Properties function.\n\n\n\n\n\n","category":"function"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.get_cs_denominator-Tuple{AbstractVector{Float64}, AbstractVector{Float64}}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.get_cs_denominator","text":"get_cs_denominator(volume::AbstractVector{Float64}, undeformed_bond::AbstractVector{Float64})\n\nCalculate the denominator for the critical time step calculation.\n\nArguments\n\nvolume::AbstractVector{Float64}: The volume field.\nundeformed_bond::Union{SubArray,Vector{Float64},Vector{Int64}}: The undeformed bond field.\n\nReturns\n\nFloat64: The denominator for the critical time step calculation.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.init_models-Tuple{Dict, Dict{Int64, Vector{Int64}}, Dict, Any}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.init_models","text":"init_models(params::Dict, block_nodes::Dict{Int64,Vector{Int64}}, solver_options::Dict)\n\nInitialize models\n\nArguments\n\nparams::Dict: Parameters.\nblock_nodes::Dict{Int64,Vector{Int64}}: block nodes.\nsolver_options::Dict: Solver options.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.read_properties-Tuple{Dict, Bool}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.read_properties","text":"read_properties(params::Dict, material_model::Bool)\n\nRead properties of material.\n\nArguments\n\nparams::Dict: Parameters.\nmaterial_model::Bool: Material model.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.set_heat_capacity-Tuple{Dict, Dict, Vector{Float64}}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.set_heat_capacity","text":"set_heat_capacity(params::Dict, block_nodes::Dict, heat_capacity::NodeScalarField{Float64})\n\nSets the heat capacity of the nodes in the dictionary.\n\nArguments\n\nparams::Dict: The parameters\nblock_nodes::Dict: The block nodes\nheat_capacity::NodeScalarField{Float64}: The heat capacity array\n\nReturns\n\nheat_capacity::SubArray: The heat capacity array\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.test_timestep-Tuple{Float64, Float64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.test_timestep","text":"test_timestep(t::Float64, critical_time_step::Float64)\n\nCompare a time step t with a critical time step critical_time_step and update critical_time_step if t is smaller.\n\nArguments\n\nt::Float64: The time step to compare with critical_time_step.\ncritical_time_step::Float64: The current critical time step.\n\nReturns\n\ncritical_time_step::Float64: The updated critical time step, which is either the original critical_time_step or t, whichever is smaller.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Additive.compute_model-Tuple{AbstractVector{Int64}, Dict, Int64, Float64, Float64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Additive.compute_model","text":"compute_model(nodes::AbstractVector{Int64}, model_param::Dict, block::Int64, time::Float64, dt::Float64)\n\nComputes the addtive models\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes\nmodel_param::Dict: The model parameters\nblock::Int64: The block\ntime::Float64: The current time\ndt::Float64: The time step\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Additive.fields_for_local_synchronization-Tuple{Any, Any}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Additive.fields_for_local_synchronization","text":"fields_for_local_synchronization(model, block)\n\nDefines all synchronization fields for local synchronization\n\nArguments\n\nmodel::String: Model class.\nblock::Int64: block ID\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Additive.init_fields-Tuple{}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Additive.init_fields","text":"init_fields()\n\nInitialize additive model fields\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Additive.init_model-Tuple{AbstractVector{Int64}, Int64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Additive.init_model","text":"init_model(nodes::AbstractVector{Int64}, block::Int64)\n\nInitialize the additive models.\n\nArguments\n\nnodes::AbstractVector{Int64}: Nodes for the additive model.\nblock::Int64: Block identifier for the additive model.\n\nExample\n\ninit_model(my_data_manager, [1, 2, 3], 1)\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Damage.compute_model-Tuple{AbstractVector{Int64}, Dict, Int64, Float64, Float64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Damage.compute_model","text":"compute_model(nodes::AbstractVector{Int64}, model_param::Dict, block::Int64, time::Float64, dt::Float64)\n\nComputes the damage model\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes\nmodel_param::Dict: The model parameters\nblock::Int64: The block\ntime::Float64: The current time\ndt::Float64: The time step\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Damage.damage_index-Tuple{AbstractVector{Int64}, Vector{Vector{Int64}}}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Damage.damage_index","text":"damage_index(::Union{SubArray, Vector{Int64})\n\nFunction calculates the damage index related to the neighborhood volume for a set of corresponding nodes. The damage index is defined as damaged volume in relation the neighborhood volume. damageIndex = sumi (brokenBondsi * volume_i) / volumeNeighborhood\n\nArguments\n\nnodes::AbstractVector{Int64}: corresponding nodes to this model\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Damage.fields_for_local_synchronization-Tuple{Any, Any}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Damage.fields_for_local_synchronization","text":"fields_for_local_synchronization(model, block)\n\nDefines all synchronization fields for local synchronization\n\nArguments\n\nmodel::String: Model class.\nblock::Int64: block ID\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Damage.init_aniso_crit_values-Tuple{Dict, Int64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Damage.init_aniso_crit_values","text":"init_aniso_crit_values(params::Dict, block_id::Int64)\n\nInitialize the anisotropic critical values\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: current block\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Damage.init_fields-Tuple{}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Damage.init_fields","text":"init_fields()\n\nInitialize damage model fields\n\nArguments\n\nparams::Dict: Parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Damage.init_interface_crit_values-Tuple{Dict, Int64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Damage.init_interface_crit_values","text":"init_interface_crit_values(params::Dict, block_id::Int64)\n\nInitialize the critical values\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: current block\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Damage.init_model-Tuple{AbstractVector{Int64}, Int64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Damage.init_model","text":"init_model(nodes::AbstractVector{Int64}, block::Int64)\n\nInitialize the damage models.\n\nArguments\n\nnodes::AbstractVector{Int64}: Nodes for the degradation model.\nblock::Int64: Block identifier for the degradation model.\n\nExample\n\ninit_model(my_data_manager, [1, 2, 3], 1)\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Degradation.compute_model-Tuple{AbstractVector{Int64}, Dict, Int64, Float64, Float64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Degradation.compute_model","text":"compute_model(nodes::AbstractVector{Int64}, model_param::Dict, block::Int64, time::Float64, dt::Float64)\n\nComputes the degradation models\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes\nmodel_param::Dict: The model parameters\nblock::Int64: The block\ntime::Float64: The current time\ndt::Float64: The time step\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Degradation.fields_for_local_synchronization-Tuple{Any, Any}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Degradation.fields_for_local_synchronization","text":"fields_for_local_synchronization(model, block)\n\nDefines all synchronization fields for local synchronization\n\nArguments\n\nmodel::String: Model class.\nblock::Int64: block ID\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Degradation.init_fields-Tuple{}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Degradation.init_fields","text":"init_fields()\n\nInitialize  model fields\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Degradation.init_model-Tuple{AbstractVector{Int64}, Int64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Degradation.init_model","text":"init_model(nodes::AbstractVector{Int64}, block::Int64)\n\nInitialize a degradation models.\n\nArguments\n\nnodes::AbstractVector{Int64}: Nodes for the degradation model.\nblock::Int64: Block identifier for the degradation model.\n\nExample\n\ninit_model(my_data_manager, [1, 2, 3], 1)\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Material.check_material_symmetry-Tuple{Int64, Dict}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Material.check_material_symmetry","text":"check_material_symmetry(dof::Int64, prop::Dict)\n\nCheck the symmetry of the material.\n\nArguments\n\ndof::Int64: The degree of freedom.\nprop::Dict: The material property.\n\nReturns\n\nprop::Dict: The material property.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Material.compute_model-Tuple{AbstractVector{Int64}, Dict{String, Any}, Int64, Float64, Float64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Material.compute_model","text":"compute_model(nodes::AbstractVector{Int64}, model_param::Dict{String,Any}, block::Int64, time::Float64, dt::Float64)\n\nComputes the material models\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes\nmodel_param::Dict{String,Any}: The model parameters\nblock::Int64: The block\ntime::Float64: The current time\ndt::Float64: The time step\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Material.determine_isotropic_parameter-Tuple{Dict}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Material.determine_isotropic_parameter","text":"determine_isotropic_parameter(prop::Dict)\n\nDetermine the isotropic parameter.\n\nArguments\n\nprop::Dict: The material property.\n\nReturns\n\nprop::Dict: The material property.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Material.distribute_force_densities-Tuple{AbstractVector{Int64}}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Material.distribute_force_densities","text":"distribute_force_densities(nodes::AbstractVector{Int64})\n\nDistribute the force densities.\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Material.fields_for_local_synchronization-Tuple{Any, Any}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Material.fields_for_local_synchronization","text":"fields_for_local_synchronization(model, block)\n\nDefines all synchronization fields for local synchronization\n\nArguments\n\nmodel::String: Model class.\nblock::Int64: block id\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Material.init_fields-Tuple{}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Material.init_fields","text":"init_fields()\n\nInitialize material model fields\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Material.init_model-Tuple{AbstractVector{Int64}, Int64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Material.init_model","text":"init_model(nodes::Union{SubArray,Vector{Int64}, block::Int64)\n\nInitializes the material model.\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes.\nblock::Int64: Block.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Thermal.compute_model-Tuple{AbstractVector{Int64}, Dict, Int64, Float64, Float64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Thermal.compute_model","text":"compute_model(nodes::AbstractVector{Int64}, model_param::Dict, block::Int64, time::Float64, dt::Float64)\n\nComputes the thermal models\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes\nmodel_param::Dict: The model parameters\nblock::Int64: The block\ntime::Float64: The current time\ndt::Float64: The time step\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Thermal.init_fields-Tuple{}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Thermal.init_fields","text":"init_fields()\n\nInitialize thermal model fields\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Thermal.init_model-Tuple{AbstractVector{Int64}, Int64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Thermal.init_model","text":"init_model(nodes::Union{SubArray,Vector{Int64}, block::Int64)\n\nInitializes the thermal model.\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes.\nblock::Int64: Block.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Pre_Calculation.check_dependencies-Tuple{Dict{Int64, Vector{Int64}}}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Pre_Calculation.check_dependencies","text":"check_dependencies(block_nodes::Dict{Int64,Vector{Int64}}\n\nCheck if materials are used which needs a form of pre calculation. If so, the option will be set.\n\nArguments\n\nblock_nodes::Dict{Int64,Vector{Int64}}: block nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Pre_Calculation.compute_model-Tuple{AbstractVector{Int64}, Union{Dict, OrderedCollections.OrderedDict}, Int64, Float64, Float64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Pre_Calculation.compute_model","text":"compute_model(nodes::AbstractVector{Int64}, model_param::Dict, block::Int64, time::Float64, dt::Float64)\n\nComputes the pre calculation models\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes\nmodel_param::Dict: The model parameters\nblock::Int64: The block\ntime::Float64: The current time\ndt::Float64: The time step\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Pre_Calculation.init_fields-Tuple{}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Pre_Calculation.init_fields","text":"init_fields()\n\nInitializes the fields.\n\n\n\n\n\n","category":"method"},{"location":"lib/model_factory_functions/#PeriLab.Solver_Manager.Model_Factory.Pre_Calculation.init_model-Tuple{AbstractVector{Int64}, Int64}","page":"Model Factory","title":"PeriLab.Solver_Manager.Model_Factory.Pre_Calculation.init_model","text":"init_model(nodes::Union{SubArray,Vector{Int64}, block::Int64)\n\nInitializes the model.\n\nArguments\n\nnodes::AbstractVector{Int64}: The nodes.\nblock::Int64: Block.\n\n\n\n\n\n","category":"method"},{"location":"theory/theory_FEM_PD_coupling/#Finite-Element-Peridynamics-coupling","page":"Finite Element - Peridynamics coupling","title":"Finite Element - Peridynamics coupling","text":"Module Related Model in PeriLab\nArlequin_coupling Arlequin Method\n\nTo couple PD with FEM the distance between the expected PD deformation and the FEM deformation has to be computed [28].\n\nmathbfz(mathbfu)=mathbfz_0mathbfZmathbfu\n\nAssume the displacement constraints in the overlapping zone between local and non-local domains are described as: mathbfz=d-sum_OmegamathbfN_i(boldsymbolxi)mathbfu_i with mathbfd the displacement of the PD point and sum_OmegamathbfN_i(boldsymbolxi)mathbfu_i the displacement within the finite element.\n\nWith\n\nmathbfK_z=kappabeginbmatrix\nmathbfI  mathbfN_d \nmathbfN^T_d  mathbfN^T_dmathbfN_d\nendbmatrixbeginbmatrix\nmathbfd  \nmathbfu\nendbmatrix","category":"section"},{"location":"theory/theory_FEM_PD_coupling/#Arlequin","page":"Finite Element - Peridynamics coupling","title":"Arlequin","text":"Following [28] for the Arlequng method the equation of motion of the coupled system in discretized form looks as follows:\n\nkappabeginbmatrix\nfracalphaV_elmathbfM_FE   \n  (1-alpha)rho_PD\nendbmatrixbeginbmatrix\nddotmathbfd  \nddotmathbfu\nendbmatrix + beginbmatrix\nfracalphaV_elmathbfK_FE   \n  (1-alpha)mathbff_PD\nendbmatrixbeginbmatrix\nmathbfd  \nmathbfu\nendbmatrix + mathbfK_zbeginbmatrix\nmathbfd_0  \nmathbfu_0\nendbmatrix=beginbmatrix\nfracalphaV_elmathbfF_FE  \n(1-alpha)mathbfb_PD\nendbmatrix\n\nThe Integration is illustrated in [29].\n\n","category":"section"},{"location":"lib/logging_functions/#Logging-Functions","page":"Logging","title":"Logging - Functions","text":"","category":"section"},{"location":"lib/logging_functions/#Index","page":"Logging","title":"Index","text":"Pages = [\"logging_functions.md\"]","category":"section"},{"location":"lib/logging_functions/#Logging_Module","page":"Logging","title":"Logging_Module","text":"","category":"section"},{"location":"lib/logging_functions/#PeriLab.Logging_Module.get_log_file-Tuple{}","page":"Logging","title":"PeriLab.Logging_Module.get_log_file","text":"get_log_file()\n\nGet the log file.\n\nReturns\n\nlog_file::String: The log file.\n\n\n\n\n\n","category":"method"},{"location":"lib/logging_functions/#PeriLab.Logging_Module.init_logging-Tuple{String, Bool, Bool, Int64, Int64}","page":"Logging","title":"PeriLab.Logging_Module.init_logging","text":"init_logging(filename::String, debug::Bool, silent::Bool, rank::Int64, size::Int64)\n\nInitialize the logging.\n\nArguments\n\nfilename::String: The filename.\ndebug::Bool: If debug is true.\nsilent::Bool: If silent is true.\nrank::Int64: The rank.\nsize::Int64: The size.\n\n\n\n\n\n","category":"method"},{"location":"lib/logging_functions/#PeriLab.Logging_Module.print_table-Tuple{Matrix}","page":"Logging","title":"PeriLab.Logging_Module.print_table","text":"print_table(data::Matrix)\n\nPrint the table.\n\nArguments\n\ndata::Matrix: The data.\n\n\n\n\n\n","category":"method"},{"location":"lib/logging_functions/#PeriLab.Logging_Module.progress_filter-Tuple{Any}","page":"Logging","title":"PeriLab.Logging_Module.progress_filter","text":"progress_filter(log_args)\n\nFilter progress messages.\n\nArguments\n\nlog_args: The log arguments.\n\nReturns\n\ntrue: If the message is not a progress message.\nfalse: If the message is a progress message.\n\n\n\n\n\n","category":"method"},{"location":"lib/logging_functions/#PeriLab.Logging_Module.set_log_file-Tuple{String, Bool, Int64, Int64}","page":"Logging","title":"PeriLab.Logging_Module.set_log_file","text":"set_log_file(filename::String)\n\nSet the log file.\n\nArguments\n\nfilename::String: The filename.\n\nReturns\n\nlog_file::String: The log file.\n\n\n\n\n\n","category":"method"},{"location":"man/models/additive/#Additive-Models","page":"Additive Models","title":"Additive Models","text":"Additive Model Simple\nPrint Temperature âœ”ï¸","category":"section"},{"location":"man/models/additive/#Simple","page":"Additive Models","title":"Simple","text":"To realize an additive model all bonds from a point are disconnected from it's neighbors by setting all underlineomegalangleboldsymbolxirangle = 0. Within the mesh input an activation time is specified t_activate. If this time is reached during the simulation process the point is activated.\n\nunderlineomegalangleboldsymbolxirangle in mathcalH_textbfx =    leftbeginarrayl\n0 qquadtextfor tt_activate\n1  qquadtextfor t geq t_activate\nendarrayright\n\nDepended on the process modeled, additional information can be passed to the point or the bonds connected with him. For this simple printing process a printing temperature is added utilized the heat source S_i. In the presented model, the bonding is ideal an no phase or chemical changes occur. However, in principal such models are applicable. Also it must be noted, that due to mechanical or thermo-mechanical loading bonds can be damaged, if a damage model is applied. In that case it won't be activated again.\n\nWithin this process the t_activate can be user defined. However, to reproduce real processes an interface with the G-code is needed. This interface provides the information when the tool arrives at a specific point and defines the activation time as shown in the figure (taken from [9]).\n\n(Image: Virtual printing process)\n\n","category":"section"},{"location":"lecture/seminar_4/#Seminar-4:-From-bond-based-to-state-based-I-(Theory)","page":"Seminar 4","title":"Seminar 4: From bond-based to state-based I (Theory)","text":"Definition of states\n\nA state is not in general a linear function of xi .\nA state is not in general a continuous function of xi.\nThe real Euclidean space V is infinite-dimensional, while the real Euclidean space mathcalL_2 (the set of second order tensors) has dimension 9\n\nDefinitions\n\nscalar state\n\nunderlinealangle boldsymbolxirangle\n\nvector state\n\nunderlinemathbfAlangle boldsymbolxirangle\n\nShape tensor\n\nmathbfK = underlinemathbfX*underlinemathbfX = int_mathcalHunderlineomegalangle boldsymbolxirangleunderlinemathbfXlangle boldsymbolxirangleotimesunderlinemathbfXlangle boldsymbolxirangle dV\n\nis positive definite\n\n(Image: )\n\nFigure taken from [14]","category":"section"},{"location":"lecture/seminar_4/#Constitutive-Models","page":"Seminar 4","title":"Constitutive Models","text":"(Image: )\n\nboldsymbolxi = mathbfx-mathbfx\n\nDeformation vector state field\n\nunderlinemathbfYmathbfxtlangle boldsymbolxirangle=mathbfy(mathbfx+boldsymbolxit)-mathbfy(mathbfxt)\n\nA material is elastic if there exists a differentiable scalar valued function W()  mathcalV rightarrow mathbbR such that\n\nunderlinemathbfT= hatunderlinemathbfT(underlinemathbfY)= nabla W(underlinemathbfY)\n\nW\n\nis the strain energy density function.","category":"section"},{"location":"lecture/seminar_4/#Ordinary-state-based","page":"Seminar 4","title":"Ordinary state-based","text":"Ordinary and elastic means\n\nIt is mobile\nThere exists a scalar-valued function w\n\nW(underlinemathbfY)= w(underliney)qquadtextandqquad underliney=underlinemathbfY\n\nFor this w\n\nunderlinet(underliney)= nabla w(underliney)","category":"section"},{"location":"lecture/seminar_4/#PD-solid-elastic","page":"Seminar 4","title":"PD solid elastic","text":"Concept uses LamÃ© coefficients boldsymbolsigma = 2Gboldsymbolvarepsilon + K  operatornametr(boldsymbolvarepsilon) I\n\nunderlineelangleboldsymbolxirangle=mathbfFboldsymbolxi - boldsymbolxi=varepsilon_ijfracxi_ixi_jboldsymbolxi\n\nvarepsilon_ij=frac12(u_ij+u_ji)\n\nunderlinee^dlangleboldsymbolxirangle=varepsilon_ij^dfracxi_ixi_jboldsymbolxi\n\nW=fracalpha2int_mathcalHunderlineomegalangleboldsymbolxirangle(underlinee^dlangleboldsymbolxirangle)^2dV_boldsymbolxi\n\nunder assumption of a spherical non-local domain.\n\nW = fracalpha m15varepsilon_ij^dvarepsilon_ij^d\n\ncompared with the strain energy density of the classical model.\n\nOmega=Gvarepsilon_ij^dvarepsilon_ij^d\n\nalpha=frac15Gm\n\n\n\nunderlinex=underlinemathbfX=boldsymbolxiquadunderliney=underlinemathbfY\n\nunderlinee=underliney-underlinex=boldsymboleta\n\nunderliney-underlinexneqboldsymboleta\n\nunderlinet=underlinemathbfT\n\nWeighted volume\n\nm_V = int_mathcalH underlineomegalangle boldsymbolxirangle underlinex underlinex dV\n\nDilatation\n\ntheta = frac3m_V  int_mathcalHunderlineomegalangle boldsymbolxirangle underlinex underlineelangle boldsymbolxirangle dV\n\nunderlinet = fracomegalangle boldsymbolxirangle m_Vleft3K theta underlinex + 15G underlinee^d  right\n\nDecomposition in the devatoring and isotropic part of the strain\n\nunderlinee^dlangle boldsymbolxirangle = epsilon_ij^dxi_ifracx_jboldsymbolxi\n\nunderlinee^ilangle boldsymbolxirangle = epsilon_ij^ixi_ifracx_jboldsymbolxi\n\nThe force density can be determined as\n\nunderlinemathbfT=underlinetfracunderlinemathbfYunderlinemathbfY","category":"section"},{"location":"lecture/seminar_4/#Correspondence","page":"Seminar 4","title":"Correspondence","text":"underlinemathbfYlangle boldsymbolxirangle=mathbfFboldsymbolxi\n\nThen the peridynamic constitutive model corresponds to the classical constitutive model at mathbfF [14].\n\nmathbfF=int_mathcalH(underlineomegalangle boldsymbolxirangleunderlinemathbfYlangle boldsymbolxirangleotimesunderlinemathbfXlangle boldsymbolxirangle dV )cdot mathbfK^-1\n\nmathbfK=int_mathcalHunderlineomegalangle boldsymbolxirangleunderlinemathbfXlangle boldsymbolxirangleotimesunderlinemathbfXlangle boldsymbolxirangle dV\n\nboldsymbolsigma = f(mathbfF t T )\n\nmathbfP = textdet(mathbfF)boldsymbolsigmamathbfF^-T\n\nunderlinemathbfT = underlineomegalangle boldsymbolxiranglemathbfPmathbfK^-1mathbfxi","category":"section"},{"location":"lecture/seminar_4/#Zero-energy-modes","page":"Seminar 4","title":"Zero-energy modes","text":"For correspondence models, the so called zero-energy modes could occur [15]. These modes are non-physical and lead to unstable or unreasonable solutions. Several stabilization methods were published to overcome this problem [16], [17], [18], [19],[20],[21].\n\nunderlinemathbfT^C=underlinemathbfT+underlinemathbfT^S\n\nunderlinemathbfT^Slangle boldsymbolxirangle = underlineomegalangleboldsymbolxiranglemathbfC_1underlinemathbfz\n\nunderlinemathbfzlangle boldsymbolxirangle= underlinemathbfYlangleboldsymbolxi rangle-mathbfFboldsymbolxi\n\nmathbfC_1=mathbfCcdotcdotmathbfK^-1\n\n\nx = [1,2,3,4,5]\n\na = [1,2,3,4,5]\n\nintegral_a = sum(a)\n\nb=[1,2,3.1,3.9,5]\n\nintegral_b = sum(b)\n\ndisplay(integral_a - integral_b)\n\n\nfunction def_grad(x,y)\n    K = sum(x)\n    F = sum(y)/K\n    display(\"F*x $(F.*x')\")\n    display(\"z $(F.*x' - y)\")\nend\n\nx = [1,2,3,4]\ny = [0.5 1. 1.5 2]\n\nprintln(\"Constant deformation gradient in non-local domain\")\ndef_grad(x,y)\n\n\ny = [0.5 0.9 1.6 2]\nprintln(\"Non-Constant deformation gradient in non-local domain\")\ndef_grad(x,y)\n","category":"section"},{"location":"lecture/seminar_4/#Properties-of-\\mathbf{K}-and-\\mathbf{F}","page":"Seminar 4","title":"Properties of mathbfK and mathbfF","text":"using LinearAlgebra\nx = [1 0;0 1;0 -1; -1 0; 1 1; -1 -1]\nK = x'*x\n\ndisplay(K'-K)\ndisplay(rank(K))\n\ny = [1.1 0;0 1.0;0 -1; -1 0; 1 1; -1 -1]\n\nF = y'*x / K\n\ndisplay(F'-F)\ndisplay(rank(F))\n\nstrain = 0.5*(F'*F - I)\ndisplay(strain'-strain)\ndisplay(rank(strain))\n\n\n","category":"section"},{"location":"lecture/seminar_1/#Seminar-1:-Trusses-and-structure-of-matrices","page":"Seminar 1","title":"Seminar 1: Trusses and structure of matrices","text":"For a truss everything is a scalar. The norms are given for better illustration.\n\ni\n\npoint\n\nj\n\nneighbor\n\nxi = x_j-x_i\n\neta = u_j - u_i\n\nBond force\n\nf_ij = c_iomega_ij sfracxi+etaxi + eta = c_iomega_ij s\n\ns = fracxi + eta - xixi = fracetaxi\n\nrho ddotu_i = frac12sum_j (f_jiV_i-f_ijV_j)+b_i\n\npoint based is solved like this\n\ninfo: 2D and 3D\nthe bond force f_ij becomes mathbff_ij and is mathbff_ij=c_iomega_ij sfracboldsymbolxi + etaboldsymbolxi + eta\n\nMatrix based\n\nbeginbmatrix\nK_11  cdots  K_1j  0 0\nvdots  ddots  \nK_j1    K_jj \n0   \nvdots   ddots\n0  cdotsK_nn\nendbmatrixbeginbmatrixu_1vdotsu_ju_j+1vdots u_nendbmatrix = mathbfF_internal\n\nK_ij = -fraccxi_ij omega_ijV_j quad textfor  i ne jquad K_ii = -sum_j ne i K_ij i=1n quad textand quad j=i+1n_neighborsi+1\n\nmathbfF_internal\n\nis the force density in leftfracNm^3right\n\n1D [32] rightarrow c = frac2EAdelta^2 2D For FEM\n\nmathbfK=fracEALbeginbmatrix1-1-11endbmatrix\n\n\n\nTest the local model case. (Image: )\n\nAssumptions\n\ndelta = L n_neighborsi=1 omega_ij=1 V_i=V=const\n\nV=AL\n\ninfo: Volume\nMust be AL, because the sum of the neighborvolume must represent the whole volume of the neighborhood, which is AL.\n\nc=05frac2EAL^2\n\nK_11=-K_12=-05fraccxi V=-05fraccL V=-fracEAL^3AL=-fracEL^2\n\nmathbfK=fracEL^2beginbmatrix1-1-11endbmatrix\n\nbring it in local form of the stiffness matrix the forces and not the force densities the stiffness has to be multiplied by V.\n\n^forcesK_11=-^forcesK_12=-fracEL^2AL=fracEAL\n\nmathbfK=fracEALbeginbmatrix1-1-11endbmatrix\n\n","category":"section"},{"location":"lecture/seminar_1/#Analysis-of-matrix-behavior","page":"Seminar 1","title":"Analysis of matrix behavior","text":"using LinearAlgebra\nE = 1\nV = 1\nL = 1\nnp = 4\nnn = np-1\ndelta = 1\nomega=ones(np, np)\n##\nc=zeros(np)\nc .= 2*E/delta^2\n#c[4]=1.5 .*c[4]\nK=zeros(np,np)\nfor iID in 1:np\n  for jID in -nn:nn\n    if jID != 0 && iID + jID > 0 && iID + jID < np + 1\n      xi = L*abs(jID)\n      K[iID, iID + jID] -= 0.5 * c[iID] / xi * V * omega[iID, iID + jID]\n      K[iID, iID]      +=  0.5 *c[iID] / xi * V * omega[iID, iID + jID]\n    end\n  end\nend\neigvals(K)\ndisplay(K)\nrank(K)\neigvals(K)\ndet(K)\n\n## Damage\n\nomega[1,2] = 0\n\nK=zeros(np,np)\nfor iID in 1:np\n  for jID in -nn:nn\n    if jID != 0 && iID + jID > 0 && iID + jID < np + 1\n      xi = L*abs(jID)\n      K[iID, iID + jID] -= 0.5 * c[iID] / xi * V * omega[iID, iID + jID]\n      K[iID, iID]      +=  0.5 *c[iID] / xi * V * omega[iID, iID + jID]\n    end\n  end\nend\n\ndisplay(K)\n","category":"section"},{"location":"lecture/seminar_1/#Perilab","page":"Seminar 1","title":"Perilab","text":"","category":"section"},{"location":"lecture/seminar_1/#Mesh","page":"Seminar 1","title":"Mesh","text":"header: x y block_id volume\n0 0 1 1\n1 0 1 1\n2 0 1 1\n3 0 1 1\n4 0 1 1","category":"section"},{"location":"lecture/seminar_1/#Yaml","page":"Seminar 1","title":"Yaml","text":"PeriLab:\n  Discretization:\n    Node Sets:\n      Node Set 1: 1\n      Node Set 2: 5\n    Type: \"Text File\"\n    Input Mesh File: \"truss.txt\"\n  Models:\n    Material Models:\n      Test:\n        Material Model: \"Bond-based Elastic\"\n        Symmetry: \"isotropic plane stress\"\n        Young's Modulus: 7000\n        Poisson's Ratio: 0.3\n  Blocks:\n    block_1:\n      Block ID: 1\n      Material Model: \"Test\"\n      Density: 2e-9\n      Horizon: 2\n  Boundary Conditions:\n    BC_1:\n      Variable: \"Displacements\"\n      Node Set: \"Node Set 1\"\n      Coordinate: \"x\"\n      Value: \"100*t\"\n      Type: Dirichlet\n    BC_2:\n      Variable: \"Displacements\"\n      Coordinate: \"x\"\n      Node Set: \"Node Set 2\"\n      Value: \"0.1*t\"\n      Type: Dirichlet\n  Solver:\n    Material Models: True\n    Initial Time: 0.0\n    Final Time: 1.0\n    Number of Steps: 20\n    Static:\n      Show solver iteration: true\n      Residual tolerance: 1e-7\n      Solution tolerance: 1e-8\n      Residual scaling: 7000\n      m: 550\n      Maximum number of iterations: 100\n  Outputs:\n    Output1:\n      Output Filename: \"truss\"\n      Output File Type: Exodus\n      Number of Output Steps: 20\n      Output Variables:\n        Displacements: True\n        Number of Neighbors: True\n        Forces: True\n\n","category":"section"},{"location":"man/models/overview/#Models","page":"Overview","title":"Models","text":"mindmap\n  root((Models))\n    Material Models\n      Bond Based\n        Bond-based Elastic\n        Unified Bond-based Elastic\n      Ordinary\n        PD Solid Elastic\n        PD Solid Plastic\n      Correspondence\n        Correspondence Elastic\n        Correspondence Plastic\n        Bond-associated (optional)\n    Damage Models\n      Critical Stretch\n      Critical Energy\n    Thermal Models\n      Thermal Expansion\n      Thermal Flow\n      Heat Transfer\n    Additive Models\n        Simple\n\n","category":"section"},{"location":"theory/theory_correspondence/#Non-ordinary-state-based-Peridynamics","page":"Non-Ordinary state-based","title":"Non-ordinary state based Peridynamics","text":"","category":"section"},{"location":"theory/theory_correspondence/#Correspondence-Peridynamics","page":"Non-Ordinary state-based","title":"Correspondence Peridynamics","text":"The correspondence formulation is a non-ordinary state-based formulation provided by [14]. It has the goal to apply classical models to Peridynamics.\n\nThe non-local deformation gradient is defined as\n\nmathbfF=int_mathcalHunderlineomegalangle boldsymbolxirangleunderlinemathbfYlangle boldsymbolxirangleotimesunderlinemathbfXlangle boldsymbolxirangle dV cdot mathbfK^-1\n\nwith the positive definite shape tensor as\n\nmathbfK=int_mathcalHunderlineomegalangle boldsymbolxirangleunderlinemathbfXlangle boldsymbolxirangleotimesunderlinemathbfXlangle boldsymbolxirangle dV\n\ninfo: Positive definiteness in numerics\nIn numerical applications if bonds break the shape tensor is positive semi definite. detmathbfK=0 can occur and the inversion of the shape tensor won't work.\n\nBased on this definition strain measures can be created to calculate the Cauchy stresses\n\nboldsymbolsigma = f(mathbfF t T )\n\nTo get the force densities the First-Piola Kirchhoff stress tensor has to be calculated by\n\nmathbfP = textdet(mathbfF)boldsymbolsigmamathbfF^-T\n\nand finaly the force density vector can be determined as\n\nunderlinemathbfT = underlineomegalangle boldsymbolxiranglemathbfPmathbfK^-1mathbfxi\n\nThe 2D plane strain or plane stress models are represented in the Cauchy stresses by assuming that the strain in the third direction are zero or the stresses.","category":"section"},{"location":"theory/theory_correspondence/#Zero-energy-modes","page":"Non-Ordinary state-based","title":"Zero-energy modes","text":"For correspondence models, the so called zero-energy modes could occur [15]. These modes are non-physical and lead to unstable or unreasonable solutions. Several stabilization methods were published to overcome this problem [16], [17], [18], [19],[20],[21].\n\nA promising approach implemented as global control in PeriLab was published by Wan et al. in 2019 [22]. Instead of a bond-based stabilization method proposed by Silling [23] Wan et al. developed a state-based stabilization method. As positive side effect this method stabilizes the solution for anisotropic material as well. The corrected force density state underlinemathbfT^C with suppression of the zero-energy mode is:\n\nunderlinemathbfT^C=underlinemathbfT+underlinemathbfT^S\n\nFollowing Wan et al. \\cite{WanJ2019} the suppression force density state underlinemathbfT^S is:\n\nunderlinemathbfT^Slangle boldsymbolxirangle = underlineomegalangleboldsymbolxiranglemathbfC_1underlinemathbfz\n\nwith underlinemathbfz as the non-uniform deformation state\n\nunderlinemathbfzlangle boldsymbolxirangle= underlinemathbfYlangleboldsymbolxi rangle-mathbfFboldsymbolxi\n\ncaused by the zero-energy mode. If the approximated non-local deformation gradient mathbfF exactly maps each undeformed bond to the deformed configuration no zero-energy mode occur. In that case the non-uniform deformation state is zero and the corrected force density state underlinemathbfT^C is equal to the force density state underlinemathbfT. The second order tensor mathbfC_1 is given as\n\nmathbfC_1=mathbfCcdotcdotmathbfK^-1\n\nutilizing the elasticity tensor.","category":"section"},{"location":"theory/theory_correspondence/#Bond-associated-correspondence-Peridynamics","page":"Non-Ordinary state-based","title":"Bond-associated correspondence Peridynamics","text":"","category":"section"},{"location":"theory/theory_correspondence/#Matrix-based-approach","page":"Non-Ordinary state-based","title":"Matrix based approach","text":"info: Redefinition of shape tensor\nFor the derivation the shape tensor is defined as mathbfD.\n\nIn the discretized form, the shape tensor for material point i is computed as the weighted sum over all neighbors: mathbfD_i = sum_j in mathcalH_i underlineomega_ij V_j underlinemathbfX_ij otimes underlinemathbfX_ij where underlineomega_ij is the influence function, V_j is the volume of material point j, and underlinemathbfX_ij = mathbfx_j - mathbfx_i is the undeformed bond vector state.\n\nThe deformation gradient tensor for material point i is calculated using the discretized correspondence relation:\n\nmathbfF_i = mathbfI + left sum_j in mathcalH_i underlineomega_ij V_j underlinemathbfU_ij otimes underlinemathbfX_ij right mathbfD_i^-1\n\nwhere mathbfI is the identity tensor and underlinemathbfU_ij = mathbfu_j - mathbfu_i is the displacement vector state between material points i and j.\n\nUnder the assumption of small deformations, the linearized strain tensor is computed from the symmetric part of the displacement gradient:\n\nboldsymbolvarepsilon_i = frac12(mathbfF_i + mathbfF_i^T) - mathbfI\n\nSubstituting leads to:\n\nboldsymbolvarepsilon_i = frac12 sum_k in mathcalH_i V_kunderlineomega_ik leftleft( underlinemathbfU_ik otimes underlinemathbfX_ikright) mathbfD_i^-1 + mathbfD_i^-T left(  underlinemathbfX_ik otimes underlinemathbfU_ikright)right\n\nTo facilitate the matrix formulation, a strain-displacement operator is introduced. This operator relates the displacement field to the strain tensor through linear relationships.\n\nTwo auxiliary vectors are defined for each bond ik:\n\nmathbfB_1ik = underlinemathbfX_ik^T mathbfD_i^-1\n\nand\n\nmathbfB_2ik = mathbfD_i^-T underlinemathbfX_ik\n\nThe strain-displacement operator mathbfB_ik is constructed as a third-order tensor with components:\n\nB_ikmnp = frac12left(delta_mp B_1ikn + delta_np B_2ikmright)\n\nwhere delta_ij is the Kronecker delta, and mnp are spatial indices. This tensor formulation allows the strain computation to be expressed compactly in index notation:\n\nvarepsilon_imn = sum_k in mathcalH_i V_kunderlineomega_ik B_ikmno underlineU_iko = sum_k in mathcalH_i V_kunderlineomega_ik B_ikmno(U_ko-U_io)\n\nThe bond force density vector is computed using the linearized constitutive relation:\n\nbeginaligned\nunderlinemathbfT_ij = underlineomega_ijboldsymbolsigma_i mathbfD_i^-1underlinemathbfX_ij  \n= underlineomega_ijleft(mathbfC_iboldsymbolvarepsilon_iright) mathbfD_i^-1underlinemathbfX_ij  \n =  underlineomega_ijunderlinemathbfX_ij^T mathbfD_i^-T (mathbfC_iboldsymbolvarepsilon_i)^T\n =  underlineomega_ijunderlinemathbfX_ij^T mathbfD^-1_i (mathbfC_iboldsymbolvarepsilon_i)\nendaligned\n\nThe stiffness matrix components are derived separating the displacement vector from the strain tensor. To do so, the tensor contraction mathbfC_i  mathbfB_ik in index notation becomes:\n\nmathbfC  mathbfB_ik_mnq = C_imnop B_ikopq\n\nCombining the strain-displacement relationship with the force calculation from the stiffness matrix components are:\n\nmathbfK_ij = -underlineomega_ij V_j V_k underlineomega_ik mathbfD_i^-1 underlinemathbfX_ij mathbfC  mathbfB_ik\n\nwith the explicit index notation:\n\nK_ijmo = -underlineomega_ij V_j V_k underlineomega_ik sum_np mathbfC  mathbfB_ik_mno D_i^-1_np X_ijp","category":"section"},{"location":"theory/theory_correspondence/#Zero-energy-mode-compensation","page":"Non-Ordinary state-based","title":"Zero energy mode compensation","text":"The global control [22] is introcuded in matrix form.\n\nThe corrected force density state underlinemathbfT^C combines the original correspondence force with a stabilization term:\n\nunderlinemathbfT^C=underlinemathbfT+underlinemathbfT^S\n\nwhere underlinemathbfT is the original correspondence force density state and underlinemathbfT^S is the suppression force density state. Following Wan et al. [22], the suppression force density state is defined as:\n\nunderlinemathbfT^Slangle boldsymbolxirangle =underlineomegalangleboldsymbolxiranglemathbfZunderlinemathbfz\n\nwhere mathbfZ is the zero-energy stiffness tensor and underlinemathbfz is the non-uniform deformation state.\n\nThe non-uniform deformation state underlinemathbfz quantifies the deviation between the actual deformed configuration and the configuration predicted by the correspondence deformation gradient:\n\nunderlinemathbfzlangle boldsymbolxirangle=underlinemathbfYlangleboldsymbolxi rangle-mathbfFboldsymbolxi\n\nThe second-order zero-energy stiffness tensor mathbfZ is constructed using the elasticity tensor from the constitutive relation:\n\nmathbfZ=mathbfCmathbfD^-1\n\nwhere mathbfC is the elasticity tensor and mathbfD^-1 is the inverse shape tensor.\n\nFor the discrete implementation, the non-uniform deformation state for bond ij is expressed in terms of displacement differences:\n\nbeginalignedunderlinemathbfz_ij = underlinemathbfY_ij-mathbfFunderlinemathbfX_ij= underlinemathbfX_ij+underlinemathbfU_ij-mathbfFunderlinemathbfX_ij= underlinemathbfU_ij - left( sum_k in mathcalH_i underlineomega_ik V_k underlinemathbfU_ik otimes underlinemathbfX_ikright) mathbfD_i^-1underlinemathbfX_ij= underlinemathbfU_ij - sum_k in mathcalH_i underlineomega_ik V_k underlinemathbfU_ik (underlinemathbfX_ik^T mathbfD_i^-1underlinemathbfX_ij)=underlinemathbfU_ijleftmathbfI - sum_k in mathcalH_i underlineomega_ik V_k (underlinemathbfX_ik^T mathbfD_i^-1underlinemathbfX_ij)rightendaligned\n\nbeginalignedunderlinemathbfT^S_ij = mathbfZ_iunderlinemathbfU_ijleftmathbfI- sum_k in mathcalH_i underlineomega_ik V_k (underlinemathbfX_ik otimes mathbfD_i^-1underlinemathbfX_ij)right=(mathbfC_imathbfD_i^-1)underlinemathbfU_ijleftmathbfI-sum_k in mathcalH_i underlineomega_ik V_k (underlinemathbfX_ik^T mathbfD_i^-1underlinemathbfX_ij)rightendaligned\n\nThe stabilization terms can be directly incorporated into the matrix formulation. The additional stiffness matrix components arising from the zero-energy mode compensation are:\n\nmathbfK^S_ij  = -leftmathbfI - sum_k in mathcalH_i underlineomega_ik V_k (underlinemathbfX_ik^T mathbfD_i^-1underlinemathbfX_ij)right(mathbfCmathbfD_i^-1)V_i\n\nThe corresponding transpose terms are:\n\nmathbfK^S_ji =  -leftmathbfI - sum_k in mathcalH_i underlineomega_ik V_k (underlinemathbfX_ik^T mathbfD_i^-1underlinemathbfX_ij)right(mathbfCmathbfD_i^-1) V_j\n\nThe diagonal terms ensure equilibrium by summing all off-diagonal contributions:\n\nmathbfK^S_ii = -sum_substackell in mathcalH_i  ell neq i mathbfK^S_iell\n\nThe advantage of this stabilization approach lies in its seamless integration with the matrix-based formulation. The stabilization stiffness terms mathbfK^S are simply added to the correspondence stiffness matrix mathbfK, yielding a stabilized system:\n\n(mathbfK + mathbfK^S)mathbfu = mathbfF_ext\n\n","category":"section"},{"location":"lib/glossar/#Glossar","page":"Glossar","title":"Glossar","text":"","category":"section"},{"location":"lib/glossar/#Abbreviations","page":"Glossar","title":"Abbreviations","text":"Abbreviation Full\ndof degree of freedom\nFEM Finite Element Method\nPD Peridynamics","category":"section"},{"location":"lib/glossar/#Variables","page":"Glossar","title":"Variables","text":"Parameter Name\nmathcalH Neighborhood [-]\nV Volume leftm^3right\nmathbfx Position of point leftmright\nmathbfx Position of neighbor leftmright\nt Time leftsright\nmathbfb Body force densities leftNm^3right\nmathbfu Displacements leftmright\nddotmathbfu Accelerations leftms^2right\nunderlinemathbfT Force density state leftNm^6right\nrho Mass density leftkgm^3right\ntau Temperature leftKright\nDelta Delta of a variable left-right\nmathbfH Heat flux leftWm^2right\nmathbfF Force density leftNm^3right\n\n","category":"section"},{"location":"lib/io_functions/#IO-Functions","page":"IO","title":"IO - Functions","text":"","category":"section"},{"location":"lib/io_functions/#Index","page":"IO","title":"Index","text":"Pages = [\"io_functions.md\"]","category":"section"},{"location":"lib/io_functions/#IO","page":"IO","title":"IO","text":"","category":"section"},{"location":"lib/io_functions/#Parameter_Handling","page":"IO","title":"Parameter_Handling","text":"","category":"section"},{"location":"lib/io_functions/#PeriLab.IO._init_overlap_map_-Tuple{Any}","page":"IO","title":"PeriLab.IO._init_overlap_map_","text":"_init_overlap_map_(size)\n\nInitialize the overlap map.\n\nArguments\n\nsize::Int64: The number of ranks.\n\nReturns\n\noverlap_map::Dict{Int64,Dict{Int64,Dict{String,Vector{Int64}}}}: The overlap map.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.apply_bond_filters-Tuple{Vector{Vector{Int64}}, DataFrames.DataFrame, Dict, Int64}","page":"IO","title":"PeriLab.IO.apply_bond_filters","text":"apply_bond_filters(nlist::BondScalarState{Int64}, mesh::DataFrame, params::Dict, dof::Int64)\n\nApply the bond filters to the neighborhood list.\n\nArguments\n\nnlist::BondScalarState{Int64}: The neighborhood list.\nmesh::DataFrame: The mesh.\nparams::Dict: The parameters.\ndof::Int64: The degrees of freedom.\n\nReturns\n\nnlist::BondScalarState{Int64}: The filtered neighborhood list.\nnlist_filtered_ids::BondScalarState{Int64}: The filtered neighborhood list.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.area_of_polygon-Tuple{Any}","page":"IO","title":"PeriLab.IO.area_of_polygon","text":"area_of_polygon(vertices)\n\nCalculate the area of a polygon.\n\nArguments\n\nvertices: The vertices of the polygon.\n\nReturns\n\narea: The area of the polygon.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.bond_intersect_infinite_plane-NTuple{4, Vector{Float64}}","page":"IO","title":"PeriLab.IO.bond_intersect_infinite_plane","text":"bond_intersect_infinite_plane(p0::Vector{Float64}, p1::Vector{Float64}, lower_left_corner::Vector{Float64}, normal::Vector{Float64})\n\nCheck if a line segment intersects an infinite plane.\n\nArguments\n\np0::Vector{Float64}: The start point of the line segment.\np1::Vector{Float64}: The end point of the line segment.\nlower_left_corner::Vector{Float64}: The lower left corner of the plane.\nnormal::Vector{Float64}: The normal of the plane.\n\nReturns\n\nBool: True if the line segment intersects the plane, False otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.bond_intersect_rectangle_plane-Tuple{Union{Vector{Float64}, Vector{Int64}}, Union{Vector{Float64}, Vector{Int64}}, Union{Vector{Float64}, Vector{Int64}}, Union{Vector{Float64}, Vector{Int64}}, Real, Real}","page":"IO","title":"PeriLab.IO.bond_intersect_rectangle_plane","text":"bond_intersect_rectangle_plane(x::Vector{Float64}, lower_left_corner::Vector{Float64}, bottom_unit_vector::Vector{Float64}, normal::Vector{Float64}, side_length::Float64, bottom_length::Float64)\n\nCheck if a bond intersects a rectangle plane.\n\nArguments\n\nx::Vector{Float64}: The point.\nlower_left_corner::Vector{Float64}: The lower left corner of the rectangle.\nbottom_unit_vector::Vector{Float64}: The unit vector along the bottom of the rectangle.\nnormal::Vector{Float64}: The normal of the plane.\nside_length::Float64: The side length of the rectangle.\nbottom_length::Float64: The bottom length of the rectangle.\n\nReturns\n\nBool: True if the point is inside the rectangle, False otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.bond_intersects_disc-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64}","page":"IO","title":"PeriLab.IO.bond_intersects_disc","text":"bond_intersects_disc(p0::Vector{Float64}, p1::Vector{Float64}, center::Vector{Float64}, normal::Vector{Float64}, radius::Float64)\n\nCheck if a line segment intersects a disk.\n\nArguments\n\np0::Vector{Float64}: The start point of the line segment.\np1::Vector{Float64}: The end point of the line segment.\ncenter::Vector{Float64}: The center of the disk.\nnormal::Vector{Float64}: The normal of the plane.\nradius::Float64: The radius of the disk.\n\nReturns\n\nBool: True if the line segment intersects the disk, False otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.calculate_block-Tuple{String, Union{Int64, Vector{Int64}}, String, Int64}","page":"IO","title":"PeriLab.IO.calculate_block","text":"calculate_block( field_key::String, dof::Int64, calculation_type::String, block::Int64)\n\nCalculate the global value of a field for a given block.\n\nArguments\n\nfield_key::String: Field key.\ndof::Union{Int64,Vector{Int64}}: Degree of freedom\ncalculation_type::String: Calculation type.\nblock::Int64: Block number.\n\nReturns\n\nvalue::Float64: Global value.\nnnodes::Int64: Number of nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.calculate_nodelist-Tuple{String, Union{Int64, Vector{Int64}}, String, Union{Int64, Vector{Int64}}}","page":"IO","title":"PeriLab.IO.calculate_nodelist","text":"calculate_nodelist(field_key::String, dof::Union{Int64,Vector{Int64}}, calculation_type::String, local_nodes::Vector{Int64})\n\nCalculate the global value of a field for a given set of nodes.\n\nArguments\n\nfield_key::String: Field key.\ndof::Union{Int64,Vector{Int64}}: Degree of freedom\ncalculation_type::String: Calculation type.\nlocal_nodes::Vector{Int64}: Node set.\n\nReturns\n\nvalue::Vector: Global value.\nnnodes::Int64: Number of nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.calculate_volume-Tuple{String, Vector{Vector{Float64}}}","page":"IO","title":"PeriLab.IO.calculate_volume","text":"calculate_volume(element_type::String, vertices::Vector{Vector{Float64}})\n\nCalculate the volume of a element.\n\nArguments\n\nelement_type: The element type of the element.\nvertices: The vertices of the element.\n\nReturns\n\nvolume: The volume of the element.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.check_for_duplicate_in_dataframe-Tuple{DataFrames.DataFrame}","page":"IO","title":"PeriLab.IO.check_for_duplicate_in_dataframe","text":"check_for_duplicate_in_dataframe(mesh::DataFrame)\n\ncheck duplicated entries and throws an error if one is there. If not everything is ok.\n\nArguments\n\nmesh::DataFrame: The input mesh data represented as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.check_mesh_elements-Tuple{DataFrames.DataFrame, Int64}","page":"IO","title":"PeriLab.IO.check_mesh_elements","text":"check_mesh_elements(mesh, dof)\n\nProcess and analyze mesh data to create an dictionary containing information about mesh elements for further processing.\n\nArguments\n\nmesh::DataFrame: The input mesh data represented as a DataFrame.\ndof::Int64: The degrees of freedom (DOF) for the mesh elements.\n\nReturns\n\nA dictionary containing information about mesh elements, which can be used for further processing or uploading.\n\nExample\n\n`julia meshdata = DataFrame(x1 = [1.0, 2.0, 3.0], x2 = [4.0, 5.0, 6.0], volume = [10.0, 20.0, 30.0]) dof = 3 result = checkmeshelements(meshdata, dof)\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.check_types_in_dataframe-Tuple{DataFrames.DataFrame}","page":"IO","title":"PeriLab.IO.check_types_in_dataframe","text":"check_types_in_dataframe(mesh::DataFrame)\n\ncheck if block_id in mesh contains only int.\n\nArguments\n\nmesh::DataFrame: The input mesh data represented as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.clearNP1-Tuple{String}","page":"IO","title":"PeriLab.IO.clearNP1","text":"clearNP1(name::String)\n\nClears the NP1 from the name\n\nArguments\n\nname::String: The name\n\nReturns\n\nname::String: The cleared name\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.close_result_file-Tuple{Dict}","page":"IO","title":"PeriLab.IO.close_result_file","text":"close_result_file(result_file::Dict)\n\nCloses the result file\n\nArguments\n\nresult_file::Dict: The result file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.close_result_files-Tuple{Vector{Dict}, Dict{Int64, Dict}}","page":"IO","title":"PeriLab.IO.close_result_files","text":"close_result_files(result_files::Vector{Dict}, outputs::Dict{Int64,Dict{}})\n\nCloses the result files if the flush_file flag is not set\n\nArguments\n\nresult_files::Vector{Dict}: The result files\noutputs::Dict{Int64,Dict{}}: The output settings\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.close_result_files-Tuple{Vector{Dict}}","page":"IO","title":"PeriLab.IO.close_result_files","text":"close_result_files(result_files::Vector{Dict})\n\nCloses the result files\n\nArguments\n\nresult_files::Vector{Dict}: The result files\n\nReturns\n\ntrue: File is closed\nfalse: File was already closed\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_and_distribute_bond_norm-Tuple{MPI.Comm, Vector{Vector{Int64}}, Vector{Vector{Int64}}, Vector{Any}, Int64}","page":"IO","title":"PeriLab.IO.create_and_distribute_bond_norm","text":"create_and_distribute_bond_norm(comm::MPI.Comm, nlist_filtered_ids::BondScalarState{Int64}, distribution::Vector{Int64}, bond_norm::Vector{Float64}, dof::Int64)\n\nCreate and distribute the bond norm\n\nArguments\n\ncomm::MPI.Comm: MPI communicator\nnlist_filtered_ids::BondScalarState{Int64}: The filtered neighborhood list\ndistribution::Vector{Int64}: The distribution\nbond_norm::Vector{Float64}: The bond norm\ndof::Int64: The degree of freedom\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_distribution-Tuple{Int64, Int64}","page":"IO","title":"PeriLab.IO.create_distribution","text":"create_distribution(nnodes::Int64, size::Int64)\n\nCalculate the initial size of each chunk for a nearly equal number of nodes vs. cores this algorithm might lead to the problem, that the last core is not equally loaded\n\nArguments\n\nnnodes::Int64: The number of nodes.\nsize::Int64: The number of cores.\n\nReturns\n\ndistribution::Array{Int64,1}: The distribution of the nodes.\npoint_to_core::Array{Int64,1}: The number of nodes in each rank.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_distribution_neighbor_based-Tuple{Int64, Vector{Vector{Int64}}, Int64}","page":"IO","title":"PeriLab.IO.create_distribution_neighbor_based","text":"create_distribution_neighbor_based(nnodes::Int64,nlist::BondScalarState{Int64}, size::Int64)\n\nCalculate the initial size of each chunk for a nearly equal number of nodes vs. cores this algorithm might lead to the problem, that the last core is not equally loaded\n\nArguments\n\nnnodes::Int64: The number of nodes.\nnlist::BondScalarState{Int64}: The neighborhood list.\nsize::Int64: The number of cores.\n\nReturns\n\ndistribution::Array{Int64,1}: The distribution of the nodes.\npoint_to_core::Array{Int64,1}: The number of nodes in each rank.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_distribution_node_based-Tuple{Int64, Vector{Vector{Int64}}, Int64}","page":"IO","title":"PeriLab.IO.create_distribution_node_based","text":"create_distribution_node_based(nnodes::Int64,nlist::BondScalarState{Int64}, size::Int64)\n\nCalculate the initial size of each chunk for a nearly equal number of nodes vs. cores this algorithm might lead to the problem, that the last core is not equally loaded\n\nArguments\n\nnnodes::Int64: The number of nodes.\nnlist::BondScalarState{Int64}: The neighborhood list.\nsize::Int64: The number of cores.\n\nReturns\n\ndistribution::Array{Int64,1}: The distribution of the nodes.\npoint_to_core::Array{Int64,1}: The number of nodes in each rank.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_global_to_local_mapping-Tuple{Any}","page":"IO","title":"PeriLab.IO.create_global_to_local_mapping","text":"glob_to_loc(distribution)\n\nGet the global to local mapping\n\nArguments\n\ndistribution: The distribution\n\nReturns\n\ncreate_global_to_local_mapping: The global to local mapping\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_neighborhoodlist-Tuple{DataFrames.DataFrame, Dict, Int64}","page":"IO","title":"PeriLab.IO.create_neighborhoodlist","text":"create_neighborhoodlist(mesh::DataFrame, params::Dict, dof::Int64)\n\nCreate the neighborhood list of the mesh elements.\n\nArguments\n\nmesh::DataFrame: The input mesh data represented as a DataFrame.\nparams::Dict: The input parameters.\ndof::Int64: The degrees of freedom (DOF) for the mesh elements.\n\nReturns\n\nnlist::Array{Array{Int64,1},1}: The neighborhood list of the mesh elements.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_overlap_map-Tuple{Vector{Vector{Int64}}, Vector{Int64}, Int64}","page":"IO","title":"PeriLab.IO.create_overlap_map","text":"create_overlap_map(distribution, ptc, size)\n\nCreate the overlap map.\n\nArguments\n\ndistribution::Array{Int64,1}: The distribution of the nodes.\nptc::Array{Int64,1}: The number of nodes in each rank.\nsize::Int64: The number of ranks.\n\nReturns\n\noverlap_map::Dict{Int64,Dict{Int64,Dict{String,Vector{Int64}}}}: The overlap map.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.create_result_file","page":"IO","title":"PeriLab.IO.create_result_file","text":"create_result_file(filename::Union{AbstractString,String}, num_nodes::Int64, num_dim::Int64, num_elem_blks::Int64, num_node_sets::Int64)\n\nCreates a exodus file for the results\n\nArguments\n\nfilename::Union{AbstractString,String}: The name of the file to create\nnum_nodes::Int64: The number of nodes\nnum_dim::Int64: The number of dimensions\nnum_elem_blks::Int64: The number of element blocks\nnum_node_sets::Int64: The number of node sets\n\nReturns\n\nresult_file::Dict{String,Any}: A dictionary containing the filename and the exodus file\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.IO.create_result_file-Tuple{String, Dict}","page":"IO","title":"PeriLab.IO.create_result_file","text":"create_result_file(filename::String, outputs::Dict)\n\nCreates a csv file for the results\n\nArguments\n\nfilename::String: The name of the file to create\noutputs::Dict: The outputs dictionary\n\nReturns\n\nDict: The result file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.csv_reader-Tuple{String}","page":"IO","title":"PeriLab.IO.csv_reader","text":"csv_reader(filename::String)\n\nRead csv and return it as a DataFrame.\n\nArguments\n\nfilename::String: The path to the mesh file.\n\nReturns\n\ncsvData::DataFrame: The csv data a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.define_nsets-Tuple{Dict{String, Vector{Int64}}}","page":"IO","title":"PeriLab.IO.define_nsets","text":"define_nsets(nsets::Dict{String,Vector{Int64}})\n\nDefines the node sets\n\nArguments\n\nnsets::Dict{String,Vector{Int64}}: Node sets read from files\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.delete_files-Tuple{Vector{Dict}, String}","page":"IO","title":"PeriLab.IO.delete_files","text":"delete_files(result_files::Vector{Dict})\n\nDeletes the result files\n\nArguments\n\nresult_files: The result files\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.disk_filter-Tuple{Int64, Matrix{Float64}, Dict, Vector{Vector{Int64}}, Int64}","page":"IO","title":"PeriLab.IO.disk_filter","text":"disk_filter(nnodes::Int64, data::Matrix{Float64}, filter::Dict, nlist::BondScalarState{Int64}, dof::Int64)\n\nApply the disk filter to the neighborhood list.\n\nArguments\n\nnnodes::Int64: The number of nodes.\ndata::Matrix{Float64}: The data.\nfilter::Dict: The filter.\nnlist::BondScalarState{Int64}: The neighborhood list.\ndof::Int64: The degrees of freedom.\n\nReturns\n\nfilter_flag::Vector{Bool}: The filter flag.\nnormal::Vector{Float64}: The normal vector of the disk.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.distribute_neighborhoodlist_to_cores-Tuple{MPI.Comm, Vector{Vector{Int64}}, Vector{Vector{Int64}}, Bool}","page":"IO","title":"PeriLab.IO.distribute_neighborhoodlist_to_cores","text":"distribute_neighborhoodlist_to_cores(comm::MPI.Comm, nlist, distribution)\n\nDistributes the neighborhood list to the cores.\n\nArguments\n\ncomm::MPI.Comm: MPI communicator\nnlist: neighborhood list\ndistribution Array{Int64}: global nodes distribution at cores\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.distribution_to_cores-Tuple{MPI.Comm, DataFrames.DataFrame, Vector{Vector{Int64}}, Int64}","page":"IO","title":"PeriLab.IO.distribution_to_cores","text":"distribution_to_cores(comm::MPI.Comm, mesh, distribution, dof::Int64)\n\nDistributes the mesh data to the cores\n\nArguments\n\ncomm::MPI.Comm: MPI communicator\nmesh: Mesh\ndistribution Array{Int64}: global nodes distribution at cores\ndof::Int64: Degree of freedom\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.element_distribution-Tuple{Vector{Vector{Int64}}, Vector{Int64}, Int64}","page":"IO","title":"PeriLab.IO.element_distribution","text":"element_distribution(topology::Vector{Vector{Int64}}, ptc::Vector{Int64}, size::Int64)\n\nCreate the distribution of the finite elements. Is needed to avoid multiple element calls. Each element should run only one time at the cores.\n\nArguments\n\ntopology::Vector{Vector{Int64}}: The topology list of the mesh elements.\nnlist::BondScalarState{Int64}: The neighborhood list of the mesh elements.\nsize::Int64: The number of ranks.\n\nReturns\n\ndistribution::Vector{Vector{Int64}}: The distribution of the nodes.\netc::Vector{Int64}: The number of nodes in each rank.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.extrude-Tuple{Any, Any}","page":"IO","title":"PeriLab.IO.extrude","text":"extrude(cmds, dataobject)\n\nExample extrusion callback for G1 which calculates total length of filament extruded.\n\nThe extruded filament length is obtained by watching the E axis movement in the g-code file.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.extrude_surface_mesh-Tuple{DataFrames.DataFrame, Dict}","page":"IO","title":"PeriLab.IO.extrude_surface_mesh","text":"extrude_surface_mesh(mesh::DataFrame)\n\nextrude the mesh at the surface of the block\n\nArguments\n\nmesh::DataFrame: The input mesh data represented as a DataFrame.\nparams::Dict: The input parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.find_global_core_value!-Union{Tuple{T}, Tuple{T, String, Int64}} where T<:Union{Float64, Int64}","page":"IO","title":"PeriLab.IO.find_global_core_value!","text":"find_global_core_value!(global_value::Union{Int64,Float64}, calculation_type::String, nnodes::Int64)\n\nFind global core value.\n\nArguments\n\nglobal_value::Union{Int64,Float64}: The global value\ncalculation_type::String: The calculation type\nnnodes::Int64: The number of nodes\n\nReturns\n\nglobal_value::Union{Int64,Float64}: The global value\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_block_nodes-Tuple{AbstractVector{Int64}, Int64}","page":"IO","title":"PeriLab.IO.get_block_nodes","text":"get_block_nodes(block_Id::AbstractVector{Int64}, block::Int64)\n\nReturns the nodes of a block\n\nArguments\n\nblock_Id::AbstractVector{Int64}: The block Id\nblock::Int64: The block\n\nReturns\n\nnodes::Vector{Int64}: The nodes of the block\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_bond_geometry-Tuple{}","page":"IO","title":"PeriLab.IO.get_bond_geometry","text":"get_bond_geometry()\n\nGets the bond geometry\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_file_size-Tuple{Vector{Dict}}","page":"IO","title":"PeriLab.IO.get_file_size","text":"get_file_size(result_files::Vector{Dict})\n\nGets the file size of the result files\n\nArguments\n\nresult_files: The result files\n\nReturns\n\ntotal_file_size: The total file size\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_global_values-Tuple{Dict}","page":"IO","title":"PeriLab.IO.get_global_values","text":"get_global_values(output::Dict,)\n\nGet global values.\n\nArguments\n\noutput::Dict: The output\n\nReturns\n\nglobal_values::Vector: The global values\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_local_element_topology-Tuple{Vector{Vector{Int64}}, Vector{Int64}}","page":"IO","title":"PeriLab.IO.get_local_element_topology","text":"get_local_element_topology(topology::Vector{Vector{Int64}}, distribution::Vector{Int64})\n\nGet the local element topology\n\nArguments\n\ntopology::Vector{Vector{Int64}}: The topology\ndistribution::Vector{Int64}: The distribution\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_local_neighbors-Tuple{Any, Any}","page":"IO","title":"PeriLab.IO.get_local_neighbors","text":"get_local_neighbors(mapping, nlist_core)\n\nGets the local neighborhood list from the global neighborhood list\n\nArguments\n\nmapping: mapping function\nnlist_core: global neighborhood list\n\nReturns\n\nnlist_core: local neighborhood list\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_local_overlap_map-Tuple{Any, Vector{Vector{Int64}}, Int64}","page":"IO","title":"PeriLab.IO.get_local_overlap_map","text":"get_local_overlap_map()\n\nChanges entries in the overlap map from the global numbering to the local computer core one.\n\nArguments\n\noverlap_map::Dict{Int64, Dict{Int64, String}}: overlap map with global nodes.\ndistribution::Vector{Vector{Int64}}: global nodes distribution at cores, needed for the gobal to local mapping\nranks Array{Int64} : number of used computer cores\n\nReturns\n\noverlap_map::Dict{Int64, Dict{Int64, String}}: returns overlap map with local nodes.\n\nExample:\n\nget_local_overlap_map(overlap_map, distribution, ranks)  # returns local nodes\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_mpi_rank_string-Tuple{Int64, Int64}","page":"IO","title":"PeriLab.IO.get_mpi_rank_string","text":"get_mpi_rank_string(rank::Int64, max_rank::Int64)\n\nGet MPI rank string.\n\nArguments\n\nvalue::Int64: The rank\nmax_rank::Int64: The max rank\n\nReturns\n\nresult::String: The result\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_number_of_neighbornodes-Tuple{Vector{Vector{Int64}}, Bool}","page":"IO","title":"PeriLab.IO.get_number_of_neighbornodes","text":"get_number_of_neighbornodes(nlist::BondScalarState{Int64})\n\nGet the number of neighbors for each node.\n\nArguments\n\nnlist::BondScalarState{Int64}: The neighborhood list of the mesh elements.\n\nReturns\n\nlength_nlist::Vector{Int64}: The number of neighbors for each node.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_paraview_coordinates-Tuple{Int64, Int64}","page":"IO","title":"PeriLab.IO.get_paraview_coordinates","text":"get_paraview_coordinates(dof::Int64, refDof::Int64)\n\nReturns the paraview specific dof\n\nArguments\n\ndof::Int64: The degrees of freedom\nrefDof::Int64: The reference degrees of freedom\n\nReturns\n\nparaview_specifics::String: The paraview specific dof\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.get_results_mapping-Tuple{Dict, String}","page":"IO","title":"PeriLab.IO.get_results_mapping","text":"get_results_mapping(params::Dict, path::String)\n\nGets the results mapping\n\nArguments\n\nparams::Dict: The parameters\npath::String: The path\n\nReturns\n\noutput_mapping::Dict{Int64,Dict{}}: The results mapping\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.global_value_avg-Tuple{VecOrMat{Float64}, Union{Int64, Vector{Int64}}, AbstractVector{Int64}}","page":"IO","title":"PeriLab.IO.global_value_avg","text":"global_value_avg(field::Union{NodeScalarField{Float64},NodeVectorField{Float64}}, dof::Union{Int64,Vector{Int64}}, nodes::AbstractVector{Int64})\n\nCalculate the global average of a field for given nodes.\n\nArguments\n\nfield::Union{NodeScalarField{Float64},NodeVectorField{Float64}}: Field.\ndof::Union{Int64,Vector{Int64}}: Degree of freedom\nnodes::AbstractVector{Int64}: Nodes.\n\nReturns\n\nreturnValue::Vector: Global value.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.global_value_max-Tuple{VecOrMat{Float64}, Union{Int64, Vector{Int64}}, AbstractVector{Int64}}","page":"IO","title":"PeriLab.IO.global_value_max","text":"global_value_max(field::Union{NodeScalarField{Float64},NodeVectorField{Float64}}, dof::Union{Int64,Vector{Int64}}, nodes::AbstractVector{Int64})\n\nCalculate the global maximum of a field for given nodes.\n\nArguments\n\nfield::Union{NodeScalarField{Float64},NodeVectorField{Float64}}: Field.\ndof::Union{Int64,Vector{Int64}}: Degree of freedom\nnodes::AbstractVector{Int64}: Nodes.\n\nReturns\n\nreturnValue::Vector: Global value.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.global_value_min-Tuple{VecOrMat{Float64}, Union{Int64, Vector{Int64}}, AbstractVector{Int64}}","page":"IO","title":"PeriLab.IO.global_value_min","text":"global_value_min(field::Union{NodeScalarField{Float64},NodeVectorField{Float64}}, dof::Union{Int64,Vector{Int64}}, nodes::AbstractVector{Int64})\n\nCalculate the global minimum of a field for given nodes.\n\nArguments\n\nfield::Union{NodeScalarField{Float64},NodeVectorField{Float64}}: Field.\ndof::Union{Int64,Vector{Int64}}: Degree of freedom\nnodes::AbstractVector{Int64}: Nodes.\n\nReturns\n\nreturnValue::Vector: Global value.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.global_value_sum-Tuple{Union{Array{Float64, 3}, VecOrMat{Float64}}, Union{Int64, Vector{Int64}}, AbstractVector{Int64}}","page":"IO","title":"PeriLab.IO.global_value_sum","text":"global_value_sum(field::Union{NodeScalarField{Float64},NodeVectorField{Float64},NodeTensorField{Float64,3}}, dof::Union{Int64,Vector{Int64}}, nodes::AbstractVector{Int64})\n\nCalculate the global sum of a field for given nodes.\n\nArguments\n\nfield::Union{NodeScalarField{Float64},NodeVectorField{Float64},NodeTensorField{Float64,3}}: Field.\ndof::Union{Int64,Vector{Int64}: Degree of freedom\nnodes::AbstractVector{Int64}: Nodes.\n\nReturns\n\nreturnValue::Vector: Global value.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.hex8_volume-Tuple{Matrix{Float64}}","page":"IO","title":"PeriLab.IO.hex8_volume","text":"hex8volume(hexvertices)\n\nCalculate the volume of a hex.\n\nArguments\n\nhex_vertices: The vertices of the wedge.\n\nReturns\n\nvolume: The volume of the wedge.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.hex8_volume-Tuple{Vector{Vector{Float64}}}","page":"IO","title":"PeriLab.IO.hex8_volume","text":"hex8volume(hexvertices)\n\nCalculate the volume of a hex.\n\nArguments\n\nhex_vertices: The vertices of the wedge.\n\nReturns\n\nvolume: The volume of the wedge.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.init_data-Tuple{Dict, String, MPI.Comm}","page":"IO","title":"PeriLab.IO.init_data","text":"init_data(params::Dict, path::String, comm::MPI.Comm)\n\nInitializes the data for the mesh.\n\nArguments\n\nparams::Dict: The parameters for the simulation.\npath::String: The path to the mesh file.\ncomm::MPI.Comm: The MPI communicator.\n\nReturns\n\nparams::Dict: The parameters for the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.init_orientations-Tuple{}","page":"IO","title":"PeriLab.IO.init_orientations","text":"init_orientations()\n\nInitialize orientations.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.init_results_in_exodus","page":"IO","title":"PeriLab.IO.init_results_in_exodus","text":"init_results_in_exodus(exo::ExodusDatabase, output::Dict{}, coords::Union{Matrix{Int64},Matrix{Float64}}, block_Id::Vector{Int64}, block_list::Vector{String}, nsets::Dict{String,Vector{Int64}}, global_ids::Vector{Int64}, PERILAB_VERSION::String)\n\nInitializes the results in exodus\n\nArguments\n\nexo::ExodusDatabase: The exodus database\noutput::Dict{String,Any}: The output\ncoords::Union{Matrix{Int64},Matrix{Float64}}: The coordinates\nblock_Id::Vector{Int64}: The block Id\nblock_list::Vector{String}: The unique blocks\nnsets::Dict{String,Vector{Int64}}: The node sets\nglobal_ids::Vector{Int64}: The global ids\n\nReturns\n\nresult_file::Dict{String,Any}: The result file\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.IO.init_write_results-Tuple{Dict, String, String, String}","page":"IO","title":"PeriLab.IO.init_write_results","text":"init_write_results(params::Dict, output_dir::String, path::String, nsteps::Int64, PERILAB_VERSION::String)\n\nInitialize write results.\n\nArguments\n\nparams::Dict: The parameters\noutput_dir::String: The output directory.\npath::String: The path\nnsteps::Int64: The number of steps\n\nReturns\n\nresult_files::Array: The result files\noutputs::Dict: The outputs\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.initialize_data-Tuple{String, String, MPI.Comm}","page":"IO","title":"PeriLab.IO.initialize_data","text":"initialize_data(filename::String, filedirectory::String, comm::MPI.Comm)\n\nInitialize data.\n\nArguments\n\nfilename::String: The name of the input file.\nfiledirectory::String: The directory of the input file.\ncomm::MPI.Comm: The MPI communicator\n\nReturns\n\ndata::Dict: The data\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.load_and_evaluate_mesh-Tuple{Dict, String, Int64, Bool}","page":"IO","title":"PeriLab.IO.load_and_evaluate_mesh","text":"load_and_evaluate_mesh(params::Dict, path::String, ranksize::Int64)\n\nLoad and evaluate the mesh data.\n\nArguments\n\nparams::Dict: The input parameters.\npath::String: The path to the mesh file.\nranksize::Int64: The number of ranks.\n\nReturns\n\ndistribution::Array{Int64,1}: The distribution of the mesh elements.\nmesh::DataFrame: The mesh data as a DataFrame.\nntype::Dict: The type of the mesh elements.\noverlap_map::Array{Array{Int64,1},1}: The overlap map of the mesh elements.\nnlist::Array{Array{Int64,1},1}: The neighborhood list of the mesh elements.\ndof::Int64: The degrees of freedom (DOF) for the mesh elements.\nnsets::Dict: The node sets\ntopology::Int64::Array{Int64,nelement:nodes}`: The topology of elements.\nel_distribution::Array{Int64,1}: The distribution of the finite elements.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.local_nodes_from_dict-Tuple{Dict{Int64, Int64}, Vector{Int64}}","page":"IO","title":"PeriLab.IO.local_nodes_from_dict","text":"local_nodes_from_dict(create_global_to_local_mapping::Dict{Int,Int}, global_nodes::Vector{Int64})\n\nChanges entries in the overlap map from the global numbering to the local computer core one.\n\nArguments\n\ncreate_global_to_local_mapping::Dict{Int,Int}: global to local mapping\nglobal_nodes::Vector{Int64}: global nodes\n\nReturns\n\noverlap_map::Dict{Int64, Dict{Int64, String}}: returns overlap map with local nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.merge_exodus_file-Tuple{AbstractString}","page":"IO","title":"PeriLab.IO.merge_exodus_file","text":"merge_exodus_file(file_name::Union{AbstractString,String})\n\nMerges the exodus file\n\nArguments\n\nfile_name::Union{AbstractString,String}: The name of the file to merge\n\nReturns\n\nexo::ExodusDatabase: The exodus file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.merge_exodus_files-Tuple{Vector{Dict}, String}","page":"IO","title":"PeriLab.IO.merge_exodus_files","text":"merge_exodus_files(result_files::Vector{Any}, output_dir::String)\n\nMerges exodus output files\n\nArguments\n\nresult_files::Vector{Any}: The result files\noutput_dir::String: The file directory\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.movement-Tuple{Any, Any}","page":"IO","title":"PeriLab.IO.movement","text":"movement(cmds, dataobject)\n\nExample movement callback for G0 and G1 which calculates the total distance moved in all axes.\n\nIt is calculated by watching the X, Y and Z axes movement.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.neighbors-Tuple{DataFrames.DataFrame, Dict, Union{Vector{Int64}, Vector{String}}}","page":"IO","title":"PeriLab.IO.neighbors","text":"neighbors(mesh, params::Dict, coor)\n\nCompute the neighbor list for each node in a mesh based on their proximity using a BallTree data structure.\n\nArguments\n\nmesh: A mesh data structure containing the coordinates and other information.\nparams: paramss needed for computing the neighbor list.\ncoor: A vector of coordinate names along which to compute the neighbor list.\n\nReturns\n\nAn array of neighbor lists, where each element represents the neighbors of a node in the mesh.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.node_distribution","page":"IO","title":"PeriLab.IO.node_distribution","text":"node_distribution(nlist::BondScalarState{Int64}, size::Int64)\n\nCreate the distribution of the nodes.\n\nArguments\n\nnlist::BondScalarState{Int64}: The neighborhood list of the mesh elements.\nsize::Int64: The number of ranks.\ndistribution_type::String: The distribution type.\n\nReturns\n\ndistribution::Vector{Vector{Int64}}: The distribution of the nodes.\nptc::Vector{Int64}: Defines at which core / rank each node lies.\nntype::Dict: The type of the nodes.\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.IO.open_result_file-Tuple{Dict}","page":"IO","title":"PeriLab.IO.open_result_file","text":"open_result_file(result_file::Dict)\n\nOpens the result file\n\nArguments\n\nresult_file::Dict: The result file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.paraview_specifics-Tuple{Int64}","page":"IO","title":"PeriLab.IO.paraview_specifics","text":"paraview_specifics(dof::Int64)\n\nReturns the paraview specific dof\n\nArguments\n\ndof::Int64: The degrees of freedom\n\nReturns\n\nparaview_specifics::String: The paraview specific dof\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.parseLine","page":"IO","title":"PeriLab.IO.parseLine","text":"parseLine(line::String, returnPair::Bool = true)::Array{Union{String,Pair{String,String}},1}\n\nParse a single line of g-code and return an array of Pair{String,String} or an array of String containing the parsed commands.\n\nThe first command usually defines what to do (ie. G01 - linear interpolation) and following commands are the arguments (ie. X 14.312);\n\nExamples\n\njulia> parseLine(\"G10 X5.Y3. E6.\")\n4-element Array{Union{Pair{String,String}, String},1}:\n \"G\" => \"10\"\n \"X\" => \"5.\"\n \"Y\" => \"3.\"\n \"E\" => \"6.\"\n\nReturn array of strings\n\njulia> parseLine(\"G10 X5.Y3. E6.\", false)\n4-element Array{Union{Pair{String,String}, String},1}:\n \"G10\"\n \"X5.\"\n \"Y3.\"\n \"E6.\"\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.IO.read_external_topology-Tuple{String}","page":"IO","title":"PeriLab.IO.read_external_topology","text":"read_external_topology(filename::String)\n\nRead external topoloy data from a file and return it as a DataFrame.\n\nArguments\n\nfilename::String: The path to the mesh file.\n\nReturns\n\nexternal_topology::DataFrame: The external topology data as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.read_input-Tuple{String}","page":"IO","title":"PeriLab.IO.read_input","text":"read_input(filename::String)\n\nReads the input deck from a yaml file\n\nArguments\n\nfilename::String: The name of the yaml file\n\nReturns\n\nparams::Dict{String,Any}: The parameters read from the yaml file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.read_input_file-Tuple{String}","page":"IO","title":"PeriLab.IO.read_input_file","text":"read_input_file(filename::String)\n\nReads the input deck from a yaml file\n\nArguments\n\nfilename::String: The name of the yaml file\n\nReturns\n\nDict{String,Any}: The validated parameters read from the yaml file.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.read_mesh-Tuple{String, Dict}","page":"IO","title":"PeriLab.IO.read_mesh","text":"read_mesh(filename::String, params::Dict)\n\nRead mesh data from a file and return it as a DataFrame.\n\nArguments\n\nfilename::String: The path to the mesh file.\nparams::Dict: The input parameters.\n\nReturns\n\nmesh::DataFrame: The mesh data as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.rectangular_plane_filter-Tuple{Int64, Matrix{Float64}, Dict, Vector{Vector{Int64}}, Int64}","page":"IO","title":"PeriLab.IO.rectangular_plane_filter","text":"rectangular_plane_filter(nnodes::Int64, data::Matrix{Float64}, filter::Dict, nlist::BondScalarState{Int64}, dof::Int64)\n\nApply the rectangular plane filter to the neighborhood list.\n\nArguments\n\nnnodes::Int64: The number of nodes.\ndata::Matrix{Float64}: The data.\nfilter::Dict: The filter.\nnlist::BondScalarState{Int64}: The neighborhood list.\ndof::Int64: The degrees of freedom.\n\nReturns\n\nfilter_flag::Vector{Bool}: The filter flag.\nnormal::Vector{Float64}: The normal vector of the disk.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.set_dof-Tuple{DataFrames.DataFrame}","page":"IO","title":"PeriLab.IO.set_dof","text":"set_dof(mesh::DataFrame)\n\nSet the degrees of freedom (DOF) for the mesh elements.\n\nArguments\n\nmesh::DataFrame: The input mesh data represented as a DataFrame.\n\nReturns\n\ndof::Int64: The degrees of freedom (DOF) for the mesh elements.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.set_output_frequency","page":"IO","title":"PeriLab.IO.set_output_frequency","text":"set_output_frequency(params::Dict, nsteps::Int64, step_id::Int64)\n\nSets the output frequency.\n\nArguments\n\nparams::Dict: The parameters\nnsteps::Int64: The number of steps\nstep_id::Int64: The step id\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.IO.show_block_summary-Tuple{Dict, Dict, String, Bool, MPI.Comm}","page":"IO","title":"PeriLab.IO.show_block_summary","text":"show_block_summary(solver_options::Dict, params::Dict, log_file::String, silent::Bool, comm::MPI.Comm)\n\nShow block summary.\n\nArguments\n\nsolver_options::Dict: The solver options\nparams::Dict: The params\nlog_file::String: The log file\nsilent::Bool: The silent flag\ncomm::MPI.Comm: The Comm_rank\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.show_mpi_summary-Tuple{String, Bool, MPI.Comm}","page":"IO","title":"PeriLab.IO.show_mpi_summary","text":"show_mpi_summary(log_file::String, silent::Bool, comm::MPI.Comm)\n\nShow MPI summary.\n\nArguments\n\nlog_file::String: The log file\nsilent::Bool: The silent flag\ncomm::MPI.Comm: The comm\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.stripComments-Tuple{String}","page":"IO","title":"PeriLab.IO.stripComments","text":"stripComments(line::String)::String\n\nReturn a copy of string line with stripped comments inside parentheses and all characters after a semicolon.\n\nThis function also removes whitespace as it it not needed for further parsing.\n\nExamples\n\njulia> stripComments(\"G92 (G10(aaa)))) ((comment)G) Z0.2 ; this is a comment\")\n\"G92Z0.2\"\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.tetrahedron_volume-Tuple{Matrix{Float64}}","page":"IO","title":"PeriLab.IO.tetrahedron_volume","text":"tetrahedron_volume(tet_vertices)\n\nCalculate the volume of a tetrahedron.\n\nArguments\n\ntet_vertices: The vertices of the tetrahedron.\n\nReturns\n\nvolume: The volume of the tetrahedron.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.tetrahedron_volume-Tuple{Vector{Vector{Float64}}}","page":"IO","title":"PeriLab.IO.tetrahedron_volume","text":"tetrahedron_volume(tet_vertices)\n\nCalculate the volume of a tetrahedron.\n\nArguments\n\ntet_vertices: The vertices of the tetrahedron.\n\nReturns\n\nvolume: The volume of the tetrahedron.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.wedge6_volume-Tuple{Vector{Vector{Float64}}}","page":"IO","title":"PeriLab.IO.wedge6_volume","text":"wedge6_volume(wedge_vertices)\n\nCalculate the volume of a wedge.\n\nArguments\n\nwedge_vertices: The vertices of the wedge.\n\nReturns\n\nvolume: The volume of the wedge.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.write_global_results_in_csv-Tuple{IOStream, Float64, Any}","page":"IO","title":"PeriLab.IO.write_global_results_in_csv","text":"write_global_results_in_csv(csv_file::IOStream, time::Float64, global_values)\n\nWrites the global results to the csv file\n\nArguments\n\ncsv_file::IOStream: The csv file\nglobal_values: The global values\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.write_global_results_in_exodus-Tuple{Exodus.ExodusDatabase, Int64, Any}","page":"IO","title":"PeriLab.IO.write_global_results_in_exodus","text":"write_global_results_in_exodus(exo::ExodusDatabase, step::Int64, global_values)\n\nWrites the global results in the exodus file\n\nArguments\n\nexo::ExodusDatabase: The exodus file\nstep::Int64: The step\nglobal_values: The global values\n\nReturns\n\nexo::ExodusDatabase: The exodus file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.write_nodal_results_in_exodus-Tuple{Exodus.ExodusDatabase, Int64, Dict}","page":"IO","title":"PeriLab.IO.write_nodal_results_in_exodus","text":"write_nodal_results_in_exodus(exo::ExodusDatabase, step::Int64, output::Dict)\n\nWrites the nodal results in the exodus file\n\nArguments\n\nexo::ExodusDatabase: The exodus file\nstep::Int64: The step\noutput::Dict: The output\n\nReturns\n\nexo::ExodusDatabase: The exodus file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.write_results-Tuple{Vector{Dict}, Float64, Float64, Dict}","page":"IO","title":"PeriLab.IO.write_results","text":"write_results(result_files::Vector{Any}, time::Float64, max_damage::Float64, outputs::Dict)\n\nWrite results.\n\nArguments\n\nresult_files::Vector{Any}: The result files\ntime::Float64: The time\nmax_damage::Float64: The maximum damage\noutputs::Dict: The outputs\n\nReturns\n\nresult_files::Vector{Any}: The result files\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.IO.write_step_and_time-Tuple{Exodus.ExodusDatabase, Int64, Float64}","page":"IO","title":"PeriLab.IO.write_step_and_time","text":"write_step_and_time(exo::ExodusDatabase, step::Int64, time::Float64)\n\nWrites the step and time in the exodus file\n\nArguments\n\nexo::ExodusDatabase: The exodus file\nstep::Int64: The step\ntime::Float64: The time\n\nReturns\n\nexo::ExodusDatabase: The exodus file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling._get_values","page":"IO","title":"PeriLab.Parameter_Handling._get_values","text":"_get_values(params::Dict, block_id::Int64, valueName::String, defaultValue::Union{Float64,Bool,Nothing})\n\nGet the value of a block.\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: The ID of the block\nvalueName::String: The name of the value\ndefaultValue::Union{Float64,Bool,Nothing: The default value\n\nReturns\n\nvalue::Float64: The value of the block\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.check_for_duplicates-Tuple{Vector{String}}","page":"IO","title":"PeriLab.Parameter_Handling.check_for_duplicates","text":"check_for_duplicates(filenames)\n\nCheck for duplicate filenames.\n\nArguments\n\nfilenames::Vector{String}: The filenames\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_all_keys-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_all_keys","text":"get_all_keys(params::Dict)\n\nGet all the keys in the parameters\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nkeys_list::Array: The keys list\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_angles-Tuple{Dict, Int64, Int64}","page":"IO","title":"PeriLab.Parameter_Handling.get_angles","text":"get_angles(params::Dict, block_id::Int64, dof::Int64)\n\nGet the horizon of a block.\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: The ID of the block\ndof::Int64: The dof\n\nReturns\n\nangles::Float64: The angles of the block\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_bc_definitions-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_bc_definitions","text":"get_bc_definitions(params::Dict)\n\nGet the boundary condition definitions\n\nArguments\n\nparams::Dict: The parameters\n\nReturns\n\nbcs::Dict{String,Any}: The boundary conditions\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_block_names_and_ids-Tuple{Dict, Vector{Int64}, Bool}","page":"IO","title":"PeriLab.Parameter_Handling.get_block_names_and_ids","text":"get_block_names_and_ids(params::Dict, block_ids::Vector{Int64})\n\nGet the names of the blocks.\n\nArguments\n\nparams::Dict: The parameters dictionary.\nblock_ids::Vector{Int64}: The IDs of the blocks\n\nReturns\n\nblock_names::Vector{String}: The names of the blocks.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_bond_filters-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_bond_filters","text":"get_bond_filters(params::Dict)\n\nReturns the bond filters from the parameters\n\nArguments\n\nparams::Dict: The parameters\n\nReturns\n\ncheck::Bool: Whether the bond filters are defined\nbfList::Dict{String,Dict{String,Any}}: The bond filters\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_calculation_options-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_calculation_options","text":"get_calculation_options(params::Dict)\n\nGet the calculation options\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nsolver_options::Dict: The solver options\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_computes-Tuple{Dict, Vector{String}}","page":"IO","title":"PeriLab.Parameter_Handling.get_computes","text":"get_computes(params::Dict, variables::Vector{String})\n\nGet the computes.\n\nArguments\n\nparams::Dict: The parameters dictionary.\nvariables::Vector{String}: The variables.\n\nReturns\n\ncomputes::Dict{String,Dict{Any,Any}}: The computes.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_computes_names-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_computes_names","text":"get_computes_names(params::Dict)\n\nGet the names of the computes.\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\ncomputes_names::Vector{String}: The names of the computes.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_density-Tuple{Dict, Int64}","page":"IO","title":"PeriLab.Parameter_Handling.get_density","text":"get_density(params::Dict, block_id::Int64)\n\nGet the density of a block.\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: The ID of the block\n\nReturns\n\ndensity::Float64: The density of the block\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_end_time-Tuple{Dict, String}","page":"IO","title":"PeriLab.Parameter_Handling.get_end_time","text":"get_end_time(outputs::Dict, output::String)\n\nGet the end_time.\n\nArguments\n\noutputs::Dict: The outputs\noutput::String: The output\n\nReturns\n\nend_time::Float64: The value\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_external_topology_name-Tuple{Dict, Any}","page":"IO","title":"PeriLab.Parameter_Handling.get_external_topology_name","text":"get_external_topology_name(params::Dict, path)\n\nReturns the name of the mesh file from the parameters\n\nArguments\n\nparams::Dict: The parameters\npath::String: Path of the working folder\n\nReturns\n\nString: The name of the finite element topology file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_fem_block-Tuple{Dict, Int64}","page":"IO","title":"PeriLab.Parameter_Handling.get_fem_block","text":"get_fem_block(params::Dict, block_id::Int64)\n\nGet the fem_block of a block.\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: The ID of the block\n\nReturns\n\nfem_block::Float64: The fem_block of the block\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_final_time-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_final_time","text":"get_final_time(params::Dict)\n\nGet the final time\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nfinal_time::Float64: The final time\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_fixed_dt-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_fixed_dt","text":"get_fixed_dt(params::Dict)\n\nGet the fixed time step\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nfixed_dt::Float64: The fixed time step\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_flush_file-Tuple{Dict, String}","page":"IO","title":"PeriLab.Parameter_Handling.get_flush_file","text":"get_flush_file(outputs::Dict, output::String)\n\nGets the flush file.\n\nArguments\n\noutputs::Dict: The outputs\noutput::String: The output\n\nReturns\n\nflush_file::Bool: The flush file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_header-Tuple{AbstractString}","page":"IO","title":"PeriLab.Parameter_Handling.get_header","text":"get_header(filename::Union{String,AbstractString})\n\nReturns the header line and the header.\n\nArguments\n\nfilename::Union{String,AbstractString}: The filename of the file.\n\nReturns\n\nheader_line::Int: The header line.\nheader::Vector{String}: The header.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_heat_capacity-Tuple{Dict, Int64}","page":"IO","title":"PeriLab.Parameter_Handling.get_heat_capacity","text":"get_heat_capacity(params::Dict, block_id::Int64)\n\nGet the heat capacity of a block.\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: The ID of the block\n\nReturns\n\nheat_capacity::Float64: The heat capacity of the block\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_horizon-Tuple{Dict, Int64}","page":"IO","title":"PeriLab.Parameter_Handling.get_horizon","text":"get_horizon(params::Dict, block_id::Int64)\n\nGet the horizon of a block.\n\nArguments\n\nparams::Dict: The parameters\nblock_id::Int64: The ID of the block\n\nReturns\n\nhorizon::Float64: The horizon of the block\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_initial_time-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_initial_time","text":"get_initial_time(params::Dict)\n\nGet the initial time\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\ninitial_time::Float64: The initial time\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_max_damage-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_max_damage","text":"getmaxdamage(params::Dict)\n\nGet the maximum damage.\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nmax_damage::Float64: The value\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_mesh_name-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_mesh_name","text":"get_mesh_name(params::Dict)\n\nReturns the name of the mesh file from the parameters\n\nArguments\n\nparams::Dict: The parameters\n\nReturns\n\nString: The name of the mesh file\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_model_options-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_model_options","text":"get_model_options(params::Dict)\n\nGet the solver options\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nsolver_options::Dict: The solver options\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_model_parameter","page":"IO","title":"PeriLab.Parameter_Handling.get_model_parameter","text":"get_model_parameter(params, model, id)\n\nRetrieve a model parameter from a dictionary of parameters.\n\nThis function retrieves a specific model parameter from a dictionary of parameters based on the provided model and identifier (id).\n\nArguments\n\nparams::Dict: A dictionary containing various parameters.\nmodel::String: The model type for which the parameter is sought.\nid::String: The identifier (name) of the specific model parameter.\n\nReturns\n\nparameter::Any: The retrieved model parameter, or nothing if the parameter is not found.\n\nErrors\n\nIf the specified model is defined in blocks but no model definition block exists, an error message is logged, and the function returns nothing.\nIf the model with the given identifier is defined in blocks but missing in the model's definition, an error message is logged, and the function returns nothing.\n\nExample\n\nparams = Dict(\n    \"Models\" => Dict(\n        \"Models\" => Dict(\n            \"ModelA\" => 42,\n            \"ModelB\" => 24\n        )\n    )\n)\n\nmodel = \"Models\"\nid = \"ModelA\"\n\nresult = get_model_parameter(params, model, id)\nif result !== nothing\n    println(\"Parameter id: result\")\nelse\n    println(\"Parameter not found.\")\nend\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_node_sets-Tuple{Dict, String, DataFrames.DataFrame}","page":"IO","title":"PeriLab.Parameter_Handling.get_node_sets","text":"get_node_sets(params::Dict, path::String)\n\nReturns the node sets from the parameters\n\nArguments\n\nparams::Dict: The parameters\npath::String: The path to the mesh file\n\nReturns\n\nnsets::Dict{String,Any}: The node sets\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_nsteps-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_nsteps","text":"get_nsteps(params::Dict)\n\nGet the fixed time step\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nnsteps::Int64: The fixed time step\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_numerical_damping-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_numerical_damping","text":"get_numerical_damping(params::Dict)\n\nGet the numerical damping\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nnumerical_damping::Float64: The numerical damping\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_output_fieldnames-Tuple{Dict, Vector{String}, Vector{String}, String}","page":"IO","title":"PeriLab.Parameter_Handling.get_output_fieldnames","text":"get_output_fieldnames(outputs::Dict, variables::Vector{String}, computes::Vector{String}, output_type::String)\n\nGets the output fieldnames.\n\nArguments\n\noutputs::Dict: The outputs\nvariables::Vector{String}: The variables\ncomputes::Vector{String}: The computes\noutput_type::String: The output type\n\nReturns\n\noutput_fieldnames::Vector{String}: The output fieldnames\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_output_filenames-Tuple{Dict, String}","page":"IO","title":"PeriLab.Parameter_Handling.get_output_filenames","text":"get_output_filenames(params::Dict, output_dir::String)\n\nGets the output filenames.\n\nArguments\n\nparams::Dict: The parameters\noutput_dir::String: The file directory\n\nReturns\n\nfilenames::Vector{String}: The filenames\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_output_frequencies-Tuple{Dict, Int64}","page":"IO","title":"PeriLab.Parameter_Handling.get_output_frequencies","text":"get_output_frequencies(params::Dict, nsteps::Int64)\n\nGets the output frequencies.\n\nArguments\n\nparams::Dict: The parameters\nnsteps::Int64: The number of steps\n\nReturns\n\nfreq::Vector{Int64}: The output frequencies\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_output_type-Tuple{Dict, String}","page":"IO","title":"PeriLab.Parameter_Handling.get_output_type","text":"get_output_type(outputs::Dict, output::String)\n\nGets the output type.\n\nArguments\n\noutputs::Dict: The outputs\noutput::String: The output\n\nReturns\n\noutput_type::String: The output type\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_output_variables-Tuple{String, Vector{String}}","page":"IO","title":"PeriLab.Parameter_Handling.get_output_variables","text":"get_output_variables(output::String, variables::Vector{String})\n\nGet the output variable.\n\nArguments\n\noutput::String: The output variable.\nvariables::Vector{String}: The variables.\n\nReturns\n\noutput::String: The output variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_outputs-Tuple{Dict, Vector{String}, Vector{String}}","page":"IO","title":"PeriLab.Parameter_Handling.get_outputs","text":"get_outputs(params::Dict, variables::Vector{String}, compute_names::Vector{String})\n\nGets the outputs.\n\nArguments\n\nparams::Dict: The parameters\nvariables::Vector{String}: The variables\ncompute_names::Vector{String}: The compute names\n\nReturns\n\noutputs::Dict: The outputs\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_safety_factor-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_safety_factor","text":"get_safety_factor(params::Dict)\n\nGet the safety factor\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nsafety_factor::Float64: The safety factor\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_solver_name-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_solver_name","text":"get_solver_name(params::Dict)\n\nGet the name of the solver\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nsolver_name::String: The name of the solver\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_solver_params-Tuple{Dict, Any}","page":"IO","title":"PeriLab.Parameter_Handling.get_solver_params","text":"get_solver_params(params::Dict)\n\nGet the solver parameters\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nsolver_params::Dict: The solver parameters\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_solver_steps-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.get_solver_steps","text":"get_solver_steps(params::Dict)\n\nGet the solver steps\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nsolver_steps::List: The solver steps\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_start_time-Tuple{Dict, String}","page":"IO","title":"PeriLab.Parameter_Handling.get_start_time","text":"get_start_time(outputs::Dict, output::String)\n\nGet the start_time.\n\nArguments\n\noutputs::Dict: The outputs\noutput::String: The output\n\nReturns\n\nstart_time::Float64: The value\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.get_write_after_damage-Tuple{Dict, String}","page":"IO","title":"PeriLab.Parameter_Handling.get_write_after_damage","text":"get_write_after_damage(outputs::Dict, output::String)\n\nGet the write after damage.\n\nArguments\n\noutputs::Dict: The outputs\noutput::String: The output\n\nReturns\n\nwrite_after_damage::Bool: The value\n\n\n\n\n\n","category":"method"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.validate_structure_recursive","page":"IO","title":"PeriLab.Parameter_Handling.validate_structure_recursive","text":"validate_structure_recursive(expected::Dict, actual::Dict, validate::Bool, checked_keys::Array, path::String=\"\")\n\nValidates the parameters against the expected structure\n\nArguments\n\nexpected::Dict: The expected structure\nactual::Dict: The actual structure\nvalidate::Bool: The validation results\nchecked_keys::Array: The keys that have been checked\npath::String: The current path\n\nReturns\n\nvalidate::Bool: The validation result\nchecked_keys::Array: The keys that have been checked\n\n\n\n\n\n","category":"function"},{"location":"lib/io_functions/#PeriLab.Parameter_Handling.validate_yaml-Tuple{Dict}","page":"IO","title":"PeriLab.Parameter_Handling.validate_yaml","text":"validate_yaml(params::Dict)\n\nValidates the parameters against the expected structure\n\nArguments\n\nparams::Dict: The parameters dictionary.\n\nReturns\n\nparams::Dict: The parameters dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/geometry_functions/#Geometry-Functions","page":"Geometry","title":"Geometry - Functions","text":"","category":"section"},{"location":"lib/geometry_functions/#Index","page":"Geometry","title":"Index","text":"Pages = [\"geometry_functions.md\"]","category":"section"},{"location":"lib/geometry_functions/#Geometry","page":"Geometry","title":"Geometry","text":"","category":"section"},{"location":"lib/geometry_functions/#PeriLab.Geometry.compute_shape_tensors!-Tuple{Array{Float64, 3}, Array{Float64, 3}, AbstractVector{Int64}, Vector{Vector{Int64}}, Vector{Float64}, Vector{Vector{Float64}}, Vector{Vector{Float64}}, Vector{Vector{Vector{Float64}}}}","page":"Geometry","title":"PeriLab.Geometry.compute_shape_tensors!","text":"compute_shape_tensors!(nodes::AbstractVector{Int64}, nlist, volume, omega, bond_damage, undeformed_bond, shape_tensor, inverse_shape_tensor)\n\nCalculate the shape tensor and its inverse for a set of nodes in a computational mechanics context.\n\nArguments\n\nnodes::AbstractVector{Int64}: A vector of integers representing node IDs.\ndof::Int64: An integer representing the degrees of freedom.\nnlist: A data structure (e.g., a list or array) representing neighboring node IDs for each node.\nvolume: A vector or array containing volume information for each node.\nomega: A vector or array containing omega information for each node.\nbond_damage: A data structure representing bond damage for each node.\nundeformed_bond: A data structure representing bond geometries for each node.\nshape_tensor: A preallocated 3D array to store the shape tensors for each node.\ninverse_shape_tensor: A preallocated 3D array to store the inverse shape tensors for each node.\n\nOutput\n\nshape_tensor: An updated shape_tensor array with calculated shape tensors.\ninverse_shape_tensor: An updated inverse_shape_tensor array with calculated inverse shape tensors.\n\nDescription\n\nThis function calculates the shape tensor and its inverse for a set of nodes in a computational mechanics context. The shape tensor is a key quantity used in continuum mechanics to describe material deformation. It is calculated based on bond damage, bond geometries, volume, and omega information for each node.\n\nFor each node in nodes, the function iterates through degrees of freedom (dof) and computes elements of the shape tensor. The inverse of the shape tensor is also calculated and stored in inverse_shape_tensor.\n\nExample\n\nnodes = [1, 2, 3]\ndof = 3\nnlist = [[2, 3], [1, 3], [1, 2]]\nvolume = [0.1, 0.2, 0.3]\nomega = [0.5, 0.4, 0.6]\nbond_damage = zeros(Float64, length(nodes), length(nlist[1]))\nundeformed_bond = rand(Float64, length(nodes), length(nlist[1]), dof)\nshape_tensor = zeros(Float64, length(nodes), dof, dof)\ninverse_shape_tensor = zeros(Float64, length(nodes), dof, dof)\n\n\n\n\n\n","category":"method"},{"location":"lib/geometry_functions/#PeriLab.Geometry.compute_strain!-Tuple{AbstractVector{Int64}, Array{Float64}, Array{Float64}}","page":"Geometry","title":"PeriLab.Geometry.compute_strain!","text":"function compute_strain!(nodes::AbstractVector{Int64},\n                     deformation_gradient::NodeTensorField{Float64},\n                     strain::NodeTensorField{Float64})\n\nCalculate strains for specified nodes based on deformation gradients.\n\nArguments\n\nnodes::AbstractVector{Int64}: List of nodes\ndeformation_gradient: Deformation gradient at current time step (2D or 3D array).\n\nReturns\n\nUpdated strain array containing strains.\n\nThis function iterates over the specified nodes and computes strain at each node using the given deformation gradients.\n\n\n\n\n\n","category":"method"},{"location":"lib/geometry_functions/#PeriLab.Geometry.rotation_tensor-Union{Tuple{T}, Tuple{T, Int64}} where T<:Union{AbstractVector{Float64}, AbstractVector{Int64}}","page":"Geometry","title":"PeriLab.Geometry.rotation_tensor","text":"function rotation_tensor(angles::Vector{Float64})\n\nCreates the rotation tensor for 2D or 3D applications. Uses Rotations.jl package.\n\nArguments\n\nangles::Vector{Float64}: Vector of angles definede in degrees of length one or three\n\nReturns\n\nRotation tensor\n\n\n\n\n\n","category":"method"},{"location":"man/dev/start_dev/#Getting-started-Develop-your-own-model","page":"Getting started","title":"Getting started - Develop your own model","text":"PeriLabs main development focus right now is the model section. Each model have folders with templates. Here you can find a plain .jl file with all functions you need for a minimal configuration.\n\nThis guide shows how to set up a material model. But it's the same strategy for more or less all models. The key is what you have to compute. In material it is the bond force in deformed bond direction. In damage models it is the bond damage. For thermal models it is the flux and / or the thermal deformation gradient.","category":"section"},{"location":"man/dev/start_dev/#Model-integration","page":"Getting started","title":"Model integration","text":"This is how the module header looks like. You can add here additional functions you want to export or load additional packages if needed. This set up is the basis.\n\nmodule Material_template\nusing TimerOutputs\nexport fe_support\nexport init_model\nexport material_name\nexport compute_model\nexport fields_for_local_synchronization\n\n...\n\nend\n\nFirst you have to rename your module. It should be different from existing ones. The first character should be capital. The rest is your choice.\n\nNext you have to change the function material_name. It is used to define the name of your model\n\nfunction material_name()\n    return \"My model\"\nend\n\nIn the YAML file you can call your model like this. The id Mat_1 has to be applied to a block and your module works\n\n Material Models:\n      Mat_1:\n        Material Model: \"My model\"\n\nThe density and the horizon depends on your problem.\n\ninfo: Mass density\nThe parameter density is defined in the blocks. Reason is that this parameter is used for other models as thermal as well.\n\n    block_1:\n      Block ID: 1\n      Density: 1.95e-06\n      Horizon: 0.82\n      Material Model: Mat_1\n\nCongratulations you first model works and runs. However, it does not do anything.","category":"section"},{"location":"man/dev/start_dev/#Include-features","page":"Getting started","title":"Include features","text":"The module TimerOutputs allows you measuring the computation speed and memory for certain functions or areas of your code.\n\n@timeit \"foo function\" foo()\n\n@timeit \"more foo functions\" begin\n    foo1()\n    foo2()\nend\n\nThe function initmodel is used to initialize the model. Here, you can check if parameters exist or set reference values. The dictionary materialparams includes all parameters you had defined in your yaml.\n\nYou can and should also create fields using the datamanger.\n\nfunction init_model(nodes::AbstractVector{Int64},\n                    material_parameter::Dict)\nend\n\nThis function is used as marker if it is suited for FE support. Therefore, it must be able to compute a Cauchy stress.\n\nfunction fe_support()\n    return false\nend\n\nThis function is used to specify properties which should be synchronized before the material models are called. An example is, that you need the neighboring deformation gradients to compute the bond associated correspondence formulation. Therefore, you have to synchronize.\n\nThis feature is only needed for multicore applications. The main parameters are synchronized at the beginning of each time step.\n\nwarning: Cost of synchronization\nBe aware, that synchronization cost time. Therefore, try to avoid it if possible.\n\nfunction fields_for_local_synchronization(model::String)\nend\n\nThe last module computes the model in each time step. You get all nodes and have to compute the neighorhood of it. You must call the fields you need from the datamanager. You should avoid checking if parameter exists in the material_parameter dictionary.\n\ninfo: Separation of function\nPlease seperate the functionality. Call type stable functions for analysis. Use compute_model as function to structure your analysis (getting data, call subfunctions). It is better to read, better to test and better to optimize.\n\nfunction compute_model(nodes::AbstractVector{Int64},\n                       material_parameter::Dict,\n                       block::Int64,\n                       time::Float64,\n                       dt::Float64,\n                       to::TimerOutput)\nend","category":"section"},{"location":"man/dev/start_dev/#Additional-functions","page":"Getting started","title":"Additional functions","text":"You can add as many functions as you want. You can also create files and include them if needed. As long as the interface functions exists, the module can be called.","category":"section"},{"location":"man/dev/start_dev/#Template-files","page":"Getting started","title":"Template files","text":"Additive\n\nContact\n\nDamage\n\nNon correspondence material\n\nCorrespondence material\n\nPre calculation\n\nThermal\n\n","category":"section"},{"location":"theory/theory/#Theory-manual","page":"Basics","title":"Theory manual","text":"","category":"section"},{"location":"theory/theory/#Peridynamic-theory","page":"Basics","title":"Peridynamic theory","text":"The theory manual condenses the implemented features.\n\nPeridynamics is an integral continuum mechanics formulation. For a pure mechanical description it can be formulated as:\n\nint_mathcalHunderlinemathbfTlanglemathbfxtrangle-underlinemathbfTlanglemathbfxtrangle dV- mathbfb=rhoddotmathbfu\n\nThe parameters are:\n\nParameter Name\nmathcalH Neighborhood [-]\nV Volume [m^3]\nmathbfx Position of point [m]\nmathbfx Position of neighbor [m]\nt Time [s]\nmathbfb Body force densities [Nm^3]\nmathbfu Displacements [m]\nddotmathbfu Accelerations [ms^2]\nunderlinemathbfT Force density state [Nm^6]\nrho Mass density [kgm^3]\n\nTo solve this three main types of formulations are usable; bond-based, ordinary state-based and non-ordinary state-based.\n\nMethod Related Model in PeriLab\nBond-based Bond-based Elastic\nOrdinary state-based PD Solid Elastic PD Solid Plastic\nNon-ordinary state-based Correspondence Elastic Correspondence Plastic\nBond-associated correspondence \nUnified bond-based ","category":"section"},{"location":"theory/theory/#Finite-element-theory","page":"Basics","title":"Finite element theory","text":"Finite elements are used to model boundary conditions or to be computational more efficient. PeriLab is no FEM code. Within the theory manual the basic theory and the FEM-PD coupling methods are presented.\n\n","category":"section"},{"location":"man/dev/developement_guide/#Development-Guide","page":"Guide","title":"Development Guide","text":"PeriLab is design to be extentable. Modules can be integrated with the so called factory modules. These modules are the interfaces to the higher functions.\n\ninfo: Example\nThe solver calls compute_forces as a function. This function is integrated in the Material module. Within this module the relevant material model is integrated, using the set_modules module","category":"section"},{"location":"man/dev/developement_guide/#Model-structure","page":"Guide","title":"Model structure","text":"PeriLab is structured in different ''Models''. These models are included in the model factory and split in two main parts. An init and compute part. All memory, parameter check, etc. takes place in the init phase. The computation should run without thowing warnings or errors due to input variable errors.\n\nIf you plan large scale implemention please contact us.","category":"section"},{"location":"man/dev/developement_guide/#Guidelines","page":"Guide","title":"Guidelines","text":"try to fix the type of the variables in functions\nuse self explaining variables and functions\nwrite tests\nfull scale tests should check whole models and their interaction in the software\nunit tests should test exceptions and key features\ninputs are checked in the init part of models not during run time\nin code documentation in front of functions\ntheory and extensive model explainations in the documentation\nwrite issues\nask for help\nhave fun :)\n\ninfo: References\nIf you are part of the developer or user of PeriLab feel free to use your references to improve the documentation. Especially for publications created with PeriLab.\n\n","category":"section"},{"location":"man/dev/datamanager/#Datamanager","page":"Datamanager","title":"Datamanager","text":"The datamanager is a central part of PeriLab. You can create fields as you need them based on the following data types.","category":"section"},{"location":"man/dev/datamanager/#Data-types","page":"Datamanager","title":"Data types","text":"Specific data types are defined to simplify the headers of PeriLab functions and to make them more readable. For nodes these type are\n\nconst NodeScalarField = Vector{T} where {T<:Union{Int64,Float64,Bool}}\nconst NodeVectorField = Matrix{T} where {T<:Union{Int64,Float64,Bool}}\nconst NodeTensorField = Array{T,N} where {T<:Union{Int64,Float64,Bool},N}\n\nand for bonds the types are given as\n\nconst BondScalarState = Vector{Vector{T}} where {T<:Union{Int64,Float64,Bool}}\nconst BondVectorState = Vector{Vector{Vector{T}}} where {T<:Union{Int64,Float64,Bool}}\nconst BondTensorState = Vector{Array{T,N}} where {T<:Union{Int64,Float64,Bool},N}","category":"section"},{"location":"man/dev/datamanager/#Create-constant-node-fields","page":"Datamanager","title":"Create constant node fields","text":"Constant node fields are fields with the length of the number of nodes. It return one vector of type Type_of_variable.\n\nfield = Data_Manager.create_constant_node_vector_field(Fieldname::String, Type_of_variable::Type)\n\nYou can get constant fields\n\nfield = Data_Manager.get_field(Fieldname::String)","category":"section"},{"location":"man/dev/datamanager/#Create-non-constant-node-fields","page":"Datamanager","title":"Create non-constant node fields","text":"Non-constant node fields are fields with the length of the number of nodes. Each node could have any degree of freedom. You will get a field with N and N+1 created it by this command\n\nfieldN, fieldNP1 = Data_Manager.create_node_scalar_field(Fieldname::String, Type_of_variable::Type, Degree_of_freedom::Int64)\n\ninfo: Switch values\nThe non-constant fields are switched automatically at the end of each time integration step. At the beginning of the next step NP1 is zero, wheras N is the NP1 from the previous step.\n\nYou can get non-constant fields as\n\nfieldN = Data_Manager.get_field(Fieldname::String, \"N\")\nfieldNP1 = Data_Manager.get_field(Fieldname::String, \"NP1\")\nfieldN = Data_Manager.get_field(Fieldname*\"N\"::String)\nfieldNP1 = Data_Manager.get_field(Fieldname*\"NP1\"::String)","category":"section"},{"location":"man/dev/datamanager/#Create-constant-bond-fields","page":"Datamanager","title":"Create constant bond fields","text":"Constant bond fields are fields with the length of the number of nodes. Each node has a vector of lenght number of neighbors or bonds with a defined degree of freedom. It return one vector of type Type_of_variable.\n\nfield = Data_Manager.create_constant_node_vector_field(Fieldname::String, Type_of_variable::Type, Degree_of_freedom::Int64)\n\nYou can get constant fields\n\nfield = Data_Manager.get_field(Fieldname::String)","category":"section"},{"location":"man/dev/datamanager/#Create-non-constant-bond-fields","page":"Datamanager","title":"Create non-constant bond fields","text":"Non-constant node fields are fields with the length of the number of nodes. Each node has a vector of lenght number of neighbors or bonds with a defined degree of freedom. You will get a field of type Type_of_variable with N and N+1 created it by this command\n\nfieldN, fieldNP1 = Data_Manager.create_bond_vector_state(Fieldname::String, Type_of_variable::Type, Degree_of_freedom::Int64)\n\ninfo: Switch values\nThe non-constant fields are switched automatically at the end of each time integration step. At the beginning of the next step NP1 is zero, wheras N is the NP1 from the previous step.\n\nYou can get non-constant fields as\n\nfieldN = Data_Manager.get_field(Fieldname::String, \"N\")\nfieldNP1 = Data_Manager.get_field(Fieldname::String, \"NP1\")\nfieldN = Data_Manager.get_field(Fieldname*\"N\"::String)\nfieldNP1 = Data_Manager.get_field(Fieldname*\"NP1\"::String)","category":"section"},{"location":"man/dev/datamanager/#Other-Options","page":"Datamanager","title":"Other Options","text":"For node and bond fields (constant and non-constant) the following options are possible.\n\nMatrix style\n\nYou can switch between vector and matrix. If you give the keyword MatrixorVector = \"Vector\" you get vector of length degree of freedom for each node or bond. If the keyword argument MatrixOrVector = \"Matrix\" each node or bond gets matrix dof times dof\n\nData_Manager.create_node_scalar_field(Fieldname::String, Type_of_variable::Type, Degree_of_freedom::Int64; Matrix_or_Vector::String)\n\nPre-defined Values\n\nYou can add an optional value at the end. The default is zero.\n\nData_Manager.create_node_scalar_field(Fieldname::String, Type_of_variable::Type, Degree_of_freedom::Int64, Value::Type_of_variable)","category":"section"},{"location":"man/dev/datamanager/#Create-free-size-fields","page":"Datamanager","title":"Create free size fields","text":"Free size fields can be constant or non-constant. The size is defined by the user and must be a tuple. The field dimension is chosen by the user.\n\n field = Data_Manager.create_constant_free_size_field(Fieldname::String, Type_of_variable::Type, size::NTuple)\n fieldN, fieldNP1 = Data_Manager.create_free_size_field(Fieldname::String, Type_of_variable::Type, size::NTuple)\n\ninfo: free size example\nA constant node field with a matrix 3times3 per node can be defined in a free size field by\n\nfield = Data_Manager.create_constant_free_size_field(\"Example\", Float64, (number_of_nodes, 3, 3))\n\n","category":"section"},{"location":"man/input_yaml/#PeriLab-Configuration-File","page":"Input File","title":"PeriLab Configuration File","text":"The PeriLab configuration file is a YAML file used to specify the parameters for running simulations in the PeriLab software. This structure represents the global configuration for PeriLab.\n\nThe information is stored in the params dictionary","category":"section"},{"location":"man/input_yaml/#PeriLab","page":"Input File","title":"PeriLab","text":"Blocks: List of block configurations.\nblock_id: Block-specific parameters.\nDensity: Numeric value representing density. (Float64 or Int64)\nHorizon: Numeric value representing horizon. (Float64 or Int64)\nSpecific Heat Capacity: Numeric value representing specific heat capacity. (Float64 or Int64, optional)\nMaterial Model: String representing the material model. (optional)\nDamage Model: String representing the damage model. (optional)\nThermal Model: String representing the thermal model. (optional)\nAdditive Model: String representing the additive model. (optional)\nPre Calculation Model: String representing the pre-calculation model. (optional)\nAngle X: Numeric value representing angle in X direction. (Float64 or Int64, optional)\nAngle Y: Numeric value representing angle in Y direction. (Float64 or Int64, optional)\nAngle Z: Numeric value representing angle in Z direction. (Float64 or Int64, optional)","category":"section"},{"location":"man/input_yaml/#FEM-(optional)","page":"Input File","title":"FEM (optional)","text":"Element Type: String representing the type of finite element.\nDegree: Numeric value representing the degree. (String or Int64)\nMaterial Model: String representing the material model.\nCoupling: Coupling parameters. (optional)\nCoupling Type: String representing the type of coupling.","category":"section"},{"location":"man/input_yaml/#Boundary-Conditions-(optional)","page":"Input File","title":"Boundary Conditions (optional)","text":"Own_Name: List of boundary condition configurations.\nCoordinate: String representing the coordinate.\nNode Set: String representing the node set.\nVariable: String representing the variable.\nType: String representing the type of boundary condition.\nValue: Numeric value, string, or a combination representing the boundary condition value. (Float64, Int64, String)","category":"section"},{"location":"man/input_yaml/#Compute-Class-Parameters-(optional)","page":"Input File","title":"Compute Class Parameters (optional)","text":"Own_Name: List of compute class parameters.\nBlock: String representing the block.\nNode Set: String representing the node set.\nCalculation Type: String representing the calculation type.\nCompute Class: String representing the compute class.\nVariable: String representing the variable.","category":"section"},{"location":"man/input_yaml/#Discretization","page":"Input File","title":"Discretization","text":"Input Mesh File: String representing the input mesh file.\nInput External Topology: External topology parameters. (optional)\nFile: String representing the external topology file.\nAdd Neighbor Search: Boolean indicating whether to add neighbor search. (optional)\nNode Sets: Dictionary of node sets. (optional)\nOwn_Name: Numeric value or string representing the node set. (Int64 or String)\nType: String representing the type of discretization.\nDistribution Type: String representing the distribution type. (optional)\nBond Filters: List of bond filter configurations. (optional)\nOwn_Name: Bond filter parameters.\nType: String representing the bond filter type.\nNormal X/Y/Z: Numeric values representing normal components. (Float64 or Int64)\nLower Left Corner X/Y/Z: Numeric values representing lower-left corner components. (Float64 or Int64)\nBottom Unit Vector X/Y/Z: Numeric values representing bottom unit vector components. (Float64 or Int64)\nCenter X/Y/Z: Numeric values representing center components. (Float64 or Int64)\nRadius: Numeric value representing the radius. (Float64 or Int64)\nBottom Length: Numeric value representing the bottom length. (Float64 or Int64)\nSide Length: Numeric value representing the side length. (Float64 or Int64)\nAllow Contact: Boolean indicating whether to allow contact. (optional)\nSurface Extrusion: Surface extrusion parameters. (optional)\nDirection: String representing surface extrusion direction (e.g., 'X', or 'Y').\nStep_X/Y/Z: Numeric values representing step components for surface extrusion direction (Float64 or Int64).","category":"section"},{"location":"man/input_yaml/#Outputs-(optional)","page":"Input File","title":"Outputs (optional)","text":"Own_Name: List of output configurations.\nFlush File: Boolean indicating whether to flush the output file. (optional)\nOutput Frequency: Integer representing the output frequency.\nNumber of Output Steps: Integer representing the number of output steps.\nOutput File Type: String representing the output file type. (optional)\nOutput Filename: String representing the output filename.\nWrite After Damage: Boolean indicating whether to write after damage. (optional)\nOutput Variables: Dictionary of output variables.\nOwn_Name: Boolean indicating whether to output the variable.","category":"section"},{"location":"man/input_yaml/#Models-(optional)","page":"Input File","title":"Models (optional)","text":"Damage Models: Dictionary of damage models. (optional)\nOwn_Name: List of damage model configurations.\nCritical Value: Numeric value representing the critical value. (Float64 or Int64)\nDamage Model: String representing the damage model.\nInterblock Damage: Dictionary of interblock damage parameters.\nInterblock Critical Value: Numeric value representing interblock damage. (Float64 or Int64, required)\nAnisotropic Damage: Dictionary of anisotropic damage parameters.\nCritical Value X/Y: Numeric values representing critical values in X and Y directions. (Float64 or Int64, required)\nMaterial Models: Dictionary of material models. (optional)\nOwn_Name: List of material model configurations.\nMaterial Model: String representing the material model.\nSymmetry: String representing the symmetry. (optional)\nPoisson's Ratio/Young's Modulus/Bulk Modulus/Shear Modulus: Numeric values representing material properties. (Float64 or Int64, optional)\nYield Stress: Numeric value representing the yield stress. (Float64 or Int64, optional)\nZero Energy Control: String representing zero energy control. (optional)\nC11/C12/.../C66: Numeric values representing material constants. (Float64 or Int64, optional)\nThermal Models: Dictionary of thermal models. (optional)\nOwn_Name: List of thermal model configurations.\nThermal Model: String representing the thermal model.\nType: String representing the type of thermal model. (optional)\nHeat Transfer Coefficient/Environmental Temperature/Thermal Conductivity/Thermal Expansion Coefficient/Thermal Conductivity Print Bed/Print Bed Temperature: Numeric values representing thermal parameters. (Float64 or Int64, optional)\nAdditive Models: Dictionary of additive models. (optional)\nOwn_Name: List of additive model configurations.\nAdditive Model: String representing the additive model.\nPrint Temperature: Numeric value representing the print temperature. (Float64 or Int64, optional)\nPre Calculation Models: Dictionary of pre-calculation models. (optional)\nOwn_Name : List of pre calculation model configurations.. (optional).\nBond Associated Deformation Gradient/Deformation Gradient/Deformed Bond Geometry/Shape Tensor: Boolean values indicating whether to calculate the respective parameter. (optional)\nPre Calculation Global: Dictionary of pre-calculation parameters.\nBond Associated Deformation Gradient/Deformation Gradient/Deformed Bond Geometry/Shape Tensor: Boolean values indicating whether to calculate the respective parameter. (optional)","category":"section"},{"location":"man/input_yaml/#Solver","page":"Input File","title":"Solver","text":"Additive Models/Material Models/Damage Models/Thermal Models/Pre Calculation Models: Boolean values indicating whether to solve for the respective components. (optional)\nCalculate Cauchy: Boolean values indicating whether to calculate Cauchy stresses for deformation gradient and shape tensor calculations (optional).\nCalculate von Mises: Boolean values indicating whether to calculate von Mises stresses for deformation gradient and shape tensor calculations (optional).\nCalculate Strain : Boolean values indicating whether to calculate strain for deformation gradient and shape tensor calculations (optional).\nMaximum Damage: Numeric value representing the maximum damage. (Float64, optional)\nFinal Time/Initial Time: Numeric values representing the final and initial time. (Float64 or Int64, required)\nFixed dt/Number of Steps: Numeric values defining the step width. (Float64 or Int64, optional)\nVerlet: Dictionary of Verlet solver parameters.\nSafety Factor: Numeric values representing Verlet solver parameters. (Float64 or Int64, optional)\nNumerical Damping: Numeric value representing numerical damping. (Float64 or Int64, optional)\nStatic: Dictionary of Static solver parameters.\nNumber of Steps: Numeric value representing the number of steps. (Int64, optional)\nNLsolve,Solution tolerance  | Float, Residual tolerance, Maximum number of iterations, Show solver iteration, Residual scaling, Solver Type, m, Linear Start Value Numeric values representing Static solver parameters. (Float64, Bool, String or Int64, optional)","category":"section"},{"location":"man/input_yaml/#Surface-Correction-(optional)","page":"Input File","title":"Surface Correction (optional)","text":"Type: String defining what model is used, currently only Volume Correction is included\nUpdate: Bool defining if the surface is updated during the solving process, taking changes as fracture or additive processes into account","category":"section"},{"location":"man/input_yaml/#Contact-(optional)","page":"Input File","title":"Contact (optional)","text":"tbd\n\n","category":"section"},{"location":"man/models/damage/#Damage-Models","page":"Damage Models","title":"Damage Models","text":"Damage Model Critical Stretch Critical Energy\nCritical Value âœ”ï¸ âœ”ï¸\nInterblock Damage (âœ”ï¸) (âœ”ï¸)\nAnisotropic Damage (âœ”ï¸) (âœ”ï¸)","category":"section"},{"location":"man/models/damage/#Damage-index","page":"Damage Models","title":"Damage index","text":"The damage index phi of a material point is computed as [1] phi = fracint_mathcalH(1-chilangleboldsymbolxirangle)dV_xiint_mathcalHdV_xi=fracsum^n_i=1(1-chi_i dV_isum^n_i=1 dV_i with chi is the bond damage between 0 (broken) and 1 (unbroken), V is the volume and n is the number of neighbors.","category":"section"},{"location":"man/models/damage/#Critical-Stretch","page":"Damage Models","title":"Critical Stretch","text":"The critical value correspondends to the critical stretch for this model, defined in the theory manual.","category":"section"},{"location":"man/models/damage/#Critical-Energy","page":"Damage Models","title":"Critical Energy","text":"","category":"section"},{"location":"man/models/damage/#Interblock-Damage","page":"Damage Models","title":"Interblock Damage","text":"Interlaminar behaviour between different material blocks can be defined using the Interblock Critical Value parameter. If a Bond is crossing a block interface, a user defined critical damage value is applied to the bonds.\n\nAs bonds are bidirectional, the critical damage value can be defined for both orientations, for example:\n\nInterblock Damage:\nInterblock Critical Value 1_2: 0.1\nInterblock Critical Value 2_1: 0.1\n\nBonds that aren't crossing a block interface are not affected by the interblock damage model.\n\n(Image: InterBlockDamage)","category":"section"},{"location":"man/models/damage/#Local-damping","page":"Damage Models","title":"Local damping","text":"Silling proposed a local damping to reduce waves induced by cracked bonds in [1] in (EQ 2.34). This proposed algorithm is introduced in Material_Basis.jl.\n\nThe bond force due to damping is computed as\n\nmathbft_damplangleboldsymbolxirangle = overlinephid cfraceta_i-eta_i-1dt v_0fraceta_ieta_i\n\nwith the numerical local damping coefficient d, the bond stiffness c, the rate of bond extension dote=fraceta_i-eta_i-1dt where eta_i and eta_i-1 the length of the deformed bond vector at iteration step i and i-1 and dt is the time increment.\n\nThe average damage index between point i and it's neighbor j can be computed as overlinephi=fracphi_i+phi_j2 and using the Young's modulus E and the mass density rho the dilatation wave speed [8] as\n\nv_0=fracErho\n\n","category":"section"},{"location":"lecture/seminar_6/#Seminar-6:-Parallelization-and-contact","page":"Seminar 6","title":"Seminar 6: Parallelization and contact","text":"Concept of parallelization\nGPU based\navoided, because the whole paradigm is different","category":"section"},{"location":"lecture/seminar_6/#CPU-based","page":"Seminar 6","title":"CPU based","text":"beginbmatrix1  2  3  4  5  6  7 endbmatrix_allrightarrowbeginmatrix beginbmatrix 4  6  endbmatrix_C1-global\nbeginbmatrix1  2   7 endbmatrix_C2-global\nbeginbmatrix35endbmatrix_C3-globalendmatrixleftarrow rightarrowbeginmatrix beginbmatrix 1  2  endbmatrix_C1-local\nbeginbmatrix1  2   3 endbmatrix_C2-local\nbeginbmatrix12endbmatrix_C3-localendmatrix\n\nrestructuring from fields\n\ninfo: Data access\nNot all data is avaiable at each core.\n\n$ julia\njulia> using MPI\njulia> MPI.install_mpiexecjl()\n\nRun PeriLab with two processors:\n\n$ mpiexecjl -n 2 julia -e 'using PeriLab; PeriLab.main(\"examples/DCB/DCBmodel.yaml\")'\n\nRun PeriLab with one processors:\n\njulia -e 'using PeriLab; PeriLab.main(\"examples/DCB/DCBmodel.yaml\")'","category":"section"},{"location":"lecture/seminar_6/#Multi-core-search-strategy","page":"Seminar 6","title":"Multi-core search strategy","text":"In Seminar\n\n","category":"section"},{"location":"lecture/seminar_5/#Seminar-5:-From-bond-based-to-state-based-II-(Application)","page":"Seminar 5","title":"Seminar 5: From bond-based to state-based II (Application)","text":"Convergence of the different methods\n\n(Image: )\n\nFigure taken from [36]\n\nPeriLab:\n  Discretization:\n    Node Sets:\n      Node Set 1: 1\n      Node Set 2: 5\n    Type: \"Text File\"\n    Input Mesh File: \"truss.txt\"\n  Models:\n    Material Models:\n      Test:\n        Material Model: \"PD Solid Elastic\"\n        Symmetry: \"isotropic plane stress\"\n        Young's Modulus: 7000\n        Poisson's Ratio: 0.3\n  Blocks:\n    block_1:\n      Block ID: 1\n      Material Model: \"Test\"\n      Density: 2e-9\n      Horizon: 2\n  Boundary Conditions:\n    BC_1:\n      Variable: \"Displacements\"\n      Node Set: \"Node Set 1\"\n      Coordinate: \"x\"\n      Value: \"100*t\"\n      Type: Dirichlet\n    BC_2:\n      Variable: \"Displacements\"\n      Coordinate: \"x\"\n      Node Set: \"Node Set 2\"\n      Value: \"0.1*t\"\n      Type: Dirichlet\n  Solver:\n    Material Models: True\n    Initial Time: 0.0\n    Final Time: 1.0\n    Number of Steps: 20\n    Static:\n      Show solver iteration: true\n      Residual tolerance: 1e-7\n      Solution tolerance: 1e-8\n      Residual scaling: 7000\n      m: 550\n      Maximum number of iterations: 100\n  Outputs:\n    Output1:\n      Output Filename: \"truss\"\n      Output File Type: Exodus\n      Number of Output Steps: 20\n      Output Variables:\n        Displacements: True\n        Number of Neighbors: True\n        Forces: True\n\nOrdinary PD Solid Elastic\n\nDifference to PD Solid.\n\nPeriLab:\n  Discretization:\n    Node Sets:\n      Node Set 1: 1\n      Node Set 2: 5\n    Type: \"Text File\"\n    Input Mesh File: \"truss.txt\"\n  Models:\n    Material Models:\n      Test:\n        Material Model: \"Correspondence Elastic\"\n        Symmetry: \"isotropic plane stress\"\n        Young's Modulus: 7000\n        Poisson's Ratio: 0.3\n        Global Control: true\n  Outputs:\n    Output1:\n      Output Filename: \"truss\"\n      Output File Type: Exodus\n      Number of Output Steps: 20\n      Output Variables:\n        Displacements: True\n        Number of Neighbors: True\n        Forces: True\n        Cauchy Stress: True\n\nModels for the seminar","category":"section"},{"location":"lecture/seminar_5/#Create-you-own-model","page":"Seminar 5","title":"Create you own model","text":"create a mesh (block.jl is an example)\nspecify node lists for boundary conditions\ndefine your yaml file\nrun your model\nanalyse it in Paraview\n\n","category":"section"},{"location":"lecture/lecture/#Lecture-Non-local-structural-mechanics-and-peridynamics","page":"Course Description","title":"Lecture Non-local structural mechanics and peridynamics","text":"This lecture currently running as a cooperation between the Magdeburg-Stendal University of applied sciences and the Otto von Guericke University Magdeburg.\n\n\n\nIn past decades non-local field theories were developed and utilized to capture complex phenomena such as damage and fracture. In this course, basic approaches to develop a non-local theory are introduced starting from elementary structures such as rod and beam and towards the three-dimensional solids. Examples of the analysis of engineering components undergoing damage processes will be presented. The learning competence is the development and use of powerful computational methods to evaluate the mechanical behavior of components.\n\n(Image: )\n\n\n\nLecture 1\nSeminar 1: Trusses and structure of matrices\nSeminar 2: Material point method and solver\nSeminar 3: Convergence and fracture\nSeminar 4: From bond-based to state-based I (Theory)\nSeminar 5: From bond-based to state-based II (Application)\nSeminar 6: Parallelization and contact\nSeminar 7: Multi-physics\nSeminar 8: Additive manufacturing\nSeminar 9: PeriLab - Implement your own model\n\n","category":"section"},{"location":"lecture/seminar_7/#Seminar-7:-Multi-physics","page":"Seminar 7","title":"Seminar 7: Multi-physics","text":"The theory is taken from [9]","category":"section"},{"location":"lecture/seminar_7/#Thermo-mechanics","page":"Seminar 7","title":"Thermo-mechanics","text":"boldsymbolvarepsilon=boldsymbolvarepsilon_mechanical + boldsymbolvarepsilon_thermal\n\nboldsymbolvarepsilon_thermal =- boldsymbolalphatau\n\nboldsymbolsigma=mathbfCcdotcdotleft(boldsymbolvarepsilon_mechanical - boldsymbolalphatau right)","category":"section"},{"location":"lecture/seminar_7/#Thermal-flux","page":"Seminar 7","title":"Thermal flux","text":"rho C_vdottau = int_mathcalH(underlineh(textbfxt)langleboldsymbolxirangle-underlineh(textbfxt)langleboldsymbolxirangle)dV_textbfx+ S_i\n\nunderlineh(textbfxt)langleboldsymbolxirangle = mathbfq^TmathbfK^-1(textbfx)boldsymbolxi\n\nnablacdotmathbfq = int_mathcalHleftmathbfq(textbfx)^TmathbfK^-1(textbfx)+mathbfq(textbfx)^TmathbfK^-1(textbfx)rightboldsymbolxidV_textbfx\n\nmathbfq = -boldsymbollambdanablatau\n\nnablatau = mathbfK^-1int_mathcalHlefttau(mathbfx)-tau(mathbfx)rightboldsymbolxiunderlineomegalangleboldsymbolxirangle dV_mathbfx\n\nThe numerical solving process is then\n\nrho C_v fractau^t+dt-tau^tdt=nablamathbfq + S_i\n\ntau^t+dt = dtfracnablamathbfq + S_irho C_v + tau^t\n\n(Image: )","category":"section"},{"location":"lecture/seminar_7/#Heat-transfer-to-environment","page":"Seminar 7","title":"Heat transfer to environment","text":"S_i = fracq_bcDelta\n\nq_bc = kappa (tau-tau_env)\n\n2D\n\nV_2D=2pidelta^2 h geq int_mathcalHdV\n\n3D\n\nV_3D=frac43pidelta^3 geq int_mathcalHdV\n\nf_limit leq V_specific =  fracint_mathcalHdVV_2Dor3D\n\ntau_i^t+dt = dtfracnablamathbfq_i + frackappa (tau_i^t-tau_env)dx(rho C_v)_i + tau^t_i\n\n(Image: ) (Image: )\n\nusing DifferentialEquations\nusing Plots\n\n########################\nN = 201 # number of points to discretize\n# PD discretization\ndx = 0.00005\n# free length minus width of PD boundary\nL = 0.02 - 4*dx  # conduction\nh = L / (N - 1)\nX = collect(0:h:L)\nk = 3\n########################\n\nfunction odefunc!(dudt, u, p, t)\n    dudt[1] = 0  # constant at boundary condition\n    dudt[end] = 0\n    # spatial second order differentiation\n    # utilizing second order finite difference\n    for i in 2:(N-1)\n        dudt[i] = k * (u[i-1] - 2*u[i] + u[i+1]) / h^2\n    end\n    return nothing\nend\n\ninit = zeros(length(X))  # initial temperature\ninit[1] = 10.0  # one boundary condition\ninit[end] = 0   # the other boundary condition\n\ntspan = (0.0, 2e-5)\ntsave = collect(0:3e-7:2e-5)\n\n# Define the ODE problem\nprob = ODEProblem(odefunc!, init, tspan)\n\n# Solve the ODE\nsol = solve(prob, saveat=tsave)\n\n# Access solution: sol[i, j] gives u_i at time t_j\n# sol.t gives the time points\n# sol.u gives the solution at each time point\n\n# Plotting\n# Plot temperature profiles at different times\nplot(X, sol.u[1], label=\"t = $(sol.t[1])\", xlabel=\"Position (m)\", ylabel=\"Temperature\",\n     title=\"Temperature Distribution Over Time\", linewidth=2)\n\n# Add profiles at several time points\ntime_indices = [1, length(sol.t)Ã·4, length(sol.t)Ã·2, 3*length(sol.t)Ã·4, length(sol.t)]\nfor idx in time_indices[2:end]\n    plot!(X, sol.u[idx], label=\"t = $(round(sol.t[idx], digits=6))\", linewidth=2)\nend\n\n# Create heatmap showing evolution over time\n# Convert solution to matrix format (space x time)\nu_matrix = hstack([u for u in sol.u])\n\n# Create heatmap\nheatmap(sol.t, X, u_matrix, xlabel=\"Time (s)\", ylabel=\"Position (m)\",\n        title=\"Temperature Evolution\", colorbar_title=\"Temperature\")\n\n# Create animation of temperature evolution\nanim = @animate for i in 1:length(sol.t)\n    plot(X, sol.u[i], ylim=(0, 10.5), xlabel=\"Position (m)\",\n         ylabel=\"Temperature\", title=\"Temperature at t = $(round(sol.t[i], digits=6)) s\",\n         linewidth=3, color=:red, legend=false)\nend\ngif(anim, \"heat_conduction.gif\", fps=10)\n","category":"section"},{"location":"lecture/seminar_7/#Time-step","page":"Seminar 7","title":"Time step","text":"Delta t  textminleft(fracleft(rho C_vright)_isum_j=1^Nfractextmax(texteig(boldsymbollambda))mathbfxi_ijV_jright)\n\n[24]","category":"section"},{"location":"lecture/seminar_7/#Alternative-diffusion-based-models","page":"Seminar 7","title":"Alternative diffusion based models","text":"A fracp^t+dt-p^tdt=nablamathbfe + S_i\n\nParameter Description\nA is a model factor\np is the status variable\nmathbfe is the flow variable\n\nExamples are [37]\n\nCorrosion\nDiffusion\nChemical and Water Transport\n\n","category":"section"},{"location":"man/dev/parameters/#Parameters","page":"Parameters","title":"Parameters","text":"All the parameter are stored in a dictionary called params.\n\nThe essential parameter are checked in parameter_handling.jl with the variable global expectedstructure_. If parameter are not defined there, a warning is given in the log file.\n\nParameter are included via the YAML input deck. The parameter can be found in the program in a dictionary. Therefore, the parameter naming is used there as well. For some variables, e.g. boundary condition, equations can be specified. These equations are interpreted and can be used to include time or spatial depended variables.\n\nnote: Good start\nPlease check some of the full scale tests. There are several yaml files with parameter definitions.\n\n","category":"section"},{"location":"lecture/seminar_2/#Seminar-2:-Material-point-method-and-solver","page":"Seminar 2","title":"Seminar 2: Material point method and solver","text":"particle method\npoints are grid fix (no pure mesh free method)\n\nAdvantage\n\nno topology\ndisconnection of points is easy\n\nDisadvantage\n\nconvergence is low\ngradients purely described by points","category":"section"},{"location":"lecture/seminar_2/#Equations-in-the-Quasi-Static-Material-Point-Method-Algorithm","page":"Seminar 2","title":"Equations in the Quasi-Static Material Point Method Algorithm","text":"","category":"section"},{"location":"lecture/seminar_2/#**1.-Mapping-Material-Point-Quantities-to-Grid-Nodes**","page":"Seminar 2","title":"1. Mapping Material Point Quantities to Grid Nodes","text":"Nodal Mass\n\nM_textnode = sum_mp m_mp  N_mp-nd\n\nNodal Velocity\n\nmathbfV_textnode = frac1M_textnode sum_mp mathbfP_mp  N_mp-nd\n\nInternal Force Vector\n\nmathbfF_textnode^textinternal = sum_mp boldsymbolsigma_mp  nabla N_mp-nd\n\nExternal Force Vector\n\nmathbfF_textnode^textexternal = sum_mp mathbfb  N_mp-nd","category":"section"},{"location":"lecture/seminar_2/#**2.-Solving-Equations-of-Motion-on-the-Grid**","page":"Seminar 2","title":"2. Solving Equations of Motion on the Grid","text":"Nodal Acceleration\n\nmathbfA_textnode = fracmathbfF_textnode^textexternal + mathbfF_textnode^textinternalM_textnode\n\nUpdated Nodal Velocity\n\ntildemathbfV_textnode = mathbfV_textnode + mathbfA_textnode  mathrmdt","category":"section"},{"location":"lecture/seminar_2/#**3.-Mapping-Back-to-Material-Points**","page":"Seminar 2","title":"3. Mapping Back to Material Points","text":"Material Point Acceleration\n\nmathbfa_mp = sum_nd mathbfA_textnode  N_nd-mp\n\nStrain Rate (Infinitesimal Strain Theory)\n\ndotboldsymbolvarepsilon_mp = sum_nd frac12 left mathbfV_textnode nabla N_nd-mp + (mathbfV_textnode nabla N_nd-mp)^T right\n\n\n\n(Image: )\n\n\n\n(Image: ) Figure taken from [2].\n\n\n\nrho ddotu_i = frac12sum_j (f_jiV_i-f_ijV_j)+b_i\n\nF_i + b_i=rhoddotu_i\n\nStatic case\n\n(Image: ) Figure taken from [2].\n\nmathbfF(mathbfu_i+1) + mathbfb_i+1 rightarrow 0\n\n\n\nVerlet time integration\n\nmathbfu_i+1 = mathbfu_i + Delta tdotmathbfu_i + frac12 Delta t^2ddotmathbfu_i\n\nwith\n\nddotmathbfu_i = fracmathbfF_irho\n\nwhere rho is the mass density of the point and mathbfF_i=mathbfF_external-mathbfF_internal for the current time step.\n\nFor parabolic  time integration as in temperature models the following schema is used\n\nboldsymboltau_i+1 =  boldsymboltau_i - Delta t fracmathbfHrho C_v\n\nwhere rho is the mass density, C_v is the specific heat capacity and mathbfH is the heat flux of each point [10].\n\nFor the time intergration a stable increment has to be determined.","category":"section"},{"location":"lecture/seminar_2/#Volume-correction","page":"Seminar 2","title":"Volume correction","text":"(Image: )\n\nlambda_corr=frac2V_0V(mathbfx)+V(mathbfx)\n\nThe reference volumen V_0 is depended on the dimension (3D or 2D)\n\nV_0-3D=frac4pidelta^33\n\nV_0-2D=fracpidelta^2h4\n\nthis factor is than multiplied to the bond force mathbft_corr =lambda_corrmathbft\n\nwarn: Only mechanical\nSurface correction is right now only applied for mechanical properties.\n\nYou can apply the surface correction initialy for all outer surfaces and continuous, for cracks or additive manufacturing.\n\nusing Plots\nusing Polynomials\n\n# Definition des Intervalls\nx = range(0, Ï€, length=200)\ny = sin.(x)\n\n# Plot vorbereiten\nplot(x, y,\n    label=\"sin(x)\",\n    lw=2,\n    legend=:bottomleft,\n    xlabel=\"x\",\n    ylabel=\"y\",\n    size=(1200, 800))\n\n# Anzahl der StÃ¼tzstellen\nn_nodes = 8\nx_nodes = range(0, Ï€, length=n_nodes)\ny_nodes = sin.(x_nodes)\n\n# Approximation mit Polynomen 2. bis 7. Ordnung\nfor deg in 1:3\n    # Polynomanpassung\n    p = fit(x_nodes, y_nodes, deg)\n    y_approx = p.(x)\n    plot!(x, y_approx, label=\"Grad $deg\")\nend\n\n# Punkte anzeigen\nscatter!(x_nodes, y_nodes, label=\"Exact solution\", color=:black)\n\n","category":"section"},{"location":"lecture/seminar_2/#Set-up-your-own-model","page":"Seminar 2","title":"Set up your own model","text":"header: x y block_id volume\n0 0 1 1\n1 0 1 1\n2 0 1 1\n3 0 1 1\n4 0 1 1\n\nfunction generate_grid_fixed_spacing(filename, x_from, x_to, y_from, y_to, dx; block_id=1)\n\n    num_points_x = Int(floor((x_to - x_from) / dx)) + 1\n    num_points_y = Int(floor((y_to - y_from) / dx)) + 1\n    volume = dx * dx\n\n    open(filename, \"w\") do io\n        println(io, \"header: x y block_id volume\")\n        for j in 0:num_points_y-1\n            y = y_from + j * dx\n            for i in 0:num_points_x-1\n                x = x_from + i * dx\n                println(io, \"$(x) $(y) $(block_id) $(volume)\")\n            end\n        end\n    end\nend\n\nPeriLab:\n  Discretization:\n    Node Sets:\n      Node Set 1: 1\n      Node Set 2: 5\n    Type: \"Text File\"\n    Input Mesh File: \"truss.txt\"\n  Models:\n    Material Models:\n      Test:\n        Material Model: \"Bond-based Elastic\"\n        Symmetry: \"isotropic plane stress\"\n        Young's Modulus: 7000\n        Poisson's Ratio: 0.3\n  Blocks:\n    block_1:\n      Block ID: 1\n      Material Model: \"Test\"\n      Density: 2e-9\n      Horizon: 2\n  Boundary Conditions:\n    BC_1:\n      Variable: \"Displacements\"\n      Node Set: \"Node Set 1\"\n      Coordinate: \"x\"\n      Value: \"100*t\"\n      Type: Dirichlet\n    BC_2:\n      Variable: \"Displacements\"\n      Coordinate: \"x\"\n      Node Set: \"Node Set 2\"\n      Value: \"0.1*t\"\n      Type: Dirichlet\n  Solver:\n    Material Models: True\n    Initial Time: 0.0\n    Final Time: 1.0\n    Number of Steps: 20\n    Static:\n      Show solver iteration: true\n      Residual tolerance: 1e-7\n      Solution tolerance: 1e-8\n      Residual scaling: 7000\n      m: 550\n      Maximum number of iterations: 100\n  Outputs:\n    Output1:\n      Output Filename: \"truss\"\n      Output File Type: Exodus\n      Number of Output Steps: 20\n      Output Variables:\n        Displacements: True\n        Number of Neighbors: True\n        Forces: True\n\n","category":"section"}]
}
